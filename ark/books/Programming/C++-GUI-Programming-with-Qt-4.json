[{"pageNumber":1,"pageContent":"C++GUI Programmingwith Qt 4"},{"pageNumber":3,"pageContent":"C++GUI Programmingwith Qt 4Jasmin BlanchetteMark SummerfieldIn association with Trolltech PressUpper Saddle River, NJ · Boston · Indianapolis · San FranciscoNew York · Toronto · Montreal · London · Munich · Paris · MadridCapetown · Sydney · Tokyo · Singapore · Mexico City"},{"pageNumber":4,"pageContent":"Many of the designations used by manufacturers and sellers to distinguish their products are claimed astrademarks. Where those designations appear in this book, and the publisher was aware of a trademarkclaim, the designations have been printed with initial capital letters or in all capitals.The authors and publisher have taken care in the preparation of this book, but make no expressed orimplied warranty of any kind and assume no responsibility for errors or omissions. No liability is assumedfor incidental or consequential damages in connection with or arising out of the use of the information orprograms contained herein.The publisher offers excellent discounts on this book when ordered in quantity for bulk purchases orspecial sales, which may include electronic versions and/or custom covers and content particular to yourbusiness, training goals, marketing focus, and branding interests. For more information, please contact: U.S. Corporate and Government Sales (800) 382-3419 corpsales@pearsontechgroup.comFor sales outside the United States, please contact: International Sales international@pearsoned.comVisit us on the Web: www.prenhallprofessional.comThis Book Is Safari EnabledThe SafariEnabled icon on the cover of your favorite technology book means the bookis available through Safari Bookshelf. When you buy this book, you get free access tothe online edition for 45 days.Safari Bookshelf is an electronic reference library that lets you easily search thousands of technical books,find code samples, download chapters, and access technical information whenever and wherever youneed it.To gain 45-day Safari Enabled access to this book:• Go to http://www.prenhallprofessional.com/safarienabled• Complete the brief registration form• Enter the coupon code FTMP-7EXM-TI8P-6GM1-3Y85If you have difficulty registering on Safari Bookshelf or accessing the online edition, please e-mailcustomer-service@safaribooksonline.com.Library of Congress Cataloging-in-Publication DataBlanchette, Jasmin. C++GUI programming with Qt 4 / Jasmin Blanchette, Mark Summerfield. p. cm. Includes bibliographical references and index. ISBN 0-13-187249-4 (pbk.: alk. paper) 1. Graphical user interfaces (Computer systems) 2. C++(Computer program language) I. Summerfield, Mark. II. Title. QA76.9.U83B532 2006 005.4’37—dc222006013376Copyright © 2006 Trolltech ASAll rights reserved. Printed in the United States of America. This publication may only be distributedsubject to the terms and conditions set forth in the Open Publication License, v1.0 or later (the latestversion is available at http://www.open-content.org/openpub/).Trolltech, Qt, Qtopia, and the Trolltech and Qtopia logos are registered trademarks of Trolltech AS.ISBN 0-13-187249-4Text printed in the United States on recycled paper at Courier in Stoughton, Massachusetts.First printing, June 2006"},{"pageNumber":5,"pageContent":"ContentsForeword. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. . . . . .ixPreface. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. . . . . . . .xiAcknowledgments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .xiiiA Brief History of Qt. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .xvPart I: Basic Qt1.Getting Started. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3Hello Qt . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. . . .3Making Connections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .5Laying Out Widgets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .6Using the Reference Documentation . . . . . . . . . . . . . . . . . . . . . . . . . .92.Creating Dialogs. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .13Subclassing QDialog . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .13Signals and Slots in Depth . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .20Rapid Dialog Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .23Shape-Changing Dialogs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .29Dynamic Dialogs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .36Built-in Widget and Dialog Classes . . . . . . . . . . . . . . . . . . . . . . . . . . .373.Creating Main Windows. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .43Subclassing QMainWindow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .44Creating Menus and Toolbars . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .48Setting Up the Status Bar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .52Implementing the File Menu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .54Using Dialogs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .61Storing Settings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .67Multiple Documents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .68Splash Screens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .71v"},{"pageNumber":6,"pageContent":"4.Implementing Application Functionality. . . . . . . . . . . . . . . . . . . . .73The Central Widget . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .73Subclassing QTableWidget . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .74Loading and Saving . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .80Implementing the Edit Menu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .83Implementing the Other Menus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .87Subclassing QTableWidgetItem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .915.Creating Custom Widgets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .101Customizing Qt Widgets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .101Subclassing QWidget . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .103Integrating Custom Widgets with Qt Designer . . . . . . . . . . . . . . . . .113Double Buffering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .116Part II: Intermediate Qt6.Layout Management. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .137Laying Out Widgets on a Form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .137Stacked Layouts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .143Splitters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. . .145Scrolling Areas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .148Dock Widgets and Toolbars . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .150Multiple Document Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1527.Event Processing. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .163Reimplementing Event Handlers . . . . . . . . . . . . . . . . . . . . . . . . . . . . .163Installing Event Filters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .168Staying Responsive During Intensive Processing . . . . . . . . . . . . . .1718.2D and 3D Graphics. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .175Painting with QPainter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .175Painter Transformations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .180High-Quality Rendering with QImage . . . . . . . . . . . . . . . . . . . . . . . . .188Printing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. . .190Graphics with OpenGL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1989.Drag and Drop. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .205Enabling Drag and Drop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .205Supporting Custom Drag Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .210Clipboard Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .215vi"},{"pageNumber":7,"pageContent":"10.Item View Classes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .217Using the Item View Convenience Classes . . . . . . . . . . . . . . . . . . . . .218Using Predefined Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .225Implementing Custom Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .230Implementing Custom Delegates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .24411.Container Classes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .251Sequential Containers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .252Associative Containers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .260Generic Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .263Strings, Byte Arrays, and Variants . . . . . . . . . . . . . . . . . . . . . . . . . . . .26512.Input/Output. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .273Reading and Writing Binary Data . . . . . . . . . . . . . . . . . . . . . . . . . . . .274Reading and Writing Text . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .279Traversing Directories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .285Embedding Resources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .286Inter-Process Communication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .28713.Databases. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. .293Connecting and Querying . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .294Presenting Data in Tabular Form . . . . . . . . . . . . . . . . . . . . . . . . . . . . .299Implementing Master–Detail Forms . . . . . . . . . . . . . . . . . . . . . . . . . .30414.Networking. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .311Writing FTP Clients . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .311Writing HTTP Clients . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .320Writing TCP Client–Server Applications . . . . . . . . . . . . . . . . . . . . . .323Sending and Receiving UDP Datagrams . . . . . . . . . . . . . . . . . . . . . . .33315.XML. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. . . . . . . .339Reading XML with SAX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .339Reading XML with DOM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .344Writing XML . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .34816.Providing Online Help. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .351Tooltips, Status Tips, and “What’s This?” Help . . . . . . . . . . . . . . . . .351Using QTextBrowser as a Simple Help Engine . . . . . . . . . . . . . . . . .353Using Qt Assistant for Powerful Online Help . . . . . . . . . . . . . . . . . .356vii"},{"pageNumber":8,"pageContent":"Part III: Advanced Qt17.Internationalization. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .361Working with Unicode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .362Making Applications Translation-Aware . . . . . . . . . . . . . . . . . . . . . .365Dynamic Language Switching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .371Translating Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .37618.Multithreading. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .381Creating Threads . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .381Synchronizing Threads . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .385Communicating with the Main Thread . . . . . . . . . . . . . . . . . . . . . . . .391Using Qt’s Classes in Secondary Threads . . . . . . . . . . . . . . . . . . . . . .39619.Creating Plugins. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .399Extending Qt with Plugins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .400Making Applications Plugin-Aware . . . . . . . . . . . . . . . . . . . . . . . . . . .408Writing Application Plugins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .41220.Platform-Specific Features. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .415Interfacing with Native APIs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .415Using ActiveX on Windows . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .419Handling X11 Session Management . . . . . . . . . . . . . . . . . . . . . . . . . . .43121.Embedded Programming. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .439Getting Started with Qtopia . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .440Customizing Qtopia Core . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .441AppendicesA.Installing Qt. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .447B.Introduction to C++for Java and C# Programmers. . . . . . . . . .451Index. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. . . . . . . . . .493viii"},{"pageNumber":9,"pageContent":"ForewordWhy Qt? Why do programmers like us choose Qt? Sure, there are the obviousanswers: Qt’s single-source compatibility, its feature richness, its C++perfor-mance, the availability of the source code, its documentation, the high-qualitytechnical support, and all the other items mentioned in Trolltech’s glossy mar-keting materials. This is all very well, but it misses the most important point:Qt is successful because programmerslikeit.How come programmers like one technology, but dislike another? Personally Ibelieve software engineers enjoy technology that feels right, but dislike every-thing that doesn’t. “Feels right” means many things. In the Qt 3 edition of thebook, I mentioned Trolltech’s phone system as a particularly good example ofsome particularly bad technology. The phone system didn’t feel right, becauseit forced us to do apparently random things depending on some equally randomcontext. Randomness doesn’t feel right. Another thing that doesn’t feel rightis repetitiveness and redundancy. Good programmers are lazy. What we loveabout computers compared to, say, gardening is that we don’t have to do thesame things over and over.Let me emphasize this point with a real-world example: travel reimbursementforms. Typically those forms come as fancy spreadsheets; you fill them out,and you get real money. Simple technology, one should think, and given themonetary incentive this should be a simple task for a grown-up engineer.Reality looks different, though. While nobody else in the company seems tohave any problems whatsoever dealing with those forms, the engineers do. Andhaving talked to people in other companies, this seems to be a common pattern.We defer reimbursement until the very last moment, and sometimes we mighteven forget about it. Why is that? Looking at our form, it’s a straightforward,standard procedure. One has to collect receipts, number them, and put thosenumbers into the proper fields with the date, the location, a description, andthe amount. The numbering and copying is designed to ease someone’s work,but strictly speaking it is redundant, given that the date, location, description,and amount unambiguously identify a receipt. A tiny bit of extra work to getyour money back, one would think.A small annoyance is the per-diem rate, though, which depends on the travellocation. There’s some separate document somewhere that lists the standard-ized rates for all the different travel locations. You can’t just select “Chicago”;instead you have to look up the rate for Chicago yourself. There’s a similarannoyance with the exchange rate field. One has to find the current exchangerate somewhere—perhaps with Google’s help—and then enter the rate in ev-ix"},{"pageNumber":10,"pageContent":"ery single field. Well, strictly speaking, you should wait for your credit cardcompany to issue a statement to you with the actual exchange rate that theyused. While this is not hard to do, looking up different pieces of informationfrom different sources, and then copying the relevant items to several placesin the form feels needlessly awkward.Programming can be a lot like filling in travel reimbursement forms, onlyworse. And this is where Qt comes to the rescue. Qt is different. For one thing,Qt makes sense. And for another, Qt is fun. Qt lets you concentrate on yourtasks. When Qt’s original architects faced a problem, they didn’t just look fora good solution, or the simplest solution. They looked for therightsolution,and then they documented it. Granted they made mistakes, and granted someof their design decisions didn’t pass the test of time, but they still got a lot ofthings right, and what wasn’t right could and can be corrected. You can seethis by the fact that a system originally designed to bridge Windows 95 andUnix/Motif now unifies modern desktop systems as diverse as Windows XP,Mac OS X, and GNU/Linux, and provides the foundation for the Qtopia appli-cation platform for embedded Linux.Long before Qt became so popular and so widely used, the dedication of Qt’sdevelopers to finding the right solutions made Qt special. That dedication isjust as strong today and affects everyone who develops and maintains Qt. Forus, working on Qt is a responsibility and a privilege. We are proud of helpingto make your professional and open source lives easier and more enjoyable.Matthias EttrichOslo, NorwayJune 2006x"},{"pageNumber":11,"pageContent":"PrefaceQt is a comprehensive C++framework for developing cross-platform GUI appli-cations using a “write once, compile anywhere” approach. Qt lets programmersuse a single source tree for applications that will run on Windows 98 to XP,Mac OS X, Linux, Solaris, HP-UX, and many other versions of Unix with X11.The Qt libraries and tools are also part of Qtopia Core, a product that providesits own window system on top of embedded Linux.The purpose of this book is to teach you how to write GUI programs using Qt 4.The book starts with “Hello Qt” and quickly progresses to more advanced top-ics, such as creating custom widgets and providing drag and drop. The text iscomplemented by a CD that contains the source code of the example programs.The CD also includes the open source edition of Qt 4.1.1 for all supported plat-forms, as well as MinGW, a set of freely available development tools that can beused to build Qt applications on Windows. Appendix A explains how to installthe software.The book is divided into three parts. Part I covers all the concepts and practicesnecessary for programming GUI applications using Qt. Knowledge of this partalone is sufficient to write useful GUI applications. Part II covers central Qttopics in greater depth, and Part III provides more specialized and advancedmaterial. The chapters of Parts II and III can be read in any order, but theyassume familiarity with the contents of Part I.Readers of the Qt 3 edition of this book will find this new edition familiar inboth content and style. This edition has been updated to take advantage ofQt 4’s new features (including some that were introduced with Qt 4.1) andto present code that shows good idiomatic Qt 4 programming techniques. Inmany cases, we have used examples similar to the ones used in the Qt 3 edition.This will not affect new readers, but will help those who read the previousedition orient themselves to Qt 4’s cleaner, clearer, and more expressive style.This edition includes new chapters covering Qt 4’s model/view architecture,the new plugin framework, and embedded programming with Qtopia, as wella new appendix. And just like the Qt 3 book, the emphasis is on explaining Qtprogramming rather than simply rehashing or summarizing Qt’s extensiveonline documentation.We have written the book with the assumption that you have a basic knowl-edge of C++, Java, or C#. The code examples use a subset of C++, avoidingmany C++features that are rarely needed when programming Qt. In the fewplaces where a more advanced C++construct is unavoidable, it is explainedwhere it is used.xi"},{"pageNumber":12,"pageContent":"If you already know Java or C# but have little or no experience with C++, werecommend that you begin by reading Appendix B, which provides sufficientintroduction to C++to be able to use this book. For a more thorough introduc-tion to object-oriented programming in C++, we recommendC++How to Pro-gramby Harvey Deitel and Paul Deitel, and theC++Primerby Stanley B. Lipp-man, Josée Lajoie, and Barbara E. Moo.Qt made its reputation as a cross-platform framework, but because of its intu-itive and powerful API, many organizations use Qt for single-platform develop-ment. Adobe Photoshop Album is just one example of a mass-market Windowsapplication written in Qt. Many sophisticated software systems in verticalmarkets, such as 3D animation tools, digital film processing, electronic designautomation (for chip design), oil and gas exploration, financial services, andmedical imaging, are built with Qt. If you are making a living with a success-ful Windows product written in Qt, you can easily create new markets in theMac OS X and Linux worlds simply by recompiling.Qt is available under various licenses. If you want to build commercial applica-tions, you must buy a commercial Qt license; if you want to build open sourceprograms, you can use the open source (GPL) edition. Qt is the foundation onwhich the K Desktop Environment (KDE) and the many open source applica-tions that go with it are built.In addition to Qt’s hundreds of classes, there are add-ons that extend Qt’s scopeand power. Some of these products, like Qt Script for Applications (QSA) andthe Qt Solutions components, are available from Trolltech, while others aresupplied by other companies and by the open source community. Seehttp://www.trolltech.com/products/3rdparty/for information on Qt add-ons. Qt alsohas a well-established and thriving user community that uses theqt-interestmailing list; seehttp://lists.trolltech.com/for details.If you spot errors in the book, have suggestions for the next edition, or want togive us feedback, we would be delighted to hear from you. You can reach us atqt-book@trolltech.com. The errata will be placed onhttp://doc.trolltech.com/qt-book-errata.html.xii"},{"pageNumber":13,"pageContent":"AcknowledgmentsOur first acknowledgment is of Eirik Chambe-Eng, Trolltech’s president.Eirik not only enthusiastically encouraged us to write the Qt 3 edition of thebook, he also allowed us to spend a considerable amount of our work timewriting it. Eirik and Trolltech CEO Haavard Nord both read the manuscriptand provided valuable feedback. Their generosity and foresight was aided andabetted by Matthias Ettrich, Trolltech’s lead developer. Matthias cheerfullyaccepted our neglect of duty as we obsessed over the writing of the first editionof this book and gave us a lot of advice on good Qt programming style.For the Qt 3 edition, we asked two Qt customers, Paul Curtis and KlausSchmidinger, to be our external reviewers. Both are Qt experts with an amaz-ing attention to technical detail, which they proved by spotting some very sub-tle errors in our manuscript and suggesting numerous improvements. Andwithin Trolltech, alongside Matthias, our most stalwart reviewer was ReginaldStadlbauer. His technical insight was invaluable, and he taught us how to dosome things in Qt that we didn’t even know were possible.For this Qt 4 edition, we have continued to benefit from the unstinting helpand support of Eirik, Haavard, and Matthias. Klaus Schmidinger continued togive valuable feedback, and within Trolltech, our key reviewers were AndreasAardal Hanssen, Henrik Hartz, Vivi Glückstad Karlsen, Trenton Schulz, AndyShaw, and Pål de Vibe.In addition to the reviewers mentioned above, we received expert help fromHarald Fernengel (databases), Volker Hilsheimer (ActiveX), Bradley Hughes(multithreading), Trond Kjernåsen (3D graphics and databases), Lars Knoll(2D graphics and internationalization), Sam Magnuson (qmake), Marius BuggeMonsen (item view classes), Dimitri Papadopoulos (Qt/X11), Paul Olav Tvete(custom widgets and embedded programming), Rainer Schmid (networkingand XML), Amrit Pal Singh (introduction to C++), and Gunnar Sletta (2Dgraphics and event processing).Extra thanks are due to Trolltech’s documentation and support teams forhandling documentation-related issues while the book consumed so much ofour time, and to Trolltech’s system administrators for keeping our machinesrunning and our networks communicating throughout the project.On the production side, Trenton Schulz created the accompanying CD, andTrolltech’s Cathrine Bore handled the contracts and legalities on our behalf.Thanks also to Nathan Clement for the Troll illustrations. And last but notleast, thanks to Lara Wysong from Pearsons, for handling the productionpracticalities so well.xiii"},{"pageNumber":15,"pageContent":"A Brief History of QtThe Qt framework first became publicly available in May 1995. It was initiallydeveloped by Haavard Nord (Trolltech’s CEO) and Eirik Chambe-Eng (Troll-tech’s president). Haavard and Eirik met at the Norwegian Institute of Tech-nology in Trondheim, where they both graduated with master’s degrees in com-puter science.Haavard’s interest in C++GUI development began in 1988 when he was com-missioned by a Swedish company to develop a C++GUI framework. A couple ofyears later, in the summer of 1990, Haavard and Eirik were working togetheron a C++database application for ultrasound images. The system needed to beable to run with a GUI on Unix, Macintosh, and Windows. One day that sum-mer, Haavard and Eirik went outside to enjoy the sunshine, and as they saton a park bench, Haavard said, “We need an object-oriented display system.”The resulting discussion laid the intellectual foundation for the object-orientedcross-platform GUI framework they would soon go on to build.In 1991, Haavard started writing the classes that eventually became Qt, col-laborating with Eirik on the design. The following year, Eirik came up with theidea for “signals and slots”, a simple but powerful GUI programming paradigmthat has now been embraced by several other toolkits. Haavard took the ideaand produced a hand-coded implementation. By 1993, Haavard and Eirik haddeveloped Qt’s first graphics kernel and were able to implement their own wid-gets. At the end of the year, Haavard suggested that they go into business to-gether to build “the world’s best C++GUI framework”.The year 1994 began inauspiciously with the two young programmers wantingto enter a well-established market, with no customers, an unfinished product,and no money. Fortunately, both their wives were employed and therefore ableto support their husbands for the two years Eirik and Haavard expected toneed to develop the product and start earning an income.The letter ‘Q’ was chosen as the class prefix because the letter looked beautifulin Haavard’s Emacs font. The ‘t’ was added to stand for “toolkit”, inspired byXt, the X Toolkit. The company was incorporated on March 4, 1994, originallyas Quasar Technologies, then as Troll Tech, and today as Trolltech.In April 1995, thanks to a contact made through one of Haavard’s universityprofessors, the Norwegian company Metis gave them a contract to developsoftware based on Qt. Around this time, Trolltech hired Arnt Gulbrandsen,who during his six years at Trolltech devised and implemented an ingeniousdocumentation system as well as contributing to Qt’s code.xv"},{"pageNumber":16,"pageContent":"On May 20, 1995, Qt 0.90 was uploaded tosunsite.unc.edu. Six days later, therelease was announced oncomp.os.linux.announce. This was Qt’s first publicrelease. Qt could be used for both Windows and Unix development, offeringthe same API on both platforms. Qt was available under two licenses fromday one: A commercial license was required for commercial development,and a free software edition was available for open source development. TheMetis contract kept Trolltech afloat, while for ten long months no one boughta commercial Qt license.In March 1996, the European Space Agency became the second Qt customer,with a purchase of ten commercial licenses. With unwavering faith, Eirik andHaavard hired another developer. Qt 0.97 was released at the end of May, andon September 24, 1996, Qt 1.0 came out. By the end of the year, Qt had reachedversion 1.1; eight customers, each in a different country, had bought 18 licensesbetween them. This year also saw the founding of the KDE project, led byMatthias Ettrich.Qt 1.2 was released in April 1997. Matthias Ettrich’s decision to use Qt to buildKDE helped Qt become the de facto standard for C++GUI development onLinux. Qt 1.3 was released in September 1997.Matthias joined Trolltech in 1998, and the last major Qt 1 release, 1.40, wasmade in September of that year. Qt 2.0 was released in June 1999. Qt 2 hada new open source license, the Q Public License (QPL), which complied withthe Open Source Definition. In August 1999, Qt won the LinuxWorld awardfor best library/tool. Around this time, Trolltech Pty Ltd (Australia) was es-tablished.Trolltech released Qtopia Core (then called Qt/Embedded) in 2000. It was de-signed to run on embedded Linux devices and provided its own window sys-tem as a lightweight replacement for X11. Both Qt/X11 and Qtopia Core werenow offered under the widely used GNU General Public License (GPL) as wellas under commercial licenses. By the end of 2000, Trolltech had establishedTrolltech Inc. (USA) and had released the first version of Qtopia, an applicationplatform for mobile phones and PDAs. Qtopia Core won the LinuxWorld “BestEmbedded Linux Solution” award in both 2001 and 2002, and Qtopia Phoneachieved the same distinction in 2004.Qt 3.0 was released in 2001. Qt was now available on Windows, Mac OS X,Unix, and Linux (desktop and embedded). Qt 3 provided 42 new classes and itscode exceeded 500,000 lines. Qt 3 was a major step forward from Qt 2, includ-ing considerably improved locale and Unicode support, a completely new textviewing and editing widget, and a Perl-like regular expression class. Qt 3 wonthe Software Development Times “Jolt Productivity Award” in 2002.In the summer of 2005, Qt 4.0 was released. With about 500 classes and morethan 9000 functions, Qt 4 is larger and richer than any previous version, andit has been split into several libraries so that developers only need to linkagainst the parts of Qt that they need. Qt 4 is a huge advance on previousversions with improvements that include a completely new set of efficient andxvi"},{"pageNumber":17,"pageContent":"easy-to-use template containers, advanced model/view functionality, a fastand flexible 2D painting framework, and powerful Unicode text viewing andediting classes, not to mention thousands of smaller enhancements across thecomplete range of Qt classes. Qt 4 is the first Qt edition to be available for bothcommercial and open source development on all the platforms it supports.Also in 2005, Trolltech opened a representative office in Beijing to providecustomers in China and the region with sales services, training, and technicalsupport for Qtopia.Since Trolltech’s birth, Qt’s popularity has grown unabated and continues togrow to this day. This success is a reflection both of the quality of Qt and ofhow enjoyable it is to use. In the last decade, Qt has gone from being a productused by a select few “in the know” to one that is used daily by thousands of cus-tomers and tens of thousands of open source developers all around the world.xvii"},{"pageNumber":19,"pageContent":"Part IBasic Qt"},{"pageNumber":21,"pageContent":"1. Getting StarteduHello QtuMaking ConnectionsuLaying Out WidgetsuUsing the Reference DocumentationThis chapter shows how to combine basic C++with the functionality providedby Qt to create a few small graphical user interface (GUI) applications. Thischapter also introduces two key Qt ideas: “signals and slots” and layouts. InChapter 2, we will go into more depth, and in Chapter 3, we will start buildinga more realistic application.If you already know Java or C# but have limited experience with C++, youmight want to start by reading the C++introduction in Appendix B.Hello QtLet’s start with a very simple Qt program. We will first study it line by line,then we will see how to compile and run it.001#include <QApplication>002#include <QLabel>003int main(int argc, char *argv[])004{005 QApplication app(argc, argv);006 QLabel *label = new QLabel(\"Hello Qt!\");007 label->show();008 return app.exec();009}Lines 1 and 2 include the definitions of theQApplicationandQLabelclasses. Forevery Qt class, there is a header file with the same name (and capitalization)as the class that contains the class’s definition.Line 5 creates aQApplicationobject to manage application-wide resources.TheQApplicationconstructor requiresargcandargvbecause Qt supports a fewcommand-line arguments of its own.Line 6 creates aQLabelwidget that displays “Hello Qt!”. In Qt and Unix termi-nology, awidgetis a visual element in a user interface. The term stems from3"},{"pageNumber":22,"pageContent":"41. Getting Started“window gadget” and is the equivalent of both “control” and “container” in Win-dows terminology. Buttons, menus, scroll bars, and frames are all examples ofwidgets. Widgets can contain other widgets; for example, an application win-dow is usually a widget that contains aQMenuBar, a fewQToolBars, aQStatusBar,and some other widgets. Most applications use aQMainWindowor aQDialogas theapplication window, but Qt is so flexible that any widget can be a window. Inthis example, theQLabelwidget is the application window.Line 7 makes the label visible. Widgets are always created hidden, so that wecan customize them before showing them, thereby avoiding flicker.Line 8 passes control of the application on to Qt. At this point, the program en-ters the event loop. This is a kind of stand-by mode where the program waitsfor user actions such as mouse clicks and key presses. User actions generateevents(also called “messages”) to which the program can respond, usually byexecuting one or more functions. For example, when the user clicks a widget,a “mouse press” and a “mouse release” event are generated. In this respect,GUI applications differ drastically from conventional batch programs, whichtypically process input, produce results, and terminate without human inter-vention.For simplicity, we don’t bother callingdeleteon theQLabelobject at the end ofthemain()function. This memory leak is harmless in such a small program,since the memory will be reclaimed by the operating system when the programterminates.Figure 1.1.Hello on LinuxIt is now possible to try the program on your own machine. First, you willneed to install Qt 4.1.1 (or a later Qt 4 release), a process that is explained inAppendix A. From now on, we will assume that you have a correctly installedcopy of Qt 4 and that Qt’sbindirectory is in yourPATHenvironment variable.(On Windows, this is done automatically by the Qt installation program.) Youwill also need the program’s source code in a file calledhello.cppin a directorycalledhello. You can type inhello.cppyourself, or copy it from the CD providedwith this book, where it is available as/examples/chap01/hello/hello.cpp.From a command prompt, change the directory tohello, then typeqmake -projectto create a platform-independent project file (hello.pro), then typeqmake hello.proto create a platform-specific makefile from the project file."},{"pageNumber":23,"pageContent":"Hello Qt5Typemaketo build the program.HRun it by typinghelloon Windows,./helloon Unix, andopen hello.appon Mac OS X. To terminate the program, click theclose button in the window’s title bar.If you are using Windows and have installed the Qt Open Source Editionand the MinGW compiler, you will have a shortcut to a DOS Prompt windowthat has all the environment variables correctly set up for Qt. If you startthis window, you can compile Qt applications within it usingqmakeandmakeasdescribed above. The executables produced are put in the application’sdebugorreleasefolder, for example,C:\\qt-book\\hello\\release\\hello.exe.If you are using Microsoft Visual C++, you will need to runnmakeinstead ofmake. Alternatively, you can create a Visual Studio project file fromhello.proby typingqmake -tp vc hello.proand then build the program in Visual Studio. If you are using Xcode on MacOS X, you can generate an Xcode project using the commandqmake -spec macx-xcodeFigure 1.2.A label with basic HTML formattingBefore we go on to the next example, let’s have some fun: Replace the lineQLabel *label = new QLabel(\"Hello Qt!\");withQLabel *label = new QLabel(\"<h2><i>Hello</i> \"  \"<font color=red>Qt!</font></h2>\");and rebuild the application. As the example illustrates, it’s easy to brighten upa Qt application’s user interface using some simple HTML-style formatting.Making ConnectionsThe second example shows how to respond to user actions. The applicationconsists of a button that the user can click to quit. The source code is verysimilar to Hello, except that we are using aQPushButtoninstead of aQLabelasour main widget, and we are connecting a user action (clicking a button) to apiece of code.HIf you get a compiler error on the<QApplication>include, it probably means that you are using anolder version of Qt. Make sure that you are using Qt 4.1.1 or a later Qt 4 release."},{"pageNumber":24,"pageContent":"61. Getting StartedThis application’s source code is on the CD in the file/examples/chap01/quit/quit.cpp. Here’s the contents of the file:001#include <QApplication>002#include <QPushButton>003int main(int argc, char *argv[])004{005 QApplication app(argc, argv);006 QPushButton *button = new QPushButton(\"Quit\");007 QObject::connect(button, SIGNAL(clicked()),008 &app, SLOT(quit()));009 button->show();010 return app.exec();011}Qt’s widgets emitsignalsto indicate that a user action or a change of state hasoccurred.HFor instance,QPushButtonemits aclicked()signal when the userclicks the button. A signal can be connected to a function (called aslotin thatcontext), so that when the signal is emitted, the slot is automatically executed.In our example, we connect the button’sclicked()signal to theQApplicationobject’squit()slot. TheSIGNAL()andSLOT()macros are part of the syntax; theyare explained in more detail in the next chapter.Figure 1.3.The Quit applicationWe will now build the application. We assume that you have created a directorycalledquitcontainingquit.cpp. Runqmakein thequitdirectory to generate theproject file, then run it again to generate a makefile, as follows:qqmake -projectqmake quit.proNow build the application, and run it. If you clickQuit, or pressSpace(whichpresses the button), the application will terminate.Laying Out WidgetsIn this section, we will create a small example application that demonstrateshow to use layouts to manage the geometry of widgets in a window and howto use signals and slots to synchronize two widgets. The application asks forthe user’s age, which the user can enter by manipulating either a spin box ora slider.HQt signals are unrelated to Unix signals. In this book, we are only concerned with Qt signals."},{"pageNumber":25,"pageContent":"Laying Out Widgets7The application consists of three widgets: aQSpinBox, aQSlider, and aQWidget.TheQWidgetis the application’s main window. TheQSpinBoxand theQSliderare rendered inside theQWidget; they arechildrenof theQWidget. Alternatively,we can say that theQWidgetis theparentof theQSpinBoxand theQSlider. TheQWidgethas no parent itself because it is being used as a top-level window. Theconstructors forQWidgetand all of its subclasses take aQWidget *parameterthat specifies the parent widget.Figure 1.4.The Age applicationHere’s the source code:001#include <QApplication>002#include <QHBoxLayout>003#include <QSlider>004#include <QSpinBox>005int main(int argc, char *argv[])006{007 QApplication app(argc, argv);008 QWidget *window = new QWidget;009 window->setWindowTitle(\"Enter Your Age\");010 QSpinBox *spinBox = new QSpinBox;011 QSlider *slider = new QSlider(Qt::Horizontal);012 spinBox->setRange(0, 130);013 slider->setRange(0, 130);014 QObject::connect(spinBox, SIGNAL(valueChanged(int)),015 slider, SLOT(setValue(int)));016 QObject::connect(slider, SIGNAL(valueChanged(int)),017 spinBox, SLOT(setValue(int)));018 spinBox->setValue(35);019 QHBoxLayout *layout = new QHBoxLayout;020 layout->addWidget(spinBox);021 layout->addWidget(slider);022 window->setLayout(layout);023 window->show();024 return app.exec();025}Lines 8 and 9 set up theQWidgetthat will serve as the application’s mainwindow. We callsetWindowTitle()to set the text displayed in the window’stitle bar."},{"pageNumber":26,"pageContent":"81. Getting StartedLines 10 and 11 create aQSpinBoxand aQSlider, and lines 12 and 13 set theirvalid ranges. We can safely assume that the user is at most 130 years old. Wecould passwindowto theQSpinBoxandQSliderconstructors, specifying that thesewidgets should havewindowas their parent, but it isn’t necessary here becausethe layout system will figure this out by itself and automatically set the parentof the spin box and the slider, as we will see shortly.The twoQObject::connect()calls shown in lines 14 to 17 ensure that the spinbox and the slider are synchronized so that they always show the same val-ue. Whenever the value of one widget changes, itsvalueChanged(int)signal isemitted, and thesetValue(int)slot of the other widget is called with the newvalue.Line 18 sets the spin box value to 35. When this happens, theQSpinBoxemitsthevalueChanged(int)signal with anintargument of 35. This argument ispassed to theQSlider’ssetValue(int)slot, which sets the slider value to 35. Theslider then emits thevalueChanged(int)signal, because its own value changed,triggering the spin box’ssetValue(int)slot. But at this point,setValue(int)doesn’t emit any signal, since the spin box value is already 35. This preventsinfinite recursion. Figure 1.5 summarizes the situation.1.00×©setValue(35)2.35×©valueChanged(35)setValue(35)3.35×©valueChanged(35)setValue(35)4.35×©Figure 1.5.Changing one widget’s value changes bothIn lines 19 to 22, we lay out the spin box and slider widgets using alayoutmanager. A layout manager is an object that sets the size and position of thewidgets that lie under its responsibility. Qt has three main layout managerclasses:"},{"pageNumber":27,"pageContent":"Laying Out Widgets9•QHBoxLayoutlays out widgets horizontally from left to right (right to left forsome cultures).•QVBoxLayoutlays out widgets vertically from top to bottom.•QGridLayoutlays out widgets in a grid.The call toQWidget::setLayout()on line 22 installs the layout manager on thewindow. Behind the scenes, theQSpinBoxandQSliderare “reparented” to bechildren of the widget on which the layout is installed, and for this reason wedon’t need to specify an explicit parent when we construct a widget that willbe put in a layout.Window Title5QSpinBoxQSliderQHBoxLaQHBoxLayoutQWidgetQWidgetFigure 1.6.The Age application’s widgetsEven though we didn’t set the position or size of any widget explicitly, theQSpinBoxandQSliderappear nicely laid out side by side. This is becauseQHBox-Layoutautomatically assigns reasonable positions and sizes to the widgets forwhich it is responsible, based on their needs. The layout managers free us fromthe chore of hard-coding screen positions in our applications and ensure thatwindows resize smoothly.Qt’s approach to building user interfaces is simple to understand and very flex-ible. The most common pattern that Qt programmers use is to instantiate therequired widgets and then set their properties as necessary. Programmers addthe widgets to layouts, which automatically take care of sizing and positioning.User interface behavior is managed by connecting widgets together using Qt’ssignals and slots mechanism.Using the Reference DocumentationQt’s reference documentation is an essential tool for any Qt developer, sinceit covers every class and function in Qt. This book makes use of many Qtclasses and functions, but it does not cover all of them, nor does it provideevery detail of those that are mentioned. To get the most benefit from Qt, youshould familiarize yourself with the Qt reference documentation as quicklyas possible.The documentation is available in HTML format in Qt’sdoc/htmldirectoryand can be read using any web browser. You can also useQt Assistant, the Qthelp browser, which has powerful searching and indexing features that makeit quicker and easier to use than a web browser. To launchQt Assistant, click"},{"pageNumber":28,"pageContent":"101. Getting StartedQt by Trolltech v4.x.y|Assistantin theStartmenu on Windows, typeassistanton thecommand line on Unix, or double-clickAssistantin the Mac OS X Finder.The links in the “API Reference” section on the home page provide differentways of navigating Qt’s classes. The “All Classes” page lists every class in Qt’sAPI. The “Main Classes” page lists only the most commonly used Qt classes. Asan exercise, you might want to look up the classes and functions that we haveused in this chapter.Figure 1.7.Qt’s documentation inQt Assistanton Mac OS XNote that inherited functions are documented in the base class; for example,QPushButtonhas noshow()function of its own, but it inherits one from itsancestorQWidget. Figure 1.8 shows how the classes we have seen so far relateto each other.QObjectQCoreApplicationQWidgetQLayoutQApplicationQBoxLayoutQAbstractButton QAbstractSpinBoxQAbstractSliderQFrameQHBoxLayoutQPushButtonQSpinBoxQSliderQLabelFigure 1.8.Inheritance tree for the Qt classes seen so far"},{"pageNumber":29,"pageContent":"Using the Reference Documentation11The reference documentation for the current version of Qt and for some earlierversions is available online athttp://doc.trolltech.com/. This site also hasselected articles fromQt Quarterly, the Qt programmers’ newsletter sent to allcommercial licensees.Widget StylesThe screenshots we have seen so far have been taken on Linux, but Qtapplications look native on every supported platform. Qt achieves this byemulating the platform’s look and feel, rather than wrapping a particularplatform or toolkit’s widget set.WindowsPlastiqueCDEMotifFigure 1.9.Styles available everywhereWith Qt/X11 and Qtopia Core, the default style is Plastique, which usesgradients and anti-aliasing to provide a modern look and feel. Qt applica-tion users can override the default style by using the-stylecommand-lineoption. For example, to launch the Age application using the Motif style onX11, simply type./age -style motifon the command line.Windows XPMacFigure 1.10.Platform-specific stylesUnlike the other styles, the Windows XP and Mac styles are only availableon their native platforms, since they rely on the platforms’ theme engines."},{"pageNumber":30,"pageContent":"121. Getting StartedThis chapter has introduced the key concepts of signal–slot connections andlayouts. It has also begun to reveal Qt’s consistent and fully object-oriented ap-proach to the construction and use of widgets. If you browse through Qt’s doc-umentation, you will find a uniformity of approach that makes it straightfor-ward to learn how to use new widgets, and you will also find that Qt’s carefullychosen names for functions, parameters, enums, and so on, make programmingin Qt surprisingly pleasant and easy.The following chapters of Part I build on the fundamentals covered here, show-ing how to create complete GUI applications with menus, toolbars, documentwindows, a status bar, and dialogs, along with the underlying functionality toread, process, and write files."},{"pageNumber":31,"pageContent":"2. Creating DialogsuSubclassing QDialoguSignals and Slots in DepthuRapid Dialog DesignuShape-Changing DialogsuDynamic DialogsuBuilt-in Widget and Dialog ClassesThis chapter will teach you how to create dialog boxes using Qt. Dialog boxespresent users with options and choices, and allow them to set the optionsto their preferred values and to make their choices. They are called dialogboxes, or simply “dialogs”, because they provide a means by which users andapplications can “talk to” each other.Most GUI applications consist of a main window with a menu bar and toolbar,along with dozens of dialogs that complement the main window. It is alsopossible to create dialog applications that respond directly to the user’s choicesby performing the appropriate actions (for example, a calculator application).We will create our first dialog purely by writing code to show how it is done.Then we will see how to build dialogs usingQt Designer, Qt’s visual design tool.UsingQt Designeris a lot faster than hand-coding and makes it easy to testdifferent designs and to change designs later.Subclassing QDialogOur first example is a Find dialog written entirely in C++. We will implementthe dialog as a class in its own right. By doing so, we make it an independent,self-contained component, with its own signals and slots.Figure 2.1.The Find dialog13"},{"pageNumber":32,"pageContent":"142. Creating DialogsThe source code is spread across two files:finddialog.handfinddialog.cpp. Wewill start withfinddialog.h.001#ifndef FINDDIALOG_H002#define FINDDIALOG_H003#include <QDialog>004class QCheckBox;005class QLabel;006class QLineEdit;007class QPushButton;Lines 1 and 2 (and 27) protect the header file against multiple inclusions.Line 3 includes the definition ofQDialog, the base class for dialogs in Qt.QDialoginheritsQWidget.Lines 4 to 7 are forward declarations of the Qt classes that we will use toimplement the dialog. Aforward declarationtells the C++compiler that aclass exists, without giving all the detail that a class definition (usually locatedin a header file of its own) provides. We will say more about this shortly.Next, we defineFindDialogas a subclass ofQDialog:008class FindDialog : public QDialog009{010 Q_OBJECT011public:012 FindDialog(QWidget *parent = 0);TheQ_OBJECTmacro at the beginning of the class definition is necessary for allclasses that define signals or slots.TheFindDialogconstructor is typical of Qt widget classes. Theparentparame-ter specifies the parent widget. The default is a null pointer, meaning that thedialog has no parent.013signals:014 void findNext(const QString &str, Qt::CaseSensitivity cs);015 void findPrevious(const QString &str, Qt::CaseSensitivity cs);Thesignalssection declares two signals that the dialog emits when the userclicks theFindbutton. If theSearch backwardoption is enabled, the dialog emitsfindPrevious(); otherwise, it emitsfindNext().Thesignalskeyword is actually a macro. The C++preprocessor converts it intostandard C++before the compiler sees it.Qt::CaseSensitivityis an enum typethat can take the valuesQt::CaseSensitiveandQt::CaseInsensitive.016private slots:017 void findClicked();018 void enableFindButton(const QString &text);019private:"},{"pageNumber":33,"pageContent":"Subclassing QDialog15020 QLabel *label;021 QLineEdit *lineEdit;022 QCheckBox *caseCheckBox;023 QCheckBox *backwardCheckBox;024 QPushButton *findButton;025 QPushButton *closeButton;026};027#endifIn the class’s private section, we declare two slots. To implement the slots, wewill need to access most of the dialog’s child widgets, so we keep pointers tothem as well. Theslotskeyword is, likesignals, a macro that expands into aconstruct that the C++compiler can digest.For the private variables, we used forward declarations of their classes. Thiswas possible because they are all pointers and we don’t access them in theheader file, so the compiler doesn’t need the full class definitions. We couldhave included the relevant header files (<QCheckBox>,<QLabel>, etc.), but usingforward declarations when it is possible makes compiling somewhat faster.We will now look atfinddialog.cpp, which contains the implementation of theFindDialogclass.001#include <QtGui>002#include \"finddialog.h\"First, we include<QtGui>, a header file that contains the definition of Qt’s GUIclasses. Qt consists of several modules, each of which lives in its own library.The most important modules areQtCore,QtGui,QtNetwork,QtOpenGL,QtSql,QtSvg, andQtXml. The<QtGui>header file contains the definition of all theclasses that are part of theQtCoreandQtGuimodules. Including this headersaves us the bother of including every class individually.Infiledialog.h, instead of including<QDialog>and using forward declarationsforQCheckBox,QLabel,QLineEdit, andQPushButton, we could simply have included<QtGui>. However, it is generally bad style to include such a big header file fromanother header file, especially in larger applications.003FindDialog::FindDialog(QWidget *parent)004 : QDialog(parent)005{006 label = new QLabel(tr(\"Find &what:\"));007 lineEdit = new QLineEdit;008 label->setBuddy(lineEdit);009 caseCheckBox = new QCheckBox(tr(\"Match &case\"));010 backwardCheckBox = new QCheckBox(tr(\"Search &backward\"));011 findButton = new QPushButton(tr(\"&Find\"));012 findButton->setDefault(true);013 findButton->setEnabled(false);014 closeButton = new QPushButton(tr(\"Close\"));"},{"pageNumber":34,"pageContent":"162. Creating DialogsOn line 4, we pass on theparentparameter to the base class constructor. Thenwe create the child widgets. Thetr()function calls around the string literalsmark them for translation to other languages. The function is declared inQObjectand every subclass that contains theQ_OBJECTmacro. It’s a good habitto surround user-visible strings withtr(), even if you don’t have immediateplans for translating your applications to other languages. Translating Qtapplications is covered in Chapter 17.In the string literals, we use ampersands (‘&’) to indicate shortcut keys. Forexample, line 11 creates aFindbutton, which the user can activate by pressingAlt+Fon platforms that support shortcut keys. Ampersands can also be usedto control focus: On line 6 we create a label with a shortcut key (Alt+W), andon line 8 we set the label’s buddy to be the line editor. Abuddyis a widgetthat accepts the focus when the label’s shortcut key is pressed. So when theuser pressesAlt+W(the label’s shortcut), the focus goes to the line editor (thelabel’s buddy).On line 12, we make theFindbutton the dialog’s default button by callingset-Default(true). The default button is the button that is pressed when the userhitsEnter. On line 13, we disable theFindbutton. When a widget is disabled, itis usually shown grayed out and will not respond to user interaction.015 connect(lineEdit, SIGNAL(textChanged(const QString &)),016 this, SLOT(enableFindButton(const QString &)));017 connect(findButton, SIGNAL(clicked()),018 this, SLOT(findClicked()));019 connect(closeButton, SIGNAL(clicked()),020 this, SLOT(close()));The private slotenableFindButton(const QString &)is called whenever the textin the line editor changes. The private slotfindClicked()is called when theuser clicks theFindbutton. The dialog closes itself when the user clicksClose.Theclose()slot is inherited fromQWidget, and its default behavior is to hidethe widget from view (without deleting it). We will look at the code for theenableFindButton()andfindClicked()slots later on.SinceQObjectis one ofFindDialog’s ancestors, we can omit theQObject::prefixin front of theconnect()calls.021 QHBoxLayout *topLeftLayout = new QHBoxLayout;022 topLeftLayout->addWidget(label);023 topLeftLayout->addWidget(lineEdit);024 QVBoxLayout *leftLayout = new QVBoxLayout;025 leftLayout->addLayout(topLeftLayout);026 leftLayout->addWidget(caseCheckBox);027 leftLayout->addWidget(backwardCheckBox);028 QVBoxLayout *rightLayout = new QVBoxLayout;029 rightLayout->addWidget(findButton);030 rightLayout->addWidget(closeButton);031 rightLayout->addStretch();"},{"pageNumber":35,"pageContent":"Subclassing QDialog17032 QHBoxLayout *mainLayout = new QHBoxLayout;033 mainLayout->addLayout(leftLayout);034 mainLayout->addLayout(rightLayout);035 setLayout(mainLayout);Next, we lay out the child widgets using layout managers. Layouts can containboth widgets and other layouts. By nestingQHBoxLayouts,QVBoxLayouts, andQGridLayouts in various combinations, it is possible to build very sophisticateddialogs.Window Title5QLabelQLineEditQCheckBoxQCheckBoxQPushButtonQPushButtonεεεεεεεleftLaleftLayouttopLeftLatopLeftLayoutightLarightLayoutmainLamainLayoutspacerspacerFigure 2.2.The Find dialog’s layoutsFor the Find dialog, we use twoQHBoxLayouts and twoQVBoxLayouts, as shown inFigure 2.2. The outer layout is the main layout; it is installed on theFindDialogon line 35 and is responsible for the dialog’s entire area. The other threelayouts are sub-layouts. The little “spring” at the bottom right of Figure 2.2 isa spacer item (or “stretch”). It uses up the empty space below theFindandClosebuttons, ensuring that these buttons occupy the top of their layout.One subtle aspect of the layout manager classes is that they are not widgets.Instead, they inheritQLayout, which in turn inheritsQObject. In the figure, wid-gets are represented by solid outlines and layouts are represented by dashedoutlines to highlight the difference between them. In a running application,layouts are invisible.When the sub-layouts are added to the parent layout (lines 25, 33, and 34),the sub-layouts are automatically reparented. Then, when the main layoutis installed on the dialog (line 35), it becomes a child of the dialog, and all thewidgets in the layouts are reparented to become children of the dialog. Theresulting parent–child hierarchy is depicted in Figure 2.3.036 setWindowTitle(tr(\"Find\"));037 setFixedHeight(sizeHint().height());038}Finally, we set the title to be shown in the dialog’s title bar and we set thewindow to have a fixed height, since there aren’t any widgets in the dialog that"},{"pageNumber":36,"pageContent":"182. Creating Dialogscan meaningfully occupy any extra vertical space. TheQWidget::sizeHint()function returns a widget’s “ideal” size.This completes the review ofFindDialog’s constructor. Since we usednewtocreate the dialog’s widgets and layouts, it would seem that we need to writea destructor that callsdeleteon each of the widgets and layouts we created.But this isn’t necessary, since Qt automatically deletes child objects when theparent is destroyed, and the child widgets and layouts are all descendants oftheFindDialog.FindDialogQLabel (label)QLineEdit (lineEdit)QCheckBox (caseCheckBox)QCheckBox (backwardCheckBox)QPushButton (findButton)QPushButton (closeButton)QHBoxLayout (mainLayout)QVBoxLayout (leftLayout)QHBoxLayout (topLeftLayout)QVBoxLayout (rightLayout)Figure 2.3.The Find dialog’s parent–child relationshipsNow we will look at the dialog’s slots:039void FindDialog::findClicked()040{041 QString text = lineEdit->text();042 Qt::CaseSensitivity cs =043 caseCheckBox->isChecked() ? Qt::CaseSensitive044  : Qt::CaseInsensitive;045 if (backwardCheckBox->isChecked()) {046 emit findPrevious(text, cs);047 } else {048 emit findNext(text, cs);049 }050}051void FindDialog::enableFindButton(const QString &text)052{053 findButton->setEnabled(!text.isEmpty());054}ThefindClicked()slot is called when the user clicks theFindbutton. It emitsthefindPrevious()or thefindNext()signal, depending on theSearch backwardoption. Theemitkeyword is specific to Qt; like other Qt extensions it isconverted into standard C++by the C++preprocessor."},{"pageNumber":37,"pageContent":"Subclassing QDialog19TheenableFindButton()slot is called whenever the user changes the text in theline editor. It enables the button if there is some text in the editor, and disablesit otherwise.These two slots complete the dialog. We can now create amain.cppfile to testourFindDialogwidget:001#include <QApplication>002#include \"finddialog.h\"003int main(int argc, char *argv[])004{005 QApplication app(argc, argv);006 FindDialog *dialog = new FindDialog;007 dialog->show();008 return app.exec();009}To compile the program, runqmakeas usual. Since theFindDialogclass defini-tion contains theQ_OBJECTmacro, the makefile generated byqmakewill includespecial rules to runmoc, Qt’s meta-object compiler. (Qt’s meta-object system iscovered in the next section.)Formocto work correctly, we must put the class definition in a header file,separate from the implementation file. The code generated bymocincludes thisheader file and adds some C++magic of its own.Classes that use theQ_OBJECTmacro must havemocrun on them. This isn’t aproblem becauseqmakeautomatically adds the necessary rules to the makefile.But if you forget to regenerate your makefile usingqmakeandmocisn’t run, thelinker will complain that some functions are declared but not implemented.The messages can be fairly obscure. GCC produces warnings like this one:finddialog.o: In function ‘FindDialog::tr(char const*, char const*)’:/usr/lib/qt/src/corelib/global/qglobal.h:1430: undefined reference to‘FindDialog::staticMetaObject’Visual C++’s output starts like this:finddialog.obj : error LNK2001: unresolved external symbol\"public:~virtual int __thiscall MyClass::qt_metacall(enum QMetaObject::Call,int,void * *)\"If this ever happens to you, runqmakeagain to update the makefile, thenrebuild the application.Now run the program. If shortcut keys are shown on your platform, verifythat the shortcut keysAlt+W,Alt+C,Alt+B, andAlt+Ftrigger the correct behavior.PressTabto navigate through the widgets with the keyboard. The defaulttab order is the order in which the widgets were created. This can be changedusingQWidget::setTabOrder()."},{"pageNumber":38,"pageContent":"202. Creating DialogsProviding a sensible tab order and keyboard shortcuts ensures that userswho don’t want to (or cannot) use a mouse are able to make full use of theapplication. Full keyboard control is also appreciated by fast typists.In Chapter 3, we will use the Find dialog inside a real application, and we willconnect thefindPrevious()andfindNext()signals to some slots.Signals and Slots in DepthThe signals and slots mechanism is fundamental to Qt programming. It en-ables the application programmer to bind objects together without the objectsknowing anything about each other. We have already connected some signalsand slots together, declared our own signals and slots, implemented our ownslots, and emitted our own signals. Let’s take a moment to look at the mecha-nism more closely.Slots are almost identical to ordinary C++member functions. They can be vir-tual; they can be overloaded; they can be public; protected, or private, they canbe directly invoked like any other C++member functions; and their parameterscan be of any types. The difference is that a slot can also be connected to asignal, in which case it is automatically called each time the signal is emitted.Theconnect()statement looks like this:connect(sender, SIGNAL(signal), receiver, SLOT(slot));wheresenderandreceiverare pointers toQObjects and wheresignalandslotare function signatures without parameter names. TheSIGNAL()andSLOT()macros essentially convert their argument to a string.In the examples we have seen so far, we have always connected differentsignals to different slots. There are other possibilities to consider.•One signal can be connected to many slots:connect(slider, SIGNAL(valueChanged(int)), spinBox, SLOT(setValue(int)));connect(slider, SIGNAL(valueChanged(int)), this, SLOT(updateStatusBarIndicator(int)));When the signal is emitted, the slots are called one after the other, in anunspecified order.•Many signals can be connected to the same slot:connect(lcd, SIGNAL(overflow()), this, SLOT(handleMathError()));connect(calculator, SIGNAL(divisionByZero()), this, SLOT(handleMathError()));When either signal is emitted, the slot is called."},{"pageNumber":39,"pageContent":"Signals and Slots in Depth21•A signal can be connected to another signal:connect(lineEdit, SIGNAL(textChanged(const QString &)), this, SIGNAL(updateRecord(const QString &)));When the first signal is emitted, the second signal is emitted as well.Apart from that, signal–signal connections are indistinguishable fromsignal–slot connections.•Connections can be removed:disconnect(lcd, SIGNAL(overflow()), this, SLOT(handleMathError()));This is rarely needed, because Qt automatically removes all connectionsinvolving an object when that object is deleted.To successfully connect a signal to a slot (or to another signal), they must havethe same parameter types in the same order:connect(ftp, SIGNAL(rawCommandReply(int, const QString &)), this, SLOT(processReply(int, const QString &)));Exceptionally, if a signal has more parameters than the slot it is connected to,the additional parameters are simply ignored:connect(ftp, SIGNAL(rawCommandReply(int, const QString &)), this, SLOT(checkErrorCode(int)));If the parameter types are incompatible, or if the signal or the slot doesn’texist, Qt will issue a warning at run-time if the application is built in debugmode. Similarly, Qt will give a warning if parameter names are included inthe signal or slot signatures.So far, we have only used signals and slots with widgets. But the mechanismitself is implemented inQObjectand isn’t limited to GUI programming. Themechanism can be used by anyQObjectsubclass:class Employee : public QObject{ Q_OBJECTpublic: Employee() { mySalary = 0; } int salary() const { return mySalary; }public slots: void setSalary(int newSalary);signals: void salaryChanged(int newSalary);private: int mySalary;};"},{"pageNumber":40,"pageContent":"222. Creating Dialogsvoid Employee::setSalary(int newSalary){ if (newSalary != mySalary) { mySalary = newSalary; emit salaryChanged(mySalary); }}Notice how thesetSalary()slot is implemented. We only emit thesalary-Changed()signal ifnewSalary != mySalary. This ensures that cyclic connectionsdon’t lead to infinite loops.Qt’s Meta-Object SystemOne of Qt’s major achievements has been the extension of C++with amechanism for creating independent software components that can bebound together without any component knowing anything about the othercomponents it is connected to.The mechanism is called themeta-object system, and it provides two keyservices: signals–slots and introspection. The introspection functionalityis necessary for implementing signals and slots, and allows applicationprogrammers to obtain “meta-information” aboutQObjectsubclasses atrun-time, including the list of signals and slots supported by the object andits class name. The mechanism also supports properties (forQt Designer)and text translation (for internationalization), and it lays the foundationfor Qt Script for Applications (QSA).Standard C++doesn’t provide support for the dynamic meta-informationneeded by Qt’s meta-object system. Qt solves this problem by providinga separate tool,moc, that parsesQ_OBJECTclass definitions and makes theinformation available through C++functions. Sincemocimplements allits functionality using pure C++, Qt’s meta-object system works with anyC++compiler.The mechanism works as follows:• TheQ_OBJECTmacro declares some introspection functions that mustbe implemented in everyQObjectsubclass:metaObject(),tr(),qt_metacall(), and a few more.• Qt’smoctool generates implementations for the functions declared byQ_OBJECTand for all the signals.•QObjectmember functions such asconnect()anddisconnect()use theintrospection functions to do their work.All of this is handled automatically byqmake,moc, andQObject, so yourarely need to think about it. But if you are curious, you can check out theQMetaObjectclass documentation and have a look at the C++source filesgenerated bymocto see how the implementation works."},{"pageNumber":41,"pageContent":"Rapid Dialog Design23Rapid Dialog DesignQt is designed to be pleasant and intuitive to hand-code, and it is not unusu-al for programmers to develop entire Qt applications purely by writing C++source code. Still, many programmers prefer to use a visual approach for de-signing forms, because they find it more natural and faster than hand-coding,and they want to be able to experiment with and change designs more quicklyand easily than is possible with hand-coded forms.Qt Designerexpands the options available to programmers by providing avisual design capability.Qt Designercan be used to develop all or just someof an application’s forms. Forms that are created usingQt Designerend upas C++code, soQt Designercan be used with a conventional tool chain andimposes no special requirements on the compiler.In this section, we will useQt Designerto create the Go-to-Cell dialog shownin Figure 2.4. And whether we do it in code or inQt Designer, creating a dialogalways involves the same fundamental steps:• Create and initialize the child widgets.• Put the child widgets in layouts.• Set the tab order.• Establish signal–slot connections.• Implement the dialog’s custom slots.Figure 2.4.The Go-to-Cell dialogTo launchQt Designer, clickQt by Trolltech v4.x.y|Designerin theStartmenu onWindows, typedesigneron the command line on Unix, or double-clickDesignerin the Mac OS X Finder. WhenQt Designerstarts, it will pop up a list of tem-plates. Click the “Widget” template, then clickOK. (The “Dialog with ButtonsBottom” template might look tempting, but for this example we will create theOKandCancelbuttons by hand to show how it is done.) You should now havea window called “Untitled”.By default,Qt Designer’s user interface consists of several top-level windows.If you prefer an MDI-style interface, with one top-level window and severalsub-windows, clickEdit|User Interface Mode|Docked Window.The first step is to create the child widgets and place them on the form. Createone label, one line editor, one horizontal spacer, and two push buttons. For each"},{"pageNumber":42,"pageContent":"242. Creating Dialogsitem, drag its name or icon fromQt Designer’s widget box and drop the itemroughly where it should go on the form. The spacer item, which is invisible inthe final form, is shown inQt Designeras a blue spring.Figure 2.5.Qt Designerin docked window mode on WindowsNow drag the bottom of the form up to make it shorter. This should producea form that is similar to Figure 2.6. Don’t spend too much time positioning theitems on the form; Qt’s layout managers will lay them out precisely later on.Figure 2.6.The form with some widgetsSet each widget’s properties usingQt Designer’s property editor:1. Click the text label. Make sure that itsobjectNameproperty is “label” andset thetextproperty to “&Cell Location:”.2. Click the line editor. Make sure that theobjectNameproperty is“lineEdit”.3. Click the first button. Set theobjectNameproperty to “okButton”, theenabledproperty to “false”, thetextproperty to “OK”, and thedefaultproperty to “true”.4. Click the second button. Set theobjectNameproperty to “cancelButton” andthetextproperty to “Cancel”.5. Click the form’s background to select the form itself. SetobjectNameto“GoToCellDialog” andwindowTitleto “Go to Cell”."},{"pageNumber":43,"pageContent":"Rapid Dialog Design25All the widgets look fine now, except the text label, which shows&Cell Location.ClickEdit|Edit Buddiesto enter a special mode that allows you to set buddies.Next, click the label and drag the red arrow line to the line editor, then release.The label should now showCell Locationand have the line editor as its buddy.ClickEdit|Edit Widgetsto leave buddy mode.Figure 2.7.The form with properties setThe next step is to lay out the widgets on the form:1. Click theCell Locationlabel and pressShiftas you click the line editor nextto it so that they are both selected. ClickForm|Lay Out Horizontally.2. Click the spacer, then holdShiftas you click the form’sOKandCancelbuttons. ClickForm|Lay Out Horizontally.3. Click the background of the form to deselect any selected items, then clickForm|Lay Out Vertically.4. ClickForm|Adjust Sizeto resize the form to its preferred size.The red lines that appear on the form show the layouts that have been created.They don’t appear when the form is run.Figure 2.8.The form with the layoutsNow clickEdit|Edit Tab Order. A number in a blue rectangle will appear next toevery widget that can accept focus. Click each widget in turn in the order youwant them to accept focus, then clickEdit|Edit Widgetsto leave tab order mode.Figure 2.9.Setting the form’s tab order"},{"pageNumber":44,"pageContent":"262. Creating DialogsTo preview the dialog, click theForm|Previewmenu option. Check the tab orderby pressingTabrepeatedly. Close the dialog using the close button in thetitle bar.Save the dialog asgotocelldialog.uiin a directory calledgotocell, and createamain.cppfile in the same directory using a plain text editor:#include <QApplication>#include <QDialog>#include \"ui_gotocelldialog.h\"int main(int argc, char *argv[]){ QApplication app(argc, argv); Ui::GoToCellDialog ui; QDialog *dialog = new QDialog; ui.setupUi(dialog); dialog->show(); return app.exec();}Now runqmaketo create a.profile and a makefile (qmake -project;qmake goto-cell.pro). Theqmaketool is smart enough to detect the user interface filegoto-celldialog.uiand to generate the appropriate makefile rules to invokeuic, Qt’suser interface compiler. Theuictool convertsgotocelldialog.uiinto C++andputs the result inui_gotocelldialog.h.The generatedui_gotocelldialog.hfile contains the definition of theUi::GoToCellDialogclass, which is a C++equivalent of thegotocelldialog.uifile.The class declares member variables that store the form’s child widgets andlayouts, and asetupUi()function that initializes the form. The generated classlooks like this:class Ui::GoToCellDialog{public: QLabel *label; QLineEdit *lineEdit; QSpacerItem *spacerItem; QPushButton *okButton; QPushButton *cancelButton; ... void setupUi(QWidget *widget) { ... }};The generated class doesn’t inherit any Qt class. When we use the form inmain.cpp, we create aQDialogand pass it tosetupUi()."},{"pageNumber":45,"pageContent":"Rapid Dialog Design27If you run the program now, the dialog will work, but it doesn’t function exactlyas we want:• TheOKbutton is always disabled.• TheCancelbutton does nothing.• The line editor accepts any text, instead of only accepting valid celllocations.We can make the dialog function properly by writing some code. The cleanestapproach is to create a new class that inherits bothQDialogandUi::GoToCell-Dialogand that implements the missing functionality (thus proving the adagethat any software problem can be solved simply by adding another layer ofindirection). Our naming convention is to give this new class the same name astheuic-generated class but without theUi::prefix.Using a text editor, create a file calledgotocelldialog.hthat contains thefollowing code:#ifndef GOTOCELLDIALOG_H#define GOTOCELLDIALOG_H#include <QDialog>#include \"ui_gotocelldialog.h\"class GoToCellDialog : public QDialog, public Ui::GoToCellDialog{ Q_OBJECTpublic: GoToCellDialog(QWidget *parent = 0);private slots: void on_lineEdit_textChanged();};#endifThe implementation belongs ingotocelldialog.cpp:#include <QtGui>#include \"gotocelldialog.h\"GoToCellDialog::GoToCellDialog(QWidget *parent) : QDialog(parent){ setupUi(this); QRegExp regExp(\"[A-Za-z][1-9][0-9]{0,2}\"); lineEdit->setValidator(new QRegExpValidator(regExp, this)); connect(okButton, SIGNAL(clicked()), this, SLOT(accept())); connect(cancelButton, SIGNAL(clicked()), this, SLOT(reject()));}"},{"pageNumber":46,"pageContent":"282. Creating Dialogsvoid GoToCellDialog::on_lineEdit_textChanged(){ okButton->setEnabled(lineEdit->hasAcceptableInput());}In the constructor, we callsetupUi()to initialize the form. Thanks to multipleinheritance, we can accessUi::GoToCellDialog’s members directly. After creat-ing the user interface,setupUi()will also automatically connect any slots thatfollow the naming conventionon_objectName_signalName()to the correspondingobjectName’ssignalName()signal. In our example, this means thatsetupUi()willestablish the following signal–slot connection:connect(lineEdit, SIGNAL(textChanged(const QString &)), this, SLOT(on_lineEdit_textChanged()));Also in the constructor, we set up a validator to restrict the range of the input.Qt provides three built-in validator classes:QIntValidator,QDoubleValidator,andQRegExpValidator. Here we use aQRegExpValidatorwith the regular expres-sion “[A-Za-z][1-9][0-9]{0,2}”, which means: Allow one uppercase or lowercaseletter, followed by one digit in the range 1 to 9, followed by zero, one, or twodigits each in the range 0 to 9. (For an introduction to regular expressions, seetheQRegExpclass documentation.)By passingthisto theQRegExpValidatorconstructor, we make it a child of theGoToCellDialogobject. By doing so, we don’t have to worry about deletingtheQRegExpValidatorlater; it will be deleted automatically when its parentis deleted.Qt’s parent–child mechanism is implemented inQObject. When we create anobject (a widget, validator, or any other kind) with a parent, the parent addsthe object to the list of its children. When the parent is deleted, it walksthrough its list of children and deletes each child. The children themselvesthen delete all of their children, and so on recursively until none remain.The parent–child mechanism greatly simplifies memory management,reducing the risk of memory leaks. The only objects we must delete explicitlyare the objects we create withnewand that have no parent. And if we deletea child object before its parent, Qt will automatically remove that object fromthe parent’s list of children.For widgets, the parent has an additional meaning: Child widgets are shownwithin the parent’s area. When we delete the parent widget, not only does thechild vanish from memory, it also vanishes from the screen.At the end of the constructor, we connect theOKbutton toQDialog’saccept()slot and theCancelbutton to thereject()slot. Both slots close the dialog, butaccept()sets the dialog’s result value toQDialog::Accepted(which equals 1),andreject()sets the value toQDialog::Rejected(which equals 0). When weuse this dialog, we can use the result value to see if the user clickedOKandact accordingly."},{"pageNumber":47,"pageContent":"Rapid Dialog Design29Theon_lineEdit_textChanged()slot enables or disables theOKbutton, accordingto whether the line edit contains a valid cell location.QLineEdit::hasAccept-ableInput()uses the validator we set in the constructor.This completes the dialog. We can now rewritemain.cppto use it:#include <QApplication>#include \"gotocelldialog.h\"int main(int argc, char *argv[]){ QApplication app(argc, argv); GoToCellDialog *dialog = new GoToCellDialog; dialog->show(); return app.exec();}Rebuild the application (qmake -project;qmake gotocell.pro) and run it again.Type “A12” in the line edit, and notice that theOKbutton becomes enabled. Trytyping some random text to see how the validator does its job. ClickCanceltoclose the dialog.One of the beauties of usingQt Designeris that it allows programmers greatfreedom to modify their form designs without being forced to change theirsource code. When you develop a form purely by writing C++code, changes tothe design can be quite time-consuming. WithQt Designer, no time is lost sinceuicsimply regenerates the source code for any forms that have changed. Thedialog’s user interface is saved in a.uifile (an XML-based file format), whilecustom functionality is implemented by subclassing theuic-generated class.Shape-Changing DialogsWe have seen how to create dialogs that always show the same widgets when-ever they are used. In some cases, it is desirable to provide dialogs that canchange shape. The two most common kinds of shape-changing dialogs areex-tension dialogsandmulti-page dialogs. Both types of dialog can be implement-ed in Qt, either purely in code or usingQt Designer.Extension dialogs usually present a simple appearance but have a togglebutton that allows the user to switch between the dialog’s simple and extendedappearances. Extension dialogs are commonly used for applications that aretrying to cater for both casual and power users, hiding the advanced optionsunless the user explicitly asks to see them. In this section, we will useQtDesignerto create the extension dialog shown in Figure 2.10.The dialog is a Sort dialog in a spreadsheet application, where the user canselect one or several columns to sort on. The dialog’s simple appearance allowsthe user to enter a single sort key, and its extended appearance provides fortwo extra sort keys. AMorebutton lets the user switch between the simple andextended appearances."},{"pageNumber":48,"pageContent":"302. Creating DialogsåFigure 2.10.The Sort dialog with simple and extended appearancesWe will create the widget with its extended appearance inQt Designer, andhide the secondary and tertiary keys at run-time as needed. The widget lookscomplicated, but it’s fairly easy to do inQt Designer. The trick is to do theprimary key part first, then duplicate it twice to obtain the secondary andtertiary keys:1. ClickFile|New Formand choose the “Dialog with Buttons Right” template.2. Create theMorebutton and drag it into the vertical layout, below the ver-tical spacer. Set theMorebutton’stextproperty to “&More”, and itscheck-ableproperty to “true”. Set theOKbutton’sdefaultproperty to “true”.3. Create a group box, two labels, two comboboxes, and one horizontal spacer,and put them anywhere on the form.4. Drag the bottom right corner of the group box to make it larger. Thenmove the other widgets into the group box and position them approximate-ly as shown in Figure 2.11 (a).5. Drag the right edge of the second combobox to make it about twice as wideas the first combobox.6. Set the group box’stitleproperty to “&Primary Key”, the first label’stextproperty to “Column:”, and the second label’stextproperty to “Order:”.7. Right-click the first combobox and chooseEdit Itemsfrom the contextmenu to pop upQt Designer’s combobox editor. Create one item with thetext “None”.8. Right-click the second combobox and chooseEdit Items. Create an“Ascending” item and a “Descending” item.9. Click the group box, then clickForm|Lay Out in a Grid. Click the group boxagain and clickForm|Adjust Size. This will produce the layout shown inFigure 2.11 (b)."},{"pageNumber":49,"pageContent":"Shape-Changing Dialogs31(a) Without layout(b) With layoutFigure 2.11.Laying out the group box’s children in a gridIf a layout doesn’t turn out quite right or if you make a mistake, you canalways clickEdit|UndoorForm|Break Layout, then reposition the widgets and tryagain.(a) Without layout(b) With layoutFigure 2.12.Laying out the form’s children in a gridWe will now add theSecondary KeyandTertiary Keygroup boxes:1. Make the dialog window tall enough for the extra parts.2. Hold down theCtrlkey (Alton the Mac) and click thePrimary Keygroup boxto create a copy of the group box (and its contents) on top of the original.Drag the copy below the original group box, while still pressingCtrl(orAlt). Repeat this process to create a third group box, dragging it below thesecond group box.3. Change theirtitleproperties to “&Secondary Key” and “&Tertiary Key”.4. Create one vertical spacer and place it between the primary key group boxand the secondary key group box."},{"pageNumber":50,"pageContent":"322. Creating Dialogs5. Arrange the widgets in the grid-like pattern shown in Figure 2.12 (a).6. Click the form to deselect any selected widgets, then clickForm|Lay Out in aGrid. The form should now match Figure 2.12 (b).7. Set the two vertical spacer items’sizeHintproperty to [20, 0].The resulting grid layout has two columns and four rows, giving a total of eightcells. ThePrimary Keygroup box, the leftmost vertical spacer item, theSecondaryKeygroup box, and theTertiary Keygroup box each occupy a single cell. Thevertical layout that contains theOK,Cancel, andMorebuttons occupies two cells.That leaves two empty cells in the bottom-right of the dialog. If this isn’t whatyou have, undo the layout, reposition the widgets, and try again.Rename the form “SortDialog” and change the window title to “Sort”. Set thenames of the child widgets to those shown in Figure 2.13.yGroupBoprimaryGroupBoxyColumnComboprimaryColumnComboyOrderComboprimaryOrderCombosecondaryGroupBosecondaryGroupBoxyColumnCombosecondaryColumnComboyOrderCombosecondaryOrderComboyGroupBotertiaryGroupBoxyColumnCombotertiaryColumnComboyOrderCombotertiaryOrderCombookButtonokButtoncancelButtoncancelButtonmoreButtonmoreButtonFigure 2.13.Naming the form’s widgetsClickEdit|Edit Tab Order. Click each combobox in turn from topmost to bot-tommost, then click theOK,Cancel, andMorebuttons on the right side. ClickEdit|Edit Widgetsto leave tab order mode.Now that the form has been designed, we are ready to make it functional bysetting up some signal–slot connections.Qt Designerallows us to establishconnections between widgets that are part of the same form. We need toestablish two connections.ClickEdit|Edit Signals/Slotsto enterQt Designer’s connection mode. Connectionsare represented by blue arrows between the form’s widgets. Because we chose"},{"pageNumber":51,"pageContent":"Shape-Changing Dialogs33the “Dialog with Buttons Right” template, theOKandCancelbuttons arealready connected toQDialog’saccept()andreject()slots. Connections are alsolisted inQt Designer’s signal/slot editor window.To establish a connection between two widgets, click the sender widget anddrag the red arrow line to the receiver widget, then release. This pops up adialog that allows you to choose the signal and the slot to connect.Figure 2.14.Connecting the form’s widgetsThe first connection to establish is between themoreButtonand thesecondary-GroupBox. Drag the red arrow line between these two widgets, then choosetoggled(bool)as the signal andsetVisible(bool)as the slot. By default,Qt De-signerdoesn’t listsetVisible(bool)in the list of slots, but it will appear if youenable theShow all signals and slotsoption.Figure 2.15.Qt Designer’s connection editor"},{"pageNumber":52,"pageContent":"342. Creating DialogsThe second connection is between themoreButton’stoggled(bool)signal and thetertiaryGroupBox’ssetVisible(bool)slot. Once the connections have been made,clickEdit|Edit Widgetsto leave connection mode.Save the dialog assortdialog.uiin a directory calledsort. To add code to theform, we will use the same multiple inheritance approach that we used for theGo-to-Cell dialog in the previous section.First, create asortdialog.hfile with the following contents:#ifndef SORTDIALOG_H#define SORTDIALOG_H#include <QDialog>#include \"ui_sortdialog.h\"class SortDialog : public QDialog, public Ui::SortDialog{ Q_OBJECTpublic: SortDialog(QWidget *parent = 0); void setColumnRange(QChar first, QChar last);};#endifThen createsortdialog.cpp:001#include <QtGui>002#include \"sortdialog.h\"003SortDialog::SortDialog(QWidget *parent)004 : QDialog(parent)005{006 setupUi(this);007 secondaryGroupBox->hide();008 tertiaryGroupBox->hide();009 layout()->setSizeConstraint(QLayout::SetFixedSize);010 setColumnRange(’A’, ’Z’);011}012void SortDialog::setColumnRange(QChar first, QChar last)013{014 primaryColumnCombo->clear();015 secondaryColumnCombo->clear();016 tertiaryColumnCombo->clear();017 secondaryColumnCombo->addItem(tr(\"None\"));018 tertiaryColumnCombo->addItem(tr(\"None\"));019 primaryColumnCombo->setMinimumSize(020 secondaryColumnCombo->sizeHint());"},{"pageNumber":53,"pageContent":"Shape-Changing Dialogs35021 QChar ch = first;022 while (ch <= last) {023 primaryColumnCombo->addItem(QString(ch));024 secondaryColumnCombo->addItem(QString(ch));025 tertiaryColumnCombo->addItem(QString(ch));026 ch = ch.unicode() + 1;027 }028}The constructor hides the secondary and tertiary parts of the dialog. It alsosets thesizeConstraintproperty of the form’s layout toQLayout::SetFixedSize,making the dialog non-resizable by the user. The layout then takes over theresponsibility for resizing, and resizes the dialog automatically when childwidgets are shown or hidden, ensuring that the dialog is always displayed atits optimal size.ThesetColumnRange()slot initializes the contents of the comboboxes basedon the selected columns in the spreadsheet. We insert a “None” item in thecomboboxes for the (optional) secondary and tertiary keys.Lines 19 and 20 present a subtle layout idiom. TheQWidget::sizeHint()func-tion returns a widget’s “ideal” size, which the layout system tries to honor. Thisexplains why different kinds of widgets, or similar widgets with different con-tents, may be assigned different sizes by the layout system. For comboboxes,this means that the secondary and tertiary comboboxes, which contain “None”,end up larger than the primary combobox, which contains only single-letterentries. To avoid this inconsistency, we set the primary combobox’s minimumsize to thesecondarycombobox’s ideal size.Here is amain()test function that sets the range to include columns ‘C’ to ‘F’and then shows the dialog:#include <QApplication>#include \"sortdialog.h\"int main(int argc, char *argv[]){ QApplication app(argc, argv); SortDialog *dialog = new SortDialog; dialog->setColumnRange(’C’, ’F’); dialog->show(); return app.exec();}That completes the extension dialog. As the example illustrates, an extensiondialog isn’t much more difficult to design than a plain dialog: All we neededwas a toggle button, a few extra signal–slot connections, and a non-resizablelayout. In production applications, it is quite common for the button thatcontrols the extension to show the textAdvanced >>>when only the basic dialogis visible andAdvanced <<<when the extension is shown. This is easy to achievein Qt by callingsetText()on theQPushButtonwhenever it is clicked."},{"pageNumber":54,"pageContent":"362. Creating DialogsThe other common type of shape-changing dialogs, multi-page dialogs, areeven easier to create in Qt, either in code or usingQt Designer. Such dialogscan be built in many different ways.• AQTabWidgetcan be used in its own right. It provides a tab bar along thetop that controls a built-inQStackedWidget.• AQListWidgetand aQStackedWidgetcan be used together, with theQList-Widget’s current item determining which page theQStackedWidgetshows, byconnecting theQListWidget::currentRowChanged()signal to theQStackedWid-get::setCurrentIndex()slot.• AQTreeWidgetcan be used with aQStackedWidgetin a similar way to aQListWidget.TheQStackedWidgetclass is covered in Chapter 6 (Layout Management).Dynamic DialogsDynamic dialogs are dialogs that are created fromQt Designer.uifiles atrun-time. Instead of converting the.uifile to C++code usinguic, we can loadthe file at run-time using theQUiLoaderclass:QUiLoader uiLoader;QFile file(\"sortdialog.ui\");QWidget *sortDialog = uiLoader.load(&file);if (sortDialog) {•••}We can access the form’s child widgets usingQObject::findChild<T>():QComboBox *primaryColumnCombo = sortDialog->findChild<QComboBox *>(\"primaryColumnCombo\");if (primaryColumnCombo) {•••}ThefindChild<T>()function is a template member function that returns thechild object that matches the given name and type. Because of a compilerlimitation, it is not available for MSVC 6. If you need to use the MSVC 6compiler, call theqFindChild<T>()global function instead, which works exactlythe same way.TheQUiLoaderclass is located in a separate library. To useQUiLoaderfrom a Qtapplication, we must add this line to the application’s.profile:CONFIG += uitoolsDynamic dialogs make it possible to change the layout of a form without recom-piling the application. They can also be used to create thin-client applications,where the executable merely has a front-end form built-in and all other formsare created as required."},{"pageNumber":55,"pageContent":"Built-in Widget and Dialog Classes37Built-in Widget and Dialog ClassesQt provides a complete set of built-in widgets and common dialogs that caterfor most situations. In this section, we present screenshots of almost allof them. A few specialized widgets are deferred until later: Main windowwidgets such asQMenuBar,QToolBar, andQStatusBarare covered in Chapter 3,and layout-related widgets such asQSplitterandQScrollAreaare covered inChapter 6. Most of the built-in widgets and dialogs are used in the examplespresented in this book. In the screenshots below, the widgets are shown usingthe Plastique style.QPushButton QToolButton QCheckBox QRadioButtonFigure 2.16.Qt’s button widgetsQt provides four kinds of “buttons”:QPushButton,QToolButton,QCheckBox, andQRadioButton.QPushButtonandQToolButtonare most commonly used to initiatean action when they are clicked, but they can also behave like toggle buttons(click to press down, click to restore).QCheckBoxcan be used for independenton/off options, whereasQRadioButtons are normally mutually exclusive.QGroupBoxQFrameFigure 2.17.Qt’s single-page container widgetsQt’s container widgets are widgets that contain other widgets.QFramecan alsobe used on its own to simply draw lines and is inherited by many other widgetclasses, includingQToolBoxandQLabel."},{"pageNumber":56,"pageContent":"382. Creating DialogsQTabWidgetQToolBoxFigure 2.18.Qt’s multi-page container widgetsQTabWidgetandQToolBoxare multi-page widgets. Each page is a child widget,and the pages are numbered from 0.QListView(as list)QTreeViewQListView(as icons)QTableViewFigure 2.19.Qt’s item view widgetsThe item views are optimized for handling large amounts of data and often usescroll bars. The scroll bar mechanism is implemented inQAbstractScrollArea,a base class for item views and other kinds of scrollable widgets.Qt provides a few widgets that are used purely for displaying information.QLabelis the most important of these, and it can be used for showing rich text(using a simple HTML-like syntax) and images.QTextBrowseris a read-onlyQTextEditsubclass that has basic HTML support in-cluding lists, tables, images, and hypertext links.Qt AssistantusesQTextBrows-erto present documentation to the user."},{"pageNumber":57,"pageContent":"Built-in Widget and Dialog Classes39QLabel(text)QLCDNumber QProgressBarQLabel(image)QTextBrowserFigure 2.20.Qt’s display widgetsQt provides several widgets for data entry.QLineEditcan restrict its inputusing an input mask or a validator.QTextEditis aQAbstractScrollAreasubclasscapable of editing large amounts of text.QSpinBox QDoubleSpinBox QComboBoxQDateEdit QTimeEdit QDateTimeEditQScrollBar QSliderQLineEditQTextEdit QDialFigure 2.21.Qt’s input widgetsQt provides the standard set of common dialogs that make it easy to ask theuser to select a color, font, or file, or to print a document."},{"pageNumber":58,"pageContent":"402. Creating DialogsQColorDialog  QFontDialogFigure 2.22.Qt’s color dialog and font dialogOn Windows and Mac OS X, Qt uses the native dialogs rather than its owncommon dialogs when possible.QPageSetupDialogQFileDialog  QPrintDialogFigure 2.23.Qt’s file and print dialogsQt provides a versatile message box and an error dialog that rememberswhich messages it has shown. The progress of time-consuming operationscan be indicated usingQProgressDialogor using theQProgressBarshown earlier.QInputDialogis very convenient when a single line of text or a single numberis required from the user.A lot of ready-to-use functionality is provided by the built-in widgets andcommon dialogs. More specialized requirements can often be satisfied bysetting widget properties, or by connecting signals to slots and implementingcustom behavior in the slots."},{"pageNumber":59,"pageContent":"Built-in Widget and Dialog Classes41QInputDialog  QProgressDialogQMessageBox  QErrorMessageFigure 2.24.Qt’s feedback dialogsIn some situations, it may be desirable to create a custom widget from scratch.Qt makes this straightforward, and custom widgets can access all the sameplatform-independent drawing functionality as Qt’s built-in widgets. Customwidgets can even be integrated withQt Designerso that they can be usedin the same way as Qt’s built-in widgets. Chapter 5 explains how to createcustom widgets."},{"pageNumber":61,"pageContent":"3. Creating Main WindowsuSubclassing QMainWindowuCreating Menus and ToolbarsuSetting Up the Status BaruImplementing the File MenuuUsing DialogsuStoring SettingsuMultiple DocumentsuSplash ScreensThis chapter will teach you how to create main windows using Qt. By the end,you will be able to build an application’s entire user interface, complete withmenus, toolbars, status bar, and as many dialogs as the application requires.Figure 3.1.Spreadsheet applicationAn application’s main window provides the framework upon which the appli-cation’s user interface is built. The main window for the Spreadsheet applica-tion shown in Figure 3.1 will form the basis of this chapter. The Spreadsheetapplication makes use of the Find, Go-to-Cell, and Sort dialogs that we createdin Chapter 2.Behind most GUI applications lies a body of code that provides the underlyingfunctionality—for example, code to read and write files or to process the datapresented in the user interface. In Chapter 4, we will see how to implementsuch functionality, again using the Spreadsheet application as our example.43"},{"pageNumber":62,"pageContent":"443. Creating Main WindowsSubclassing QMainWindowAn application’s main window is created by subclassingQMainWindow. Manyof the techniques we saw in Chapter 2 for creating dialogs are also relevantfor creating main windows, since bothQDialogandQMainWindowinherit fromQWidget.Main windows can be created usingQt Designer, but in this chapter we willdo everything in code to demonstrate how it’s done. If you prefer the morevisual approach, see the “Creating Main Windows inQt Designer” chapter inQt Designer’s online manual.The source code for the Spreadsheet application’s main window is spreadacrossmainwindow.handmainwindow.cpp. Let’s start with the header file:#ifndef MAINWINDOW_H#define MAINWINDOW_H#include <QMainWindow>class QAction;class QLabel;class FindDialog;class Spreadsheet;class MainWindow : public QMainWindow{ Q_OBJECTpublic: MainWindow();protected: void closeEvent(QCloseEvent *event);We define the classMainWindowas a subclass ofQMainWindow. It contains theQ_OBJECTmacro since it provides its own signals and slots.ThecloseEvent()function is a virtual function inQWidgetthat is automaticallycalled when the user closes the window. It is reimplemented inMainWindowso that we can ask the user the standard question “Do you want to save yourchanges?” and to save user preferences to disk.private slots: void newFile(); void open(); bool save(); bool saveAs(); void find(); void goToCell(); void sort(); void about();Some menu options, likeFile|NewandHelp|About, are implemented as privateslots inMainWindow. Most slots havevoidas their return value, butsave()and"},{"pageNumber":63,"pageContent":"Subclassing QMainWindow45saveAs()return abool. The return value is ignored when a slot is executed inresponse to a signal, but when we call a slot as a function the return value isavailable to us just as it is when we call any ordinary C++function. void openRecentFile(); void updateStatusBar(); void spreadsheetModified();private: void createActions(); void createMenus(); void createContextMenu(); void createToolBars(); void createStatusBar(); void readSettings(); void writeSettings(); bool okToContinue(); bool loadFile(const QString &fileName); bool saveFile(const QString &fileName); void setCurrentFile(const QString &fileName); void updateRecentFileActions(); QString strippedName(const QString &fullFileName);The main window needs some more private slots and several private functionsto support the user interface. Spreadsheet *spreadsheet; FindDialog *findDialog; QLabel *locationLabel; QLabel *formulaLabel; QStringList recentFiles; QString curFile; enum { MaxRecentFiles = 5 }; QAction *recentFileActions[MaxRecentFiles]; QAction *separatorAction; QMenu *fileMenu; QMenu *editMenu;••• QToolBar *fileToolBar; QToolBar *editToolBar; QAction *newAction; QAction *openAction;••• QAction *aboutQtAction;};#endifIn addition to its private slots and private functions,MainWindowalso has lots ofprivate variables. All of these will be explained as we use them.We will now review the implementation:#include <QtGui>"},{"pageNumber":64,"pageContent":"463. Creating Main Windows#include \"finddialog.h\"#include \"gotocelldialog.h\"#include \"mainwindow.h\"#include \"sortdialog.h\"#include \"spreadsheet.h\"We include the<QtGui>header file, which contains the definition of all the Qtclasses used in our subclass. We also include some custom header files, notablyfinddialog.h,gotocelldialog.h, andsortdialog.hfrom Chapter 2.MainWindow::MainWindow(){ spreadsheet = new Spreadsheet; setCentralWidget(spreadsheet); createActions(); createMenus(); createContextMenu(); createToolBars(); createStatusBar(); readSettings(); findDialog = 0; setWindowIcon(QIcon(\":/images/icon.png\")); setCurrentFile(\"\");}In the constructor, we begin by creating aSpreadsheetwidget and setting it tobe the main window’s central widget. The central widget occupies the middleof the main window (see Figure 3.2). TheSpreadsheetclass is aQTableWidgetsubclass with some spreadsheet capabilities, such as support for spreadsheetformulas. We will implement it in Chapter 4.We call the private functionscreateActions(),createMenus(),createContext-Menu(),createToolBars(), andcreateStatusBar()to set up the rest of the mainwindow. We also call the private functionreadSettings()to read the applica-tion’s stored settings.We initialize thefindDialogpointer to be a null pointer; the first timeMainWin-dow::find()is called, we will create theFindDialogobject.At the end of the constructor, we set the window’s icon toicon.png, a PNG file.Qt supports many image formats, including BMP, GIF,HJPEG, PNG, PNM,XBM, and XPM. CallingQWidget::setWindowIcon()sets the icon shown in thetop-left corner of the window. Unfortunately, there is no platform-independentway of setting the application icon that appears on the desktop. Platform-spe-cific procedures are explained athttp://doc.trolltech.com/4.1/appicon.html.HGIF support is disabled in Qt by default because the decompression algorithm used by GIF fileswas patented in some countries where software patents are recognized. We believe that this patenthas now expired worldwide. To enable GIF support in Qt, pass the-qt-gifcommand-line optionto theconfigurescript or set the appropriate option in the Qt installer."},{"pageNumber":65,"pageContent":"Subclassing QMainWindow47Window Title5Menu BarToolbar AreasDock Window AreasCentral WidgetStatus BarFigure 3.2.QMainWindow’s areasGUI applications generally use many images. There are several methods forproviding images to the application. The most common are:• Storing images in files and loading them at run-time.• Including XPM files in the source code. (This works because XPM files arealso valid C++files.)• Using Qt’s resource mechanism.Here we use Qt’s resource mechanism because it is more convenient thanloading files at run-time, and it works with any supported image file format.We have chosen to store the images in the source tree in a subdirectory calledimages.To make use of Qt’s resource system, we must create a resource file and add aline to the.profile that identifies the resource file. In this example, we havecalled the resource filespreadsheet.qrc, so we put the following line in the.profile:RESOURCES = spreadsheet.qrcThe resource file itself uses a simple XML format. Here’s an extract from theone we have used:<!DOCTYPE RCC><RCC version=\"1.0\"><qresource> <file>images/icon.png</file>••• <file>images/gotocell.png</file></qresource></RCC>"},{"pageNumber":66,"pageContent":"483. Creating Main WindowsResource files are compiled into the application’s executable, so they can’t getlost. When we refer to resources, we use the path prefix:/(colon slash), whichis why the icon is specified as:/images/icon.png. Resources can be any kind offile (not just images), and we can use them in most places where Qt expects afile name. They are covered in more detail in Chapter 12.Creating Menus and ToolbarsMost modern GUI applications provide menus, context menus, and toolbars.The menus enable users to explore the application and learn how to do newthings, while the context menus and toolbars provide quick access to frequentlyused functionality.Figure 3.3.The Spreadsheet application’s menusQt simplifies the programming of menus and toolbars through its actionconcept. Anactionis an item that can be added to any number of menus andtoolbars. Creating menus and toolbars in Qt involves these steps:• Create and set up the actions.• Create menus and populate them with the actions.• Create toolbars and populate them with the actions.In the Spreadsheet application, actions are created increateActions():void MainWindow::createActions(){ newAction = new QAction(tr(\"&New\"), this); newAction->setIcon(QIcon(\":/images/new.png\")); newAction->setShortcut(tr(\"Ctrl+N\")); newAction->setStatusTip(tr(\"Create a new spreadsheet file\")); connect(newAction, SIGNAL(triggered()), this, SLOT(newFile()));TheNewaction has an accelerator (New), a parent (the main window), anicon (new.png), a shortcut key (Ctrl+N), and a status tip. We connect the action’striggered()signal to the main window’s privatenewFile()slot, which we willimplement in the next section. This connection ensures that when the userchooses theFile|Newmenu item, clicks theNewtoolbar button, or pressesCtrl+N,thenewFile()slot is called."},{"pageNumber":67,"pageContent":"Creating Menus and Toolbars49TheOpen,Save, andSave Asactions are very similar to theNewaction, so wewill skip directly to the “recently opened files” part of theFilemenu:••• for (int i = 0; i < MaxRecentFiles; ++i) { recentFileActions[i] = new QAction(this); recentFileActions[i]->setVisible(false); connect(recentFileActions[i], SIGNAL(triggered()), this, SLOT(openRecentFile())); }We populate therecentFileActionsarray with actions. Each action is hiddenand connected to theopenRecentFile()slot. Later on, we will see how the recentfile actions are made visible and used.We can now skip to theSelect Allaction:••• selectAllAction = new QAction(tr(\"&All\"), this); selectAllAction->setShortcut(tr(\"Ctrl+A\")); selectAllAction->setStatusTip(tr(\"Select all the cells in the \"  \"spreadsheet\")); connect(selectAllAction, SIGNAL(triggered()), spreadsheet, SLOT(selectAll()));TheselectAll()slot is provided by one ofQTableWidget’s ancestors,QAbstract-ItemView, so we do not have to implement it ourselves.Let’s skip further to theShow Gridaction in theOptionsmenu:••• showGridAction = new QAction(tr(\"&Show Grid\"), this); showGridAction->setCheckable(true); showGridAction->setChecked(spreadsheet->showGrid()); showGridAction->setStatusTip(tr(\"Show or hide the spreadsheet’s \"  \"grid\")); connect(showGridAction, SIGNAL(toggled(bool)), spreadsheet, SLOT(setShowGrid(bool)));Show Gridis a checkable action. It is rendered with a checkmark in the menuand implemented as a toggle button in the toolbar. When the action is turnedon, theSpreadsheetcomponent displays a grid. We initialize the action with thedefault for theSpreadsheetcomponent, so that they are synchronized at start-up. Then we connect theShow Gridaction’stoggled(bool)signal to theSpread-sheetcomponent’ssetShowGrid(bool)slot, which it inherits fromQTableWidget.Once this action is added to a menu or toolbar, the user can toggle the grid onand off.TheShow GridandAuto-Recalculateactions are independent checkable actions.Qt also supports mutually exclusive actions through theQActionGroupclass.••• aboutQtAction = new QAction(tr(\"About &Qt\"), this); aboutQtAction->setStatusTip(tr(\"Show the Qt library’s About box\"));"},{"pageNumber":68,"pageContent":"503. Creating Main Windows connect(aboutQtAction, SIGNAL(triggered()), qApp, SLOT(aboutQt()));}For theAbout Qtaction, we use theQApplicationobject’saboutQt()slot, accessiblethrough theqAppglobal variable.Figure 3.4.About QtNow that we have created the actions, we can move on to building a menusystem containing them:void MainWindow::createMenus(){ fileMenu = menuBar()->addMenu(tr(\"&File\")); fileMenu->addAction(newAction); fileMenu->addAction(openAction); fileMenu->addAction(saveAction); fileMenu->addAction(saveAsAction); separatorAction = fileMenu->addSeparator(); for (int i = 0; i < MaxRecentFiles; ++i) fileMenu->addAction(recentFileActions[i]); fileMenu->addSeparator(); fileMenu->addAction(exitAction);In Qt, menus are instances ofQMenu. TheaddMenu()function creates aQMenuwidget with the specified text and adds it to the menu bar. TheQMainWindow::menuBar()function returns a pointer to aQMenuBar. The menu bar is created thefirst timemenuBar()is called.We start by creating theFilemenu and then add theNew,Open,Save, andSave Asactions to it. We insert a separator to visually group closely relateditems together. We use aforloop to add the (initially hidden) actions from therecentFileActionsarray, and then add theexitActionaction at the end.We have kept a pointer to one of the separators. This will allow us to hide theseparator (if there are no recent files) or to show it, since we do not want toshow two separators with nothing in between. editMenu = menuBar()->addMenu(tr(\"&Edit\")); editMenu->addAction(cutAction); editMenu->addAction(copyAction);"},{"pageNumber":69,"pageContent":"Creating Menus and Toolbars51 editMenu->addAction(pasteAction); editMenu->addAction(deleteAction); selectSubMenu = editMenu->addMenu(tr(\"&Select\")); selectSubMenu->addAction(selectRowAction); selectSubMenu->addAction(selectColumnAction); selectSubMenu->addAction(selectAllAction); editMenu->addSeparator(); editMenu->addAction(findAction); editMenu->addAction(goToCellAction);Now we create theEditmenu, adding actions withQMenu::addAction()as wedid for theFilemenu, and adding the submenu withQMenu::addMenu()at theposition where we want it to appear. The submenu, like the menu it belongsto, is aQMenu. toolsMenu = menuBar()->addMenu(tr(\"&Tools\")); toolsMenu->addAction(recalculateAction); toolsMenu->addAction(sortAction); optionsMenu = menuBar()->addMenu(tr(\"&Options\")); optionsMenu->addAction(showGridAction); optionsMenu->addAction(autoRecalcAction); menuBar()->addSeparator(); helpMenu = menuBar()->addMenu(tr(\"&Help\")); helpMenu->addAction(aboutAction); helpMenu->addAction(aboutQtAction);}We create theTools,Options, andHelpmenus in a similar fashion. We insert aseparator between theOptionsandHelpmenu. In Motif and CDE styles, theseparator pushes theHelpmenu to the right; in other styles, the separator isignored.Figure 3.5.Menu bar in Motif and Windows stylesvoid MainWindow::createContextMenu(){ spreadsheet->addAction(cutAction); spreadsheet->addAction(copyAction); spreadsheet->addAction(pasteAction); spreadsheet->setContextMenuPolicy(Qt::ActionsContextMenu);}Any Qt widget can have a list ofQActions associated with it. To provide acontext menu for the application, we add the desired actions to theSpreadsheet"},{"pageNumber":70,"pageContent":"523. Creating Main Windowswidget and set that widget’s context menu policy to show a context menu withthese actions. Context menus are invoked by right-clicking a widget or bypressing a platform-specific key.Figure 3.6.The Spreadsheet application’s context menuA more sophisticated way of providing context menus is to reimplement theQWidget::contextMenuEvent()function, create aQMenuwidget, populate it withthe desired actions, and callexec()on it.void MainWindow::createToolBars(){ fileToolBar = addToolBar(tr(\"&File\")); fileToolBar->addAction(newAction); fileToolBar->addAction(openAction); fileToolBar->addAction(saveAction); editToolBar = addToolBar(tr(\"&Edit\")); editToolBar->addAction(cutAction); editToolBar->addAction(copyAction); editToolBar->addAction(pasteAction); editToolBar->addSeparator(); editToolBar->addAction(findAction); editToolBar->addAction(goToCellAction);}Creating toolbars is very similar to creating menus. We create aFiletoolbarand anEdittoolbar. Just like a menu, a toolbar can have separators.Figure 3.7.The Spreadsheet application’s toolbarsSetting Up the Status BarWith the menus and toolbars complete, we are ready to tackle the Spreadsheetapplication’s status bar.In its normal state, the status bar contains two indicators: the current cell’slocation and the current cell’s formula. The status bar is also used to displaystatus tips and other temporary messages."},{"pageNumber":71,"pageContent":"Setting Up the Status Bar53NormalStatus tipTemporary messageFigure 3.8.The Spreadsheet application’s status barTheMainWindowconstructor callscreateStatusBar()to set up the status bar:void MainWindow::createStatusBar(){ locationLabel = new QLabel(\" W999 \"); locationLabel->setAlignment(Qt::AlignHCenter); locationLabel->setMinimumSize(locationLabel->sizeHint()); formulaLabel = new QLabel; formulaLabel->setIndent(3); statusBar()->addWidget(locationLabel); statusBar()->addWidget(formulaLabel, 1); connect(spreadsheet, SIGNAL(currentCellChanged(int, int, int, int)), this, SLOT(updateStatusBar())); connect(spreadsheet, SIGNAL(modified()), this, SLOT(spreadsheetModified())); updateStatusBar();}TheQMainWindow::statusBar()function returns a pointer to the status bar. (Thestatus bar is created the first timestatusBar()is called.) The status indicatorsare simplyQLabels whose text we change whenever necessary. We have addedan indent to theformulaLabelso that the text shown in it is offset slightlyfrom the left edge. When theQLabels are added to the status bar, they areautomatically reparented to make them children of the status bar.Figure 3.8 shows that the two labels have different space requirements. Thecell location indicator requires very little space, and when the window is re-sized, any extra space should go to the cell formula indicator on the right. Thisis achieved by specifying a stretch factor of 1 in the formula label’sQStatus-Bar::addWidget()call. The location indicator has the default stretch factor of 0,meaning that it prefers not to be stretched.WhenQStatusBarlays out indicator widgets, it tries to respect each widget’sideal size as given byQWidget::sizeHint()and then stretches any stretchablewidgets to fill the available space. A widget’s ideal size is itself dependent onthe widget’s contents and varies as we change the contents. To avoid constantresizing of the location indicator, we set its minimum size to be wide enough"},{"pageNumber":72,"pageContent":"543. Creating Main Windowsto contain the largest possible text (“W999”), with a little extra space. We alsoset its alignment toQt::AlignHCenterto horizontally center the text.Near the end of the function, we connect two ofSpreadsheet’s signals to two ofMainWindow’s slots:updateStatusBar()andspreadsheetModified().void MainWindow::updateStatusBar(){ locationLabel->setText(spreadsheet->currentLocation()); formulaLabel->setText(spreadsheet->currentFormula());}TheupdateStatusBar()slot updates the cell location and the cell formulaindicators. It is called whenever the user moves the cell cursor to a new cell.The slot is also used as an ordinary function at the end ofcreateStatusBar()toinitialize the indicators. This is necessary becauseSpreadsheetdoesn’t emit thecurrentCellChanged()signal at startup.void MainWindow::spreadsheetModified(){ setWindowModified(true); updateStatusBar();}ThespreadsheetModified()slot sets thewindowModifiedproperty totrue, updat-ing the title bar. The function also updates the location and formula indicatorsso that they reflect the current state of affairs.Implementing the File MenuIn this section, we will implement the slots and private functions necessary tomake theFilemenu options work and to manage the recently opened files list.void MainWindow::newFile(){ if (okToContinue()) { spreadsheet->clear(); setCurrentFile(\"\"); }}ThenewFile()slot is called when the user clicks theFile|Newmenu option orclicks theNewtoolbar button. TheokToContinue()private function asks theuser “Do you want to save your changes?” if there are unsaved changes. It re-turnstrueif the user chooses eitherYesorNo(saving the document onYes), andit returnsfalseif the user choosesCancel. TheSpreadsheet::clear()functionclears all the spreadsheet’s cells and formulas. ThesetCurrentFile()privatefunction updates the window title to indicate that an untitled document is be-ing edited, in addition to setting thecurFileprivate variable and updating therecently opened files list."},{"pageNumber":73,"pageContent":"Implementing the File Menu55Figure 3.9.“Do you want to save your changes?”bool MainWindow::okToContinue(){ if (isWindowModified()) { int r = QMessageBox::warning(this, tr(\"Spreadsheet\"), tr(\"The document has been modified.\\n\"  \"Do you want to save your changes?\"), QMessageBox::Yes | QMessageBox::Default, QMessageBox::No, QMessageBox::Cancel | QMessageBox::Escape); if (r == QMessageBox::Yes) { return save(); } else if (r == QMessageBox::Cancel) { return false; } } return true;}InokToContinue(), we check the state of thewindowModifiedproperty. If it istrue, we display the message box shown in Figure 3.9. The message box has aYes, aNo, and aCancelbutton. TheQMessageBox::Defaultmodifier makesYesthedefault button. TheQMessageBox::Escapemodifier makes theEsckey a synonymforCancel.The call towarning()may look a bit intimidating at first sight, but the generalsyntax is straightforward:QMessageBox::warning(parent, title, message, button0, button1, ...);QMessageBoxalso providesinformation(),question(), andcritical(), each ofwhich has its own particular icon.InformationQuestionWarningCriticalFigure 3.10.Message box iconsvoid MainWindow::open(){ if (okToContinue()) {"},{"pageNumber":74,"pageContent":"563. Creating Main Windows QString fileName = QFileDialog::getOpenFileName(this,  tr(\"Open Spreadsheet\"), \".\",  tr(\"Spreadsheet files (*.sp)\")); if (!fileName.isEmpty()) loadFile(fileName); }}Theopen()slot corresponds toFile|Open. LikenewFile(), it first callsokToContin-ue()to handle any unsaved changes. Then it uses the static convenience func-tionQFileDialog::getOpenFileName()to obtain a new file name from the user.The function pops up a file dialog, lets the user choose a file, and returns the filename—or an empty string if the user clickedCancel.The first argument toQFileDialog::getOpenFileName()is the parent widget. Theparent–child relationship doesn’t mean the same thing for dialogs as for otherwidgets. A dialog is always a window in its own right, but if it has a parent, it iscentered on top of the parent by default. A child dialog also shares its parent’staskbar entry.The second argument is the title the dialog should use. The third argumenttells it which directory it should start from, in our case the current directory.The fourth argument specifies the file filters. A file filter consists of a descrip-tive text and a wildcard pattern. Had we supported comma-separated valuesfiles and Lotus 1-2-3 files in addition to Spreadsheet’s native file format, wewould have used the following filter:tr(\"Spreadsheet files (*.sp)\\n\" \"Comma-separated values files (*.csv)\\n\" \"Lotus 1-2-3 files (*.wk1 *.wks)\")TheloadFile()private function was called inopen()to load the file. We makeit an independent function because we will need the same functionality to loadrecently opened files:bool MainWindow::loadFile(const QString &fileName){ if (!spreadsheet->readFile(fileName)) { statusBar()->showMessage(tr(\"Loading canceled\"), 2000); return false; } setCurrentFile(fileName); statusBar()->showMessage(tr(\"File loaded\"), 2000); return true;}We useSpreadsheet::readFile()to read the file from disk. If loading is suc-cessful, we callsetCurrentFile()to update the window title; otherwise,Spread-sheet::readFile()will have already notified the user of the problem througha message box. In general, it is good practice to let the lower-level compo-"},{"pageNumber":75,"pageContent":"Implementing the File Menu57nents issue error messages, since they can provide the precise details of whatwent wrong.In both cases, we display a message in the status bar for 2 seconds (2000 mil-liseconds) to keep the user informed about what the application is doing.bool MainWindow::save(){ if (curFile.isEmpty()) { return saveAs(); } else { return saveFile(curFile); }}bool MainWindow::saveFile(const QString &fileName){ if (!spreadsheet->writeFile(fileName)) { statusBar()->showMessage(tr(\"Saving canceled\"), 2000); return false; } setCurrentFile(fileName); statusBar()->showMessage(tr(\"File saved\"), 2000); return true;}Thesave()slot corresponds toFile|Save. If the file already has a name because itwas opened before or has already been saved,save()callssaveFile()with thatname; otherwise, it simply callssaveAs().bool MainWindow::saveAs(){ QString fileName = QFileDialog::getSaveFileName(this,  tr(\"Save Spreadsheet\"), \".\",  tr(\"Spreadsheet files (*.sp)\")); if (fileName.isEmpty()) return false; return saveFile(fileName);}ThesaveAs()slot corresponds toFile|Save As. We callQFileDialog::getSaveFile-Name()to obtain a file name from the user. If the user clicksCancel, we returnfalse, which is propagated up to its caller (save()orokToContinue()).If the file already exists, thegetSaveFileName()function will ask the user toconfirm that they want to overwrite. This behavior can be changed by passingQFileDialog::DontConfirmOverwriteas an additional argument togetSaveFile-Name().void MainWindow::closeEvent(QCloseEvent *event){ if (okToContinue()) { writeSettings();"},{"pageNumber":76,"pageContent":"583. Creating Main Windows event->accept(); } else { event->ignore(); }}When the user clicksFile|Exitor clicks the close button in the window’s titlebar, theQWidget::close()slot is called. This sends a “close” event to the widget.By reimplementingQWidget::closeEvent(), we can intercept attempts to closethe main window and decide whether we want the window to actually closeor not.If there are unsaved changes and the user choosesCancel, we “ignore” theevent and leave the window unaffected by it. In the normal case, we acceptthe event, resulting in Qt hiding the window. We also call the private functionwriteSettings()to save the application’s current settings.When the last window is closed, the application terminates. If needed, wecan disable this behavior by settingQApplication’squitOnLastWindowClosedproperty tofalse, in which case the application keeps running until we callQApplication::quit().void MainWindow::setCurrentFile(const QString &fileName){ curFile = fileName; setWindowModified(false); QString shownName = \"Untitled\"; if (!curFile.isEmpty()) { shownName = strippedName(curFile); recentFiles.removeAll(curFile); recentFiles.prepend(curFile); updateRecentFileActions(); } setWindowTitle(tr(\"%1[*] - %2\").arg(shownName)  .arg(tr(\"Spreadsheet\")));}QString MainWindow::strippedName(const QString &fullFileName){ return QFileInfo(fullFileName).fileName();}InsetCurrentFile(), we set thecurFileprivate variable that stores the name ofthe file being edited. Before we show the file name in the title bar, we removethe file’s path withstrippedName()to make it more user-friendly.EveryQWidgethas awindowModifiedproperty that should be set totrueifthe window’s document has unsaved changes, and tofalseotherwise. OnMac OS X, unsaved documents are indicated by a dot in the close button of thewindow’s title bar; on other platforms, they are indicated by an asterisk follow-ing the file name. Qt takes care of this behavior automatically, as long as we"},{"pageNumber":77,"pageContent":"Implementing the File Menu59keep thewindowModifiedproperty up-to-date and place the marker “[*]” in thewindow title where we want the asterisk to appear when it is required.The text we passed to thesetWindowTitle()function wastr(\"%1[*] - %2\").arg(shownName) .arg(tr(\"Spreadsheet\"))TheQString::arg()function replaces the lowest-numbered “%n” parameterwith its argument and returns the resulting string. In this case,arg()is usedwith two “%n” parameters. The first call toarg()replaces “%1”; the second callreplaces “%2”. If the file name is “budget.sp” and no translation file is loaded,the resulting string would be “budget.sp[*]+--Spreadsheet”. It would have beeneasier to writesetWindowTitle(shownName + tr(\"[*] - Spreadsheet\"));but usingarg()provides more flexibility for translators.If there is a file name, we updaterecentFiles, the application’s recently openedfiles list. We callremoveAll()to remove any occurrences of the file name in thelist, to avoid duplicates; then we callprepend()to add the file name as the firstitem. After updating the list, we call the private functionupdateRecentFileAc-tions()to update the entries in theFilemenu.void MainWindow::updateRecentFileActions(){ QMutableStringListIterator i(recentFiles); while (i.hasNext()) { if (!QFile::exists(i.next())) i.remove(); } for (int j = 0; j < MaxRecentFiles; ++j) { if (j < recentFiles.count()) { QString text = tr(\"&%1 %2\")  .arg(j + 1)  .arg(strippedName(recentFiles[j])); recentFileActions[j]->setText(text); recentFileActions[j]->setData(recentFiles[j]); recentFileActions[j]->setVisible(true); } else { recentFileActions[j]->setVisible(false); } } separatorAction->setVisible(!recentFiles.isEmpty());}We begin by removing any files that no longer exist using a Java-style iterator.Some files might have been used in a previous session, but have since beendeleted. TherecentFilesvariable is of typeQStringList(list ofQStrings).Chapter 11 explains container classes such asQStringListin detail, showinghow they relate to the C++Standard Template Library (STL), and the use ofQt’s Java-style iterator classes."},{"pageNumber":78,"pageContent":"603. Creating Main WindowsWe then go through the list of files again, this time using array-style indexing.For each file, we create a string consisting of an ampersand, a digit (j+ 1), aspace, and the file name (without its path). We set the corresponding action touse this text. For example, if the first file wasC:\\My Documents\\tab04.sp, the firstaction’s text would be “&1 tab04.sp”.Actions[0]recentFileActions[0]Actions[1]recentFileActions[1]Actions[2]recentFileActions[2]Actions[3]recentFileActions[3]Actions[4]recentFileActions[4]separatorActionFigure 3.11.Filemenu with recently opened filesEvery action can have an associated “data” item of typeQVariant. TheQVarianttype can hold values of many C++and Qt types; it is covered in Chapter 11.Here, we store the full name of the file in the action’s “data” item so that wecan easily retrieve it later. We also set the action to be visible.If there are more file actions than recent files, we simply hide the extra actions.Finally, if there is at least one recent file, we set the separator to be visible.void MainWindow::openRecentFile(){ if (okToContinue()) { QAction *action = qobject_cast<QAction *>(sender()); if (action) loadFile(action->data().toString()); }}When the user chooses a recent file, theopenRecentFile()slot is called. TheokToContinue()function is used in case there are any unsaved changes, andproviding the user did not cancel, we find out which particular action invokedthe slot usingQObject::sender().Theqobject_cast<T>()function performs a dynamic cast based on the meta-information generated bymoc, Qt’s meta-object compiler. It returns a pointerof the requestedQObjectsubclass, or 0 if the object cannot be cast to that type.Unlike the Standard C++dynamic_cast<T>(), Qt’sqobject_cast<T>()works cor-rectly across dynamic library boundaries. In our example, we useqobject_cast<T>()to cast aQObjectpointer to aQActionpointer. If the cast is successful"},{"pageNumber":79,"pageContent":"Implementing the File Menu61(it should be), we callloadFile()with the full file name that we extract fromthe action’s data.Incidentally, since we know that the sender is aQAction, the program wouldstill work if we usedstatic_cast<T>()or a traditional C-style cast instead.Refer to the “Type Conversions” section of Appendix B for an overview of thedifferent C++casts.Using DialogsIn this section, we will explain how to use dialogs in Qt—how to create andinitialize them, run them, and respond to choices made by the user interactingwith them. We will make use of the Find, Go-to-Cell, and Sort dialogs that wecreated in Chapter 2. We will also create a simple About box.Figure 3.12.The Spreadsheet application’s Find dialogWe will begin with the Find dialog. Since we want the user to be able to switchbetween the main Spreadsheet window and the Find dialog at will, the Finddialog must be modeless. Amodelesswindow is one that runs independentlyof any other windows in the application.When modeless dialogs are created, they normally have their signals connectedto slots that respond to the user’s interactions.void MainWindow::find(){ if (!findDialog) { findDialog = new FindDialog(this); connect(findDialog, SIGNAL(findNext(const QString &,  Qt::CaseSensitivity)), spreadsheet, SLOT(findNext(const QString &,  Qt::CaseSensitivity))); connect(findDialog, SIGNAL(findPrevious(const QString &,  Qt::CaseSensitivity)), spreadsheet, SLOT(findPrevious(const QString &,   Qt::CaseSensitivity))); } findDialog->show(); findDialog->activateWindow();}"},{"pageNumber":80,"pageContent":"623. Creating Main WindowsThe Find dialog is a window that enables the user to search for text in thespreadsheet. Thefind()slot is called when the user clicksEdit|Findto pop upthe Find dialog. At that point, several scenarios are possible:• This is the first time the user has invoked the Find dialog.• The Find dialog was invoked before, but the user closed it.• The Find dialog was invoked before and is still visible.If the Find dialog doesn’t already exist, we create it and connect itsfindNext()andfindPrevious()signals to the correspondingSpreadsheetslots. We couldalso have created the dialog in theMainWindowconstructor, but delaying itscreation makes startup faster. Also, if the dialog is never used, it is nevercreated, saving both time and memory.Then we callshow()andactivateWindow()to ensure that the window is visibleand active. A call toshow()alone is sufficient to make a hidden window visibleand active, but the Find dialog may be invoked when its window is alreadyvisible, in which caseshow()does nothing andactivateWindow()is necessary tomake the window active. An alternative would have been to writeif (findDialog->isHidden()) { findDialog->show();} else { findDialog->activateWindow();}which is the programming equivalent of looking both ways before crossing aone-way street.We will now look at the Go-to-Cell dialog. We want the user to pop it up, use it,and close it without being able to switch to any other window in the application.This means that the Go-to-Cell dialog must be modal. Amodalwindow is awindow that pops up when invoked and blocks the application, preventing anyother processing or interactions from taking place until the window is closed.The file dialogs and message boxes we used earlier were modal.Figure 3.13.The Spreadsheet application’s Go-to-Cell dialogA dialog is modeless if it’s invoked usingshow()(unless we callsetModal()beforehand to make it modal); it is modal if it’s invoked usingexec().void MainWindow::goToCell(){ GoToCellDialog dialog(this);"},{"pageNumber":81,"pageContent":"Using Dialogs63 if (dialog.exec()) { QString str = dialog.lineEdit->text().toUpper(); spreadsheet->setCurrentCell(str.mid(1).toInt() - 1,  str[0].unicode() - ’A’); }}TheQDialog::exec()function returns a true value (QDialog::Accepted) if thedialog is accepted, and a false value (QDialog::Rejected) otherwise. Recall thatwhen we created the Go-to-Cell dialog usingQt Designerin Chapter 2, weconnectedOKtoaccept()andCanceltoreject(). If the user choosesOK, we setthe current cell to the value in the line editor.TheQTableWidget::setCurrentCell()function expects two arguments: a rowindex and a column index. In the Spreadsheet application, cell A1 is cell (0, 0)and cell B27 is cell (26, 1). To obtain the row index from theQStringreturnedbyQLineEdit::text(), we extract the row number usingQString::mid()(whichreturns a substring from the start position to the end of the string), convert it toanintusingQString::toInt(), and subtract 1. For the column number, we sub-tract the numeric value of ‘A’ from the numeric value of the string’s uppercasedfirst character. We know that the string will have the correct format becausetheQRegExpValidatorwe created for the dialog only allows theOKbutton to beenabled if we have a letter followed by up to three digits.ThegoToCell()function differs from all the code seen so far in that it createsa widget (aGoToCellDialog) as a variable on the stack. At the cost of one extraline, we could just as easily have usednewanddelete:void MainWindow::goToCell(){ GoToCellDialog *dialog = new GoToCellDialog(this); if (dialog->exec()) { QString str = dialog->lineEdit->text().toUpper(); spreadsheet->setCurrentCell(str.mid(1).toInt() - 1,  str[0].unicode() - ’A’); } delete dialog;}Creating modal dialogs (and context menus inQWidget::contextMenuEvent()reimplementations) on the stack is a common programming pattern sincewe usually don’t need the dialog (or menu) after we have used it, and it willautomatically be destroyed at the end of the enclosing scope.We will now turn to the Sort dialog. The Sort dialog is a modal dialog thatallows the user to sort the currently selected area by the columns they specify.Figure 3.14 shows an example of sorting, with column B as the primary sortkey and column A as the secondary sort key (both ascending)."},{"pageNumber":82,"pageContent":"643. Creating Main Windows(a) Before sort(b) After sortFigure 3.14.Sorting the spreadsheet’s selected areavoid MainWindow::sort(){ SortDialog dialog(this); QTableWidgetSelectionRange range = spreadsheet->selectedRange(); dialog.setColumnRange(’A’ + range.leftColumn(),  ’A’ + range.rightColumn()); if (dialog.exec()) { SpreadsheetCompare compare; compare.keys[0] = dialog.primaryColumnCombo->currentIndex(); compare.keys[1] = dialog.secondaryColumnCombo->currentIndex() - 1; compare.keys[2] = dialog.tertiaryColumnCombo->currentIndex() - 1; compare.ascending[0] = (dialog.primaryOrderCombo->currentIndex() == 0); compare.ascending[1] = (dialog.secondaryOrderCombo->currentIndex() == 0); compare.ascending[2] = (dialog.tertiaryOrderCombo->currentIndex() == 0); spreadsheet->sort(compare); }}The code insort()follows a similar pattern to that used forgoToCell():• We create the dialog on the stack and initialize it.• We pop up the dialog usingexec().• If the user clicksOK, we extract the values entered by the user from thedialog’s widgets and make use of them.ThesetColumnRange()call sets the columns available for sorting to the columnsthat are selected. For example, using the selection shown in Figure 3.14,range.leftColumn()would yield 0, giving ‘A’ + 0 = ‘A’, andrange.rightColumn()wouldyield 2, giving ‘A’ + 2 = ‘C’."},{"pageNumber":83,"pageContent":"Using Dialogs65Thecompareobject stores the primary, secondary, and tertiary sort keys andtheir sort orders. (We will see the definition of theSpreadsheetCompareclassin the next chapter.) The object is used bySpreadsheet::sort()to compare tworows. Thekeysarray stores the column numbers of the keys. For example,if the selection extends from C2 to E5, column C has position 0. Theascendingarray stores the order associated with each key as abool.QComboBox::current-Index()returns the index of the currently selected item, starting at 0. For thesecondary and tertiary keys, we subtract one from the current item to accountfor the “None” item.Thesort()function does the job, but it is a bit fragile. It assumes that the Sortdialog is implemented in a particular way, with comboboxes and “None” items.This means that if we redesign the Sort dialog, we may also need to rewritethis code. While this approach is adequate for a dialog that is only called fromone place, it opens the door to maintenance nightmares if the dialog is used inseveral places.A more robust approach is to make theSortDialogclass smarter by havingit create aSpreadsheetCompareobject itself, which can then be accessed by itscaller. This simplifiesMainWindow::sort()significantly:void MainWindow::sort(){ SortDialog dialog(this); QTableWidgetSelectionRange range = spreadsheet->selectedRange(); dialog.setColumnRange(’A’ + range.leftColumn(),  ’A’ + range.rightColumn()); if (dialog.exec()) spreadsheet->performSort(dialog.comparisonObject());}This approach leads to loosely coupled components and is almost always theright choice for dialogs that will be called from more than one place.A more radical approach would be to pass a pointer to theSpreadsheetobjectwhen initializing theSortDialogobject and to allow the dialog to operate direct-ly on theSpreadsheet. This makes theSortDialogmuch less general, since it willonly work on a certain type of widget, but it simplifies the code even further byeliminating theSortDialog::setColumnRange()function. TheMainWindow::sort()function then becomesvoid MainWindow::sort(){ SortDialog dialog(this); dialog.setSpreadsheet(spreadsheet); dialog.exec();}This approach mirrors the first: Instead of the caller needing intimate knowl-edge of the dialog, the dialog needs intimate knowledge of the data structuressupplied by the caller. This approach may be useful where the dialog needs"},{"pageNumber":84,"pageContent":"663. Creating Main Windowsto apply changes live. But just as the caller code is fragile using the first ap-proach, this third approach breaks if the data structures change.Some developers choose just one approach to using dialogs and stick with that.This has the benefit of familiarity and simplicity since all their dialog usagesfollow the same pattern, but it also misses the benefits of the approaches thatare not used. Ideally, the approach to use should be decided on a per-dialogbasis.We will round off this section with the About box. We could create a customdialog like we did for the Find or Go-to-Cell dialogs to present the informationabout the application, but since most About boxes are highly stylized, Qtprovides a simpler solution.void MainWindow::about(){ QMessageBox::about(this, tr(\"About Spreadsheet\"), tr(\"<h2>Spreadsheet 1.1</h2>\" \"<p>Copyright &copy; 2006 Software Inc.\" \"<p>Spreadsheet is a small application that \" \"demonstrates QAction, QMainWindow, QMenuBar, \" \"QStatusBar, QTableWidget, QToolBar, and many other \" \"Qt classes.\"));}The About box is obtained by callingQMessageBox::about(), a static conveniencefunction. The function is very similar toQMessageBox::warning(), except that ituses the parent window’s icon instead of the standard “warning” icon.Figure 3.15.About SpreadsheetSo far we have used several convenience static functions from bothQMessageBoxandQFileDialog. These functions create a dialog, initialize it, and callexec()on it. It is also possible, although less convenient, to create aQMessageBoxoraQFileDialogwidget like any other widget and explicitly callexec(), or evenshow(), on it."},{"pageNumber":85,"pageContent":"Storing Settings67Storing SettingsIn theMainWindowconstructor, we calledreadSettings()to load the application’sstored settings. Similarly, incloseEvent(), we calledwriteSettings()to save thesettings. These two functions are the lastMainWindowmember functions thatneed to be implemented.void MainWindow::writeSettings(){ QSettings settings(\"Software Inc.\", \"Spreadsheet\"); settings.setValue(\"geometry\", geometry()); settings.setValue(\"recentFiles\", recentFiles); settings.setValue(\"showGrid\", showGridAction->isChecked()); settings.setValue(\"autoRecalc\", autoRecalcAction->isChecked());}ThewriteSettings()function saves the main window’s geometry (position andsize), the list of recently opened files, and theShow GridandAuto-Recalculateoptions.By default,QSettingsstores the application’s settings in platform-specificlocations. On Windows, it uses the system registry; on Unix, it stores the datain text files; on Mac OS X, it uses the Core Foundation Preferences API.The constructor arguments specify the organization’s name and the applica-tion’s name. This information is used in a platform-specific way to find a loca-tion for the settings.QSettingsstores settings askey–valuepairs. Thekeyis similar to a file systempath. Subkeys can be specified using a path-like syntax (for example,findDia-log/matchCase) or usingbeginGroup()andendGroup():settings.beginGroup(\"findDialog\");settings.setValue(\"matchCase\", caseCheckBox->isChecked());settings.setValue(\"searchBackward\", backwardCheckBox->isChecked());settings.endGroup();Thevaluecan be anint, abool, adouble, aQString, aQStringList, or any othertype supported byQVariant, including registered custom types.void MainWindow::readSettings(){ QSettings settings(\"Software Inc.\", \"Spreadsheet\"); QRect rect = settings.value(\"geometry\",  QRect(200, 200, 400, 400)).toRect(); move(rect.topLeft()); resize(rect.size()); recentFiles = settings.value(\"recentFiles\").toStringList(); updateRecentFileActions(); bool showGrid = settings.value(\"showGrid\", true).toBool(); showGridAction->setChecked(showGrid);"},{"pageNumber":86,"pageContent":"683. Creating Main Windows bool autoRecalc = settings.value(\"autoRecalc\", true).toBool(); autoRecalcAction->setChecked(autoRecalc);}ThereadSettings()function loads the settings that were saved bywriteSet-tings(). The second argument to thevalue()function specifies a default value,in case there are no settings available. The default values are used the firsttime the application is run. Since no second argument is given for the recentfiles list, it will be set to an empty list on the first run.Qt provides aQWidget::setGeometry()function to complementQWidget::geome-try(), but it doesn’t always work as we would expect on X11 because of limita-tions in many window managers. For that reason, we usemove()andresize()instead. (Seehttp://doc.trolltech.com/4.1/geometry.htmlfor a detailed expla-nation.)The arrangement we opted for inMainWindow, with all theQSettings-related codeinreadSettings()andwriteSettings(), is just one of many possible approaches.AQSettingsobject can be created to query or modify some setting at any timeduring the execution of the application and from anywhere in the code.We have now completed the Spreadsheet’sMainWindowimplementation. In thefollowing sections, we will discuss how the Spreadsheet application can bemodified to handle multiple documents and how to implement a splash screen.We will complete its functionality, including handling formulas and sorting, inthe next chapter.Multiple DocumentsWe are now ready to code the Spreadsheet application’smain()function:#include <QApplication>#include \"mainwindow.h\"int main(int argc, char *argv[]){ QApplication app(argc, argv); MainWindow mainWin; mainWin.show(); return app.exec();}Thismain()function is a little bit different from those we have written so far:We have created theMainWindowinstance as a variable on the stack instead ofusingnew. TheMainWindowinstance is then automatically destroyed when thefunction terminates.With themain()function shown above, the Spreadsheet application providesa single main window and can only handle one document at a time. If wewant to edit multiple documents at the same time, we could start multipleinstances of the Spreadsheet application. But this isn’t as convenient for"},{"pageNumber":87,"pageContent":"Multiple Documents69users as having a single instance of the application providing multiple mainwindows, just as one instance of a web browser can provide multiple browserwindows simultaneously.We will modify the Spreadsheet application so that it can handle multipledocuments. First, we need a slightly differentFilemenu:•File|Newcreates a new main window with an empty document, instead ofreusing the existing main window.•File|Closecloses the current main window.•File|Exitcloses all windows.In the original version of theFilemenu, there was noCloseoption because thatwould have been the same asExit.Figure 3.16.The newFilemenuThis is the newmain()function:int main(int argc, char *argv[]){ QApplication app(argc, argv); MainWindow *mainWin = new MainWindow; mainWin->show(); return app.exec();}With multiple windows, it now makes sense to createMainWindowwithnew,because then we can usedeleteon a main window when we have finished withit to save memory.This is the newMainWindow::newFile()slot:void MainWindow::newFile(){ MainWindow *mainWin = new MainWindow; mainWin->show();}We simply create a newMainWindowinstance. It may seem odd that we don’tkeep any pointer to the new window, but that isn’t a problem since Qt keepstrack of all the windows for us."},{"pageNumber":88,"pageContent":"703. Creating Main WindowsThese are the actions forCloseandExit:void MainWindow::createActions(){••• closeAction = new QAction(tr(\"&Close\"), this); closeAction->setShortcut(tr(\"Ctrl+W\")); closeAction->setStatusTip(tr(\"Close this window\")); connect(closeAction, SIGNAL(triggered()), this, SLOT(close())); exitAction = new QAction(tr(\"E&xit\"), this); exitAction->setShortcut(tr(\"Ctrl+Q\")); exitAction->setStatusTip(tr(\"Exit the application\")); connect(exitAction, SIGNAL(triggered()), qApp, SLOT(closeAllWindows()));•••}TheQApplication::closeAllWindows()slot closes all of the application’s win-dows, unless one of them rejects the close event. This is exactly the behaviorwe need here. We don’t have to worry about unsaved changes because that’shandled inMainWindow::closeEvent()whenever a window is closed.It looks as if we have finished making the application capable of handlingmultiple windows. Unfortunately, there is a hidden problem lurking: If theuser keeps creating and closing main windows, the machine might eventuallyrun out of memory. This is because we keep creatingMainWindowwidgets innewFile()but we never delete them. When the user closes a main window, thedefault behavior is to hide it, so it still remains in memory. With many mainwindows, this can be a problem.The solution is to set theQt::WA_DeleteOnCloseattribute in the constructor:MainWindow::MainWindow(){••• setAttribute(Qt::WA_DeleteOnClose);•••}This tells Qt to delete the window when it is closed. TheQt::WA_DeleteOnCloseattribute is one of many flags that can be set on aQWidgetto influence itsbehavior.Memory leaking isn’t the only problem that we must deal with. Our originalapplication design included an implied assumption that we would only haveone main window. With multiple windows, each main window has its ownrecently opened files list and its own options. Clearly, the recently opened fileslist should be global to the whole application. We can achieve this quite easilyby declaring therecentFilesvariable static, so that only one instance of itexists for the whole application. But then we must ensure that wherever wecalledupdateRecentFileActions()to update theFilemenu, we must call it on allmain windows. Here’s the code to achieve this:"},{"pageNumber":89,"pageContent":"Multiple Documents71foreach (QWidget *win, QApplication::topLevelWidgets()) { if (MainWindow *mainWin = qobject_cast<MainWindow *>(win)) mainWin->updateRecentFileActions();}The code uses Qt’sforeachconstruct (explained in Chapter 11) to iterate overall the application’s windows and callsupdateRecentFileActions()on all widgetsof typeMainWindow. Similar code can be used for synchronizing theShow GridandAuto-Recalculateoptions, or to make sure that the same file isn’t loaded twice.Figure 3.17.SDI versus MDIApplications that provide one document per main window are said to be SDI(single document interface) applications. A common alternative on Windowsis MDI (multiple document interface), where the application has a single mainwindow that manages multiple document windows within its central area. Qtcan be used to create both SDI and MDI applications on all its supported plat-forms. Figure 3.17 shows the Spreadsheet application using both approaches.MDI is explained in Chapter 6 (Layout Management).Splash ScreensMany applications present a splash screen at startup. Some developers usea splash screen to disguise a slow startup, while others do it to satisfy theirmarketing departments. Adding a splash screen to Qt applications is veryeasy using theQSplashScreenclass.TheQSplashScreenclass shows an image before the main window appears. Itcan also write messages on the image to inform the user about the progressof the application’s initialization process. Typically, the splash screen code islocated inmain(), before the call toQApplication::exec().Next is an examplemain()function that usesQSplashScreento present asplash screen in an application that loads modules and establishes networkconnections at startup."},{"pageNumber":90,"pageContent":"723. Creating Main Windowsint main(int argc, char *argv[]){ QApplication app(argc, argv); QSplashScreen *splash = new QSplashScreen; splash->setPixmap(QPixmap(\":/images/splash.png\")); splash->show(); Qt::Alignment topRight = Qt::AlignRight | Qt::AlignTop; splash->showMessage(QObject::tr(\"Setting up the main window...\"), topRight, Qt::white); MainWindow mainWin; splash->showMessage(QObject::tr(\"Loading modules...\"), topRight, Qt::white); loadModules(); splash->showMessage(QObject::tr(\"Establishing connections...\"), topRight, Qt::white); establishConnections(); mainWin.show(); splash->finish(&mainWin); delete splash; return app.exec();}Figure 3.18.A splash screenWe have now completed the Spreadsheet application’s user interface. Inthe next chapter, we will complete the application by implementing the corespreadsheet functionality."},{"pageNumber":91,"pageContent":"4. Implementing ApplicationFunctionalityuThe Central WidgetuSubclassing QTableWidgetuLoading and SavinguImplementing the Edit MenuuImplementing the Other MenusuSubclassing QTableWidgetItemIn the previous two chapters, we explained how to create the Spreadsheetapplication’s user interface. In this chapter, we will complete the program bycoding its underlying functionality. Among other things, we will see how toload and save files, how to store data in memory, how to implement clipboardoperations, and how to add support for spreadsheet formulas toQTableWidget.The Central WidgetThe central area of aQMainWindowcan be occupied by any kind of widget. Here’san overview of the possibilities:1. Use a standard Qt widget.A standard widget likeQTableWidgetorQTextEditcan be used as a centralwidget. In this case, the application’s functionality, such as loading andsaving files, must be implemented elsewhere (for example, in aQMainWindowsubclass).2. Use a custom widget.Specialized applications often need to show data in a custom widget. Forexample, an icon editor program would have anIconEditorwidget as itscentral widget. Chapter 5 explains how to write custom widgets in Qt.3. Use a plain QWidget with a layout manager.Sometimes the application’s central area is occupied by many widgets.This can be done by using aQWidgetas the parent of all the other widgets,and using layout managers to size and position the child widgets.73"},{"pageNumber":92,"pageContent":"744. Implementing Application Functionality4. Use a splitter.Another way of using multiple widgets together is to use aQSplitter. TheQSplitterarranges its child widgets horizontally or vertically, with splitterhandles to give some sizing control to the user. Splitters can contain allkinds of widgets, including other splitters.5. Use an MDI workspace.If the application uses MDI, the central area is occupied by aQWorkspacewidget, and each of the MDI windows is a child of that widget.Layouts, splitters, and MDI workspaces can be combined with standard Qtwidgets or with custom widgets. Chapter 6 covers these classes in depth.For the Spreadsheet application, aQTableWidgetsubclass is used as the centralwidget. TheQTableWidgetclass already provides most of the spreadsheetcapability we need, but it doesn’t support clipboard operations and doesn’tunderstand spreadsheet formulas like “=A1+A2+A3”. We will implement thismissing functionality in theSpreadsheetclass.Subclassing QTableWidgetTheSpreadsheetclass inherits fromQTableWidget. AQTableWidgetis effectivelya grid that represents a two-dimensional sparse array. It displays whichevercells the user scrolls to, within its specified dimensions. When the user enterssome text into an empty cell,QTableWidgetautomatically creates aQTableWid-getItemto store the text.Let’s start implementingSpreadsheet, beginning with the header file:#ifndef SPREADSHEET_H#define SPREADSHEET_H#include <QTableWidget>class Cell;class SpreadsheetCompare;The header starts with forward declarations for theCellandSpreadsheetCom-pareclasses.QObjectQWidgetQTableWidgetQTableWidgetItemSpreadsheetCellFigure 4.1.Inheritance trees forSpreadsheetandCell"},{"pageNumber":93,"pageContent":"Subclassing QTableWidget75The attributes of aQTableWidgetcell, such as its text and its alignment, arestored in aQTableWidgetItem. UnlikeQTableWidget,QTableWidgetItemisn’t a wid-get class; it is a pure data class. TheCellclass inheritsQTableWidgetItemand isexplained when its implementation is shown in this chapter’s last section.class Spreadsheet : public QTableWidget{ Q_OBJECTpublic: Spreadsheet(QWidget *parent = 0); bool autoRecalculate() const { return autoRecalc; } QString currentLocation() const; QString currentFormula() const; QTableWidgetSelectionRange selectedRange() const; void clear(); bool readFile(const QString &fileName); bool writeFile(const QString &fileName); void sort(const SpreadsheetCompare &compare);TheautoRecalculate()function is implemented inline since it just returnswhether or not auto-recalculation is in force.In Chapter 3, we relied on some public functions inSpreadsheetwhen weimplementedMainWindow. For example, we calledclear()fromMainWindow::newFile()to reset the spreadsheet. We also used some functions inherited fromQTableWidget, notablysetCurrentCell()andsetShowGrid().public slots: void cut(); void copy(); void paste(); void del(); void selectCurrentRow(); void selectCurrentColumn(); void recalculate(); void setAutoRecalculate(bool recalc); void findNext(const QString &str, Qt::CaseSensitivity cs); void findPrevious(const QString &str, Qt::CaseSensitivity cs);signals: void modified();Spreadsheetprovides many slots that implement actions from theEdit,Tools, andOptionsmenus, and it provides one signal,modified(), to announce any changethat has occurred.private slots: void somethingChanged();We define one private slot used internally by theSpreadsheetclass.private: enum { MagicNumber = 0x7F51C883, RowCount = 999, ColumnCount = 26 };"},{"pageNumber":94,"pageContent":"764. Implementing Application Functionality Cell *cell(int row, int column) const; QString text(int row, int column) const; QString formula(int row, int column) const; void setFormula(int row, int column, const QString &formula); bool autoRecalc;};In the class’s private section, we declare three constants, four functions, andone variable.class SpreadsheetCompare{public: bool operator()(const QStringList &row1, const QStringList &row2) const; enum { KeyCount = 3 }; int keys[KeyCount]; bool ascending[KeyCount];};#endifThe header file ends with theSpreadsheetCompareclass definition. We willexplain this when we reviewSpreadsheet::sort().We will now look at the implementation:#include <QtGui>#include \"cell.h\"#include \"spreadsheet.h\"Spreadsheet::Spreadsheet(QWidget *parent) : QTableWidget(parent){ autoRecalc = true; setItemPrototype(new Cell); setSelectionMode(ContiguousSelection); connect(this, SIGNAL(itemChanged(QTableWidgetItem *)), this, SLOT(somethingChanged())); clear();}Normally, when the user enters some text on an empty cell, theQTableWidgetwill automatically create aQTableWidgetItemto hold the text. In our spread-sheet, we wantCellitems to be created instead. This is achieved by theset-ItemPrototype()call in the constructor. Internally,QTableWidgetclones the itempassed as a prototype every time a new item is required.Also in the constructor, we set the selection mode toQAbstractItemView::Con-tiguousSelectionto allow a single rectangular selection. We connect the tablewidget’sitemChanged()signal to the privatesomethingChanged()slot; this en-"},{"pageNumber":95,"pageContent":"Subclassing QTableWidget77sures that when the user edits a cell, thesomethingChanged()slot is called. Fi-nally, we callclear()to resize the table and to set the column headings.void Spreadsheet::clear(){ setRowCount(0); setColumnCount(0); setRowCount(RowCount); setColumnCount(ColumnCount); for (int i = 0; i < ColumnCount; ++i) { QTableWidgetItem *item = new QTableWidgetItem; item->setText(QString(QChar(’A’ + i))); setHorizontalHeaderItem(i, item); } setCurrentCell(0, 0);}Theclear()function is called from theSpreadsheetconstructor to initialize thespreadsheet. It is also called fromMainWindow::newFile().We could have usedQTableWidget::clear()to clear all the items and any selec-tions, but that would have left the headers at their current size. Instead, weresize the table down to 0 × 0. This clears the entire spreadsheet, including theheaders. We then resize the table toColumnCount×RowCount(26 × 999) and popu-late the horizontal header withQTableWidgetItems containing the column names“A”, “B”, ..., “Z”. We don’t need to set the vertical header labels, because thesedefault to “1”, “2”, ..., “999”. At the end, we move the cell cursor to cell A1.verticalHeader()verticalScrollBar()wporviewport()ontalHeader()horizontalHeader()ontalScrollBar()horizontalScrollBar()Figure 4.2.QTableWidget’s constituent widgetsAQTableWidgetis composed of several child widgets. It has a horizontalQHead-erViewat the top, a verticalQHeaderViewon the left, and twoQScrollBars. Thearea in the middle is occupied by a special widget called theviewport, on whichQTableWidgetdraws the cells. The different child widgets are accessible throughfunctions inherited fromQTableViewandQAbstractScrollArea(see Figure 4.2).QAbstractScrollAreaprovides a scrollable viewport and two scroll bars, whichcan be turned on and off. ItsQScrollAreasubclass is covered in Chapter 6."},{"pageNumber":96,"pageContent":"784. Implementing Application FunctionalityStoring Data as ItemsIn the Spreadsheet application, every non-empty cell is stored in memoryas an individualQTableWidgetItemobject. Storing data as items is anapproach that is also used byQListWidgetandQTreeWidget, which operate onQListWidgetItems andQTreeWidgetItems.Qt’s item classes can be used out of the box as data holders. For example,aQTableWidgetItemalready stores a few attributes, including a string, font,color, and icon, and a pointer back to theQTableWidget. The items can alsohold data (QVariants), including registered custom types, and by subclassingthe item class we can provide additional functionality.Other toolkits provide avoidpointer in their item classes to store customdata. In Qt, the more natural approach is to usesetData()with aQVariant,but if avoidpointer is required, it can be trivially achieved by subclassingan item class and adding avoidpointer member variable.For more challenging data handling requirements, such as large datasets, complex data items, database integration, and multiple data views,Qt provides a set of model/view classes that separate the data from theirvisual representation. These are covered in Chapter 10.Cell *Spreadsheet::cell(int row, int column) const{ return static_cast<Cell *>(item(row, column));}Thecell()private function returns theCellobject for a given row and column.It is almost the same asQTableWidget::item(), except that it returns aCellpointer instead of aQTableWidgetItempointer.QString Spreadsheet::text(int row, int column) const{ Cell *c = cell(row, column); if (c) { return c->text(); } else { return \"\"; }}Thetext()private function returns the text for a given cell. Ifcell()returnsa null pointer, the cell is empty, so we return an empty string.QString Spreadsheet::formula(int row, int column) const{ Cell *c = cell(row, column); if (c) { return c->formula(); } else { return \"\";"},{"pageNumber":97,"pageContent":"Subclassing QTableWidget79 }}Theformula()function returns the cell’s formula. In many cases, the formulaand the text are the same; for example, the formula “Hello” evaluates to thestring “Hello”, so if the user types “Hello” into a cell and pressesEnter, that cellwill show the text “Hello”. But there are a few exceptions:• If the formula is a number, it is interpreted as such. For example, theformula “1.50” evaluates to thedoublevalue 1.5, which is rendered as aright-aligned “1.5” in the spreadsheet.• If the formula starts with a single quote, the rest of the formula is in-terpreted as text. For example, the formula “ ’12345” evaluates to thestring “12345”.• If the formula starts with an equals sign (‘=’), the formula is interpretedas an arithmetic formula. For example, if cell A1 contains “12” and cell A2contains “6”, the formula “=A1+A2” evaluates to 18.The task of converting a formula into a value is performed by theCellclass.For the moment, the thing to bear in mind is that the text shown in the cell isthe result of evaluating the formula, not the formula itself.void Spreadsheet::setFormula(int row, int column,  const QString &formula){ Cell *c = cell(row, column); if (!c) { c = new Cell; setItem(row, column, c); } c->setFormula(formula);}ThesetFormula()private function sets the formula for a given cell. If the cellalready has aCellobject, we reuse it. Otherwise, we create a newCellobjectand callQTableWidget::setItem()to insert it into the table. At the end, we callthe cell’s ownsetFormula()function, which will cause the cell to be repainted ifit’s shown on screen. We don’t need to worry about deleting theCellobject lateron;QTableWidgettakes ownership of the cell and will delete it automatically atthe right time.QString Spreadsheet::currentLocation() const{ return QChar(’A’ + currentColumn()) + QString::number(currentRow() + 1);}ThecurrentLocation()function returns the current cell’s location in the usualspreadsheet format of column letter followed by row number.MainWindow::updateStatusBar()uses it to show the location in the status bar."},{"pageNumber":98,"pageContent":"804. Implementing Application FunctionalityQString Spreadsheet::currentFormula() const{ return formula(currentRow(), currentColumn());}ThecurrentFormula()function returns the current cell’s formula. It is calledfromMainWindow::updateStatusBar().void Spreadsheet::somethingChanged(){ if (autoRecalc) recalculate(); emit modified();}ThesomethingChanged()private slot recalculates the whole spreadsheet if“auto-recalculate” is enabled. It also emits themodified()signal.Loading and SavingWe will now implement the loading and saving of Spreadsheet files usinga custom binary format. We will do this usingQFileandQDataStream, whichtogether provide platform-independent binary I/O.We will start with writing a Spreadsheet file:bool Spreadsheet::writeFile(const QString &fileName){ QFile file(fileName); if (!file.open(QIODevice::WriteOnly)) { QMessageBox::warning(this, tr(\"Spreadsheet\"),  tr(\"Cannot write file %1:\\n%2.\")  .arg(file.fileName())  .arg(file.errorString())); return false; } QDataStream out(&file); out.setVersion(QDataStream::Qt_4_1); out << quint32(MagicNumber); QApplication::setOverrideCursor(Qt::WaitCursor); for (int row = 0; row < RowCount; ++row) { for (int column = 0; column < ColumnCount; ++column) { QString str = formula(row, column); if (!str.isEmpty()) out << quint16(row) << quint16(column) << str; } } QApplication::restoreOverrideCursor(); return true;}"},{"pageNumber":99,"pageContent":"Loading and Saving81ThewriteFile()function is called fromMainWindow::saveFile()to write the fileto disk. It returnstrueon success,falseon error.We create aQFileobject with the given file name and callopen()to open the filefor writing. We also create aQDataStreamobject that operates on theQFileanduse it to write out the data.Just before we write the data, we change the application’s cursor to the stan-dard wait cursor (usually an hourglass) and restore the normal cursor once allthe data is written. At the end of the function, the file is automatically closedbyQFile’s destructor.QDataStreamsupports basic C++types as well as many of Qt’s types. The syntaxis modeled after the Standard C++<iostream>classes. For example,out << x << y << z;writes the variablesx,y, andzto a stream, andin >> x >> y >> z;reads them from a stream. Because the C++basic typeschar,short,int,long,andlong longmay have different sizes on different platforms, it is safest to castthese values to one ofqint8,quint8,qint16,quint16,qint32,quint32,qint64, andquint64, which are guaranteed to be of the size they advertise (in bits).The Spreadsheet application’s file format is fairly simple. A Spreadsheet filestarts with a 32-bit number that identifies the file format (MagicNumber, definedas0x7F51C883inspreadsheet.h, an arbitrary random number.) Then comes aseries of blocks, each of which contains a single cell’s row, column, and formula.To save space, we don’t write out empty cells.0x7F51C8831235Fr1236Francium· · ·Figure 4.3.The Spreadsheet file formatThe precise binary representation of the data types is determined byQData-Stream. For example, aquint16is stored as two bytes in big-endian order, and aQStringas the string’s length followed by the Unicode characters.The binary representation of Qt types has evolved quite a lot since Qt 1.0. It islikely to continue evolving in future Qt releases to keep pace with the evolutionof existing types and to allow for new Qt types. By default,QDataStreamuses themost recent version of the binary format (version 7 in Qt 4.1), but it can be setto read older versions. To avoid any compatibility problems if the applicationis recompiled later using a newer Qt release, we explicitly tellQDataStreamto use version 7 irrespective of the version of Qt we are compiling against.(QDataStream::Qt_4_1is a convenience constant that equals 7.)"},{"pageNumber":100,"pageContent":"824. Implementing Application FunctionalityQDataStreamis very versatile. It can be used on aQFile, and also on aQBuffer, aQProcess, aQTcpSocket, or aQUdpSocket. Qt also offers aQTextStreamclass that canbe used instead ofQDataStreamfor reading and writing text files. Chapter 12explains these classes in depth, and also describes various approaches tohandling differentQDataStreamversions.bool Spreadsheet::readFile(const QString &fileName){ QFile file(fileName); if (!file.open(QIODevice::ReadOnly)) { QMessageBox::warning(this, tr(\"Spreadsheet\"),  tr(\"Cannot read file %1:\\n%2.\")  .arg(file.fileName())  .arg(file.errorString())); return false; } QDataStream in(&file); in.setVersion(QDataStream::Qt_4_1); quint32 magic; in >> magic; if (magic != MagicNumber) { QMessageBox::warning(this, tr(\"Spreadsheet\"),  tr(\"The file is not a Spreadsheet file.\")); return false; } clear(); quint16 row; quint16 column; QString str; QApplication::setOverrideCursor(Qt::WaitCursor); while (!in.atEnd()) { in >> row >> column >> str; setFormula(row, column, str); } QApplication::restoreOverrideCursor(); return true;}ThereadFile()function is very similar towriteFile(). We useQFileto read inthe file, but this time using theQIODevice::ReadOnlyflag rather thanQIODevice::WriteOnly. Then we set theQDataStreamversion to 7. The format for readingmust always be the same as for writing.If the file has the correct magic number at the beginning, we callclear()toblank out all the cells in the spreadsheet, and we read in the cell data. Sincethe file only contains the data for non-empty cells, and it is very unlikely thatevery cell in the spreadsheet will be set, we must ensure that all cells arecleared before reading."},{"pageNumber":101,"pageContent":"Implementing the Edit Menu83Implementing the Edit MenuWe are now ready to implement the slots that correspond to the application’sEditmenu.void Spreadsheet::cut(){ copy(); del();}Thecut()slot corresponds toEdit|Cut. The implementation is simple sinceCutis the same asCopyfollowed byDelete.Figure 4.4.The Spreadsheet application’sEditmenuvoid Spreadsheet::copy(){ QTableWidgetSelectionRange range = selectedRange(); QString str; for (int i = 0; i < range.rowCount(); ++i) { if (i > 0) str += \"\\n\"; for (int j = 0; j < range.columnCount(); ++j) { if (j > 0) str += \"\\t\"; str += formula(range.topRow() + i, range.leftColumn() + j); } } QApplication::clipboard()->setText(str);}Thecopy()slot corresponds toEdit|Copy. It iterates over the current selection(which is simply the current cell if there is no explicit selection). Each selectedcell’s formula is added to aQString, with rows separated by newline charactersand columns separated by tab characters.The system clipboard is available in Qt through theQApplication::clipboard()static function. By callingQClipboard::setText(), we make the text available"},{"pageNumber":102,"pageContent":"844. Implementing Application Functionalityon the clipboard, both to this application and to other applications that supportplain text. Our format with tab and newline characters as separators isunderstood by a variety of applications, including Microsoft Excel.ç\"Red\\tGreen\\tBlue\\nCyan\\tMagenta\\tYellow\"Figure 4.5.Copying a selection onto the clipboardTheQTableWidget::selectedRanges()function returns a list of selection ranges.We know there cannot be more than one because we set the selection modetoQAbstractItemView::ContiguousSelectionin the constructor. For our conve-nience, we define aselectedRange()function that returns the selection range:QTableWidgetSelectionRange Spreadsheet::selectedRange() const{ QList<QTableWidgetSelectionRange> ranges = selectedRanges(); if (ranges.isEmpty()) return QTableWidgetSelectionRange(); return ranges.first();}If there is a selection at all, we simply return the first (and only) one. The casewhere there is no selection should never happen since theContiguousSelectionmode treats the current cell as being selected. But to protect against thepossibility of a bug in our program that makes no cell current, we handlethis case.void Spreadsheet::paste(){ QTableWidgetSelectionRange range = selectedRange(); QString str = QApplication::clipboard()->text(); QStringList rows = str.split(’\\n’); int numRows = rows.count(); int numColumns = rows.first().count(’\\t’) + 1; if (range.rowCount() * range.columnCount() != 1 && (range.rowCount() != numRows || range.columnCount() != numColumns)) { QMessageBox::information(this, tr(\"Spreadsheet\"), tr(\"The information cannot be pasted because the copy \" \"and paste areas aren’t the same size.\")); return; } for (int i = 0; i < numRows; ++i) { QStringList columns = rows[i].split(’\\t’); for (int j = 0; j < numColumns; ++j) {"},{"pageNumber":103,"pageContent":"Implementing the Edit Menu85 int row = range.topRow() + i; int column = range.leftColumn() + j; if (row < RowCount && column < ColumnCount) setFormula(row, column, columns[j]); } } somethingChanged();}Thepaste()slot corresponds toEdit|Paste. We fetch the text on the clipboard andcall the static functionQString::split()to break the string into aQStringList.Each row becomes one string in the list.Next, we determine the dimension of the copy area. The number of rows is thenumber of strings in theQStringList; the number of columns is the number oftab characters in the first row, plus 1. If only one cell is selected, we use that cellas the top-left corner of the paste area; otherwise, we use the current selectionas the paste area.To perform the paste, we iterate over the rows and split each of them intocells by usingQString::split()again, but this time using tab as the separator.Figure 4.6 illustrates the steps.\"Red\\tGreen\\tBlue\\nCyan\\tMagenta\\tYellow\"ç[ \"Red\\tGreen\\tBlue\",\"Cyan\\tMagenta\\tYellow\" ]ç[ \"Red\", \"Green\", \"Blue\" ][ \"Cyan\", \"Magenta\", \"Yellow\" ]çFigure 4.6.Pasting clipboard text into the spreadsheetvoid Spreadsheet::del(){ foreach (QTableWidgetItem *item, selectedItems()) delete item;}Thedel()slot corresponds toEdit|Delete. It is sufficient to usedeleteon eachof theCellobjects in the selection to clear the cells. TheQTableWidgetnoticeswhen itsQTableWidgetItems are deleted and automatically repaints itself if anyof the items were visible. If we callcell()with the location of a deleted cell,it will return a null pointer."},{"pageNumber":104,"pageContent":"864. Implementing Application Functionalityvoid Spreadsheet::selectCurrentRow(){ selectRow(currentRow());}void Spreadsheet::selectCurrentColumn(){ selectColumn(currentColumn());}TheselectCurrentRow()andselectCurrentColumn()functions correspond to theEdit|Select|RowandEdit|Select|Columnmenu options. The implementations relyonQTableWidget’sselectRow()andselectColumn()functions. We do not needto implement the functionality behindEdit|Select|All, since that is provided byQTableWidget’s inherited functionQAbstractItemView::selectAll().void Spreadsheet::findNext(const QString &str, Qt::CaseSensitivity cs){ int row = currentRow(); int column = currentColumn() + 1; while (row < RowCount) { while (column < ColumnCount) { if (text(row, column).contains(str, cs)) { clearSelection(); setCurrentCell(row, column); activateWindow(); return; } ++column; } column = 0; ++row; } QApplication::beep();}ThefindNext()slot iterates through the cells starting from the cell to the rightof the cursor and moving right until the last column is reached, then continuesfrom the first column in the row below, and so on until the text is found or untilthe very last cell is reached. For example, if the current cell is cell C24, wesearch D24, E24, ..., Z24, then A25, B25, C25, ..., Z25, and so on until Z999. Ifwe find a match, we clear the current selection, move the cell cursor to the cellthat matched, and make the window that contains theSpreadsheetactive. Ifno match is found, we make the application beep to indicate that the searchfinished unsuccessfully.void Spreadsheet::findPrevious(const QString &str,  Qt::CaseSensitivity cs){ int row = currentRow(); int column = currentColumn() - 1; while (row >= 0) {"},{"pageNumber":105,"pageContent":"Implementing the Edit Menu87 while (column >= 0) { if (text(row, column).contains(str, cs)) { clearSelection(); setCurrentCell(row, column); activateWindow(); return; } --column; } column = ColumnCount - 1; --row; } QApplication::beep();}ThefindPrevious()slot is similar tofindNext(), except that it iterates backwardand stops at cell A1.Implementing the Other MenusWe will now implement the slots for theToolsandOptionsmenus.Figure 4.7.The Spreadsheet application’sToolsandOptionsmenusvoid Spreadsheet::recalculate(){ for (int row = 0; row < RowCount; ++row) { for (int column = 0; column < ColumnCount; ++column) { if (cell(row, column)) cell(row, column)->setDirty(); } } viewport()->update();}Therecalculate()slot corresponds toTools|Recalculate. It is also called automat-ically bySpreadsheetwhen necessary.We iterate over all the cells and callsetDirty()on every cell to mark each oneas requiring recalculation. The next timeQTableWidgetcallstext()on aCelltoobtain the value to show in the spreadsheet, the value will be recalculated.Then we callupdate()on the viewport to repaint the whole spreadsheet. Therepaint code inQTableWidgetthen callstext()on each visible cell to obtain thevalue to display. Because we calledsetDirty()on every cell, the calls totext()will use a freshly calculated value. The calculation may require non-visiblecells to be recalculated, cascading the calculation until every cell that needs"},{"pageNumber":106,"pageContent":"884. Implementing Application Functionalityto be recalculated to display the correct text in the viewport has been freshlycalculated. The calculation is performed by theCellclass.void Spreadsheet::setAutoRecalculate(bool recalc){ autoRecalc = recalc; if (autoRecalc) recalculate();}ThesetAutoRecalculate()slot corresponds toOptions|Auto-Recalculate. If the fea-ture is being turned on, we recalculate the whole spreadsheet immediately tomake sure that it’s up to date; afterward,recalculate()is called automaticallyfromsomethingChanged().We don’t need to implement anything forOptions|Show GridbecauseQTableWid-getalready has asetShowGrid()slot, which it inherits from its base classQTable-View. All that remains isSpreadsheet::sort(), which is called fromMainWindow::sort():void Spreadsheet::sort(const SpreadsheetCompare &compare){ QList<QStringList> rows; QTableWidgetSelectionRange range = selectedRange(); int i; for (i = 0; i < range.rowCount(); ++i) { QStringList row; for (int j = 0; j < range.columnCount(); ++j) row.append(formula(range.topRow() + i,  range.leftColumn() + j)); rows.append(row); } qStableSort(rows.begin(), rows.end(), compare); for (i = 0; i < range.rowCount(); ++i) { for (int j = 0; j < range.columnCount(); ++j) setFormula(range.topRow() + i, range.leftColumn() + j,  rows[i][j]); } clearSelection(); somethingChanged();}Sorting operates on the current selection and reorders the rows according tothe sort keys and sort orders stored in thecompareobject. We represent eachrow of data with aQStringListand store the selection as a list of rows. We useQt’sqStableSort()algorithm, and for simplicity sort by formula rather than byvalue. Qt’s standard algorithms and data structures are covered in Chapter 11(Container Classes)."},{"pageNumber":107,"pageContent":"Implementing the Other Menus89çindexvalue0[ \"Edsger\", \"Dijkstra\", \"1930-05-11\" ]1[ \"Tony\", \"Hoare\", \"1934-01-11\" ]2[ \"Niklaus\", \"Wirth\", \"1934-02-15\" ]3[ \"Donald\", \"Knuth\", \"1938-01-10\" ]Figure 4.8.Storing the selection as a list of rowsTheqStableSort()function accepts a begin iterator, an end iterator, and acomparison function. The comparison function is a function that takes twoarguments (twoQStringLists) and that returnstrueif the first argument is“less than” the second argument,falseotherwise. Thecompareobject we passas the comparison function isn’t really a function, but it can be used as one, aswe will see shortly.indexvalue0[ \"Donald\", \"Knuth\", \"1938-01-10\" ]1[ \"Edsger\", \"Dijkstra\", \"1930-05-11\" ]2[ \"Niklaus\", \"Wirth\", \"1934-02-15\" ]3[ \"Tony\", \"Hoare\", \"1934-01-11\" ]çFigure 4.9.Putting the data back into the table after sortingAfter performing theqStableSort(), we move the data back into the table, clearthe selection, and callsomethingChanged().Inspreadsheet.h, theSpreadsheetCompareclass was defined like this:class SpreadsheetCompare{public: bool operator()(const QStringList &row1, const QStringList &row2) const; enum { KeyCount = 3 }; int keys[KeyCount]; bool ascending[KeyCount];};TheSpreadsheetCompareclass is special because it implements a()operator.This allows us to use the class as if it were a function. Such classes are calledfunction objects, or functors. To understand how functors work, we will startwith a simple example:class Square{public: int operator()(int x) const { return x * x; }}"},{"pageNumber":108,"pageContent":"904. Implementing Application FunctionalityTheSquareclass provides one function,operator()(int), that returns the squareof its parameter. By naming the functionoperator()(int)rather than, say,compute(int), we gain the capability of using an object of typeSquareas if itwere a function:Square square;int y = square(5);Now let’s see an example involvingSpreadsheetCompare:QStringList row1, row2;QSpreadsheetCompare compare;•••if (compare(row1, row2)) { // row1 is less than row2}Thecompareobject can be used just as if it had been a plaincompare()function.Additionally, its implementation can access all the sort keys and sort orders,which are stored as member variables.An alternative to this scheme would have been to store the sort keys and sortorders in global variables and use a plaincompare()function. However, com-municating through global variables is inelegant and can lead to subtle bugs.Functors are a more powerful idiom for interfacing with template functionssuch asqStableSort().Here is the implementation of the function that is used to compare twospreadsheet rows:bool SpreadsheetCompare::operator()(const QStringList &row1,  const QStringList &row2) const{ for (int i = 0; i < KeyCount; ++i) { int column = keys[i]; if (column != -1) { if (row1[column] != row2[column]) { if (ascending[i]) { return row1[column] < row2[column]; } else { return row1[column] > row2[column]; } } } } return false;}The operator returnstrueif the first row is less than the second row; otherwise,it returnsfalse. TheqStableSort()function uses the result of this function toperform the sort."},{"pageNumber":109,"pageContent":"Implementing the Other Menus91TheSpreadsheetCompareobject’skeysandascendingarrays are populated in theMainWindow::sort()function (shown in Chapter 2). Each key holds a columnindex, or+--1 (“None”).We compare the corresponding cell entries in the two rows for each key in order.As soon as we find a difference, we return an appropriatetrueorfalsevalue.If all the comparisons turn out to be equal, we returnfalse. TheqStableSort()function uses the order before the sort to resolve tie situations; ifrow1preced-edrow2originally and neither compares as “less than” the other,row1will stillprecederow2in the result. This is what distinguishesqStableSort()from itsunstable cousinqSort().We have now completed theSpreadsheetclass. In the next section, we willreview theCellclass. This class is used to hold cell formulas and provides areimplementation of theQTableWidgetItem::data()function thatSpreadsheetcalls indirectly, through theQTableWidgetItem::text()function, to display theresult of calculating a cell’s formula.Subclassing QTableWidgetItemTheCellclass inherits fromQTableWidgetItem. The class is designed to work wellwithSpreadsheet, but it has no specific dependencies on that class and could intheory be used in anyQTableWidget. Here’s the header file:#ifndef CELL_H#define CELL_H#include <QTableWidgetItem>class Cell : public QTableWidgetItem{public: Cell(); QTableWidgetItem *clone() const; void setData(int role, const QVariant &value); QVariant data(int role) const; void setFormula(const QString &formula); QString formula() const; void setDirty();private: QVariant value() const; QVariant evalExpression(const QString &str, int &pos) const; QVariant evalTerm(const QString &str, int &pos) const; QVariant evalFactor(const QString &str, int &pos) const; mutable QVariant cachedValue; mutable bool cacheIsDirty;};#endif"},{"pageNumber":110,"pageContent":"924. Implementing Application FunctionalityTheCellclass extendsQTableWidgetItemby adding two private variables:•cachedValuecaches the cell’s value as aQVariant.•cacheIsDirtyistrueif the cached value isn’t up to date.We useQVariantbecause some cells have adoublevalue, while others have aQStringvalue.ThecachedValueandcacheIsDirtyvariables are declared with the C++mutablekeyword. This allows us to modify these variables in const functions. Alterna-tively, we could recalculate the value each timetext()is called, but that wouldbe needlessly inefficient.Notice that there is noQ_OBJECTmacro in the class definition.Cellis a plainC++class, with no signals or slots. In fact, becauseQTableWidgetItemdoesn’tinherit fromQObject, we cannot have signals and slots inCellas it stands. Qt’sitem classes don’t inherit fromQObjectto keep their overhead to the barestminimum. If signals and slots are needed, they can be implemented in thewidget that contains the items or, exceptionally, using multiple inheritancewithQObject.Here’s the start ofcell.cpp:#include <QtGui>#include \"cell.h\"Cell::Cell(){ setDirty();}In the constructor, we only need to set the cache as dirty. There is no need topass a parent; when the cell is inserted into aQTableWidgetwithsetItem(), theQTableWidgetwill automatically take ownership of it.EveryQTableWidgetItemcan hold some data, up to oneQVariantfor each data“role”. The most commonly used roles areQt::EditRoleandQt::DisplayRole.The edit role is used for data that is to be edited, and the display role is for datathat is to be displayed. Often the data for both is the same, but inCellthe editrole corresponds to the cell’s formula and the display role corresponds to thecell’s value (the result of evaluating the formula).QTableWidgetItem *Cell::clone() const{ return new Cell(*this);}Theclone()function is called byQTableWidgetwhen it needs to create a newcell—for example, when the user starts typing into an empty cell that has notbeen used before. The instance passed toQTableWidget::setItemPrototype()isthe item that is cloned. Since member-wise copying is sufficient forCell, we are"},{"pageNumber":111,"pageContent":"Subclassing QTableWidgetItem93relying on the default copy constructor automatically created by C++to createnewCellinstances in theclone()function.void Cell::setFormula(const QString &formula){ setData(Qt::EditRole, formula);}ThesetFormula()function sets the cell’s formula. It is simply a conveniencefunction for callingsetData()with the edit role. It is called fromSpreadsheet::setFormula().QString Cell::formula() const{ return data(Qt::EditRole).toString();}Theformula()function is called fromSpreadsheet::formula(). LikesetFormula()it is a convenience function, this time retrieving the item’sEditRoledata.void Cell::setData(int role, const QVariant &value){ QTableWidgetItem::setData(role, value); if (role == Qt::EditRole) setDirty();}If we have a new formula, we setcacheIsDirtytotrueto ensure that the cell isrecalculated the next timetext()is called.There is notext()function defined inCell, although we calltext()onCellin-stances inSpreadsheet::text(). Thetext()function is a convenience functionprovided byQTableWidgetItem; it is the equivalent of callingdata(Qt::Display-Role).toString().void Cell::setDirty(){ cacheIsDirty = true;}ThesetDirty()function is called to force a recalculation of the cell’s value. Itsimply setscacheIsDirtytotrue, meaning thatcachedValueis no longer up todate. The recalculation isn’t performed until it is necessary.QVariant Cell::data(int role) const{ if (role == Qt::DisplayRole) { if (value().isValid()) { return value().toString(); } else { return \"####\"; } } else if (role == Qt::TextAlignmentRole) { if (value().type() == QVariant::String) { return int(Qt::AlignLeft | Qt::AlignVCenter);"},{"pageNumber":112,"pageContent":"944. Implementing Application Functionality } else { return int(Qt::AlignRight | Qt::AlignVCenter); } } else { return QTableWidgetItem::data(role); }}Thedata()function is reimplemented fromQTableWidgetItem. It returns thetext that should be shown in the spreadsheet if called withQt::DisplayRole,and the formula if called withQt::EditRole. It returns a suitable alignment ifcalled withQt::TextAlignmentRole. In theDisplayRolecase, it relies onvalue()tocompute the cell’s value. If the value is invalid (because the formula is wrong),we return “####”.TheCell::value()function used indata()returns aQVariant. AQVariantcanstore values of different types, such asdoubleandQString, and provides func-tions to convert the variant to other types. For example, callingtoString()on avariant that holds adoublevalue produces a string representation of thedouble.AQVariantconstructed using the default constructor is an “invalid” variant.const QVariant Invalid;QVariant Cell::value() const{ if (cacheIsDirty) { cacheIsDirty = false; QString formulaStr = formula(); if (formulaStr.startsWith(’\\’’)) { cachedValue = formulaStr.mid(1); } else if (formulaStr.startsWith(’=’)) { cachedValue = Invalid; QString expr = formulaStr.mid(1); expr.replace(\" \", \"\"); expr.append(QChar::Null); int pos = 0; cachedValue = evalExpression(expr, pos); if (expr[pos] != QChar::Null) cachedValue = Invalid; } else { bool ok; double d = formulaStr.toDouble(&ok); if (ok) { cachedValue = d; } else { cachedValue = formulaStr; } } } return cachedValue;}"},{"pageNumber":113,"pageContent":"Subclassing QTableWidgetItem95Thevalue()private function returns the cell’s value. IfcacheIsDirtyistrue, weneed to recalculate the value.If the formula starts with a single quote (for example, “ ’12345”), the sin-gle quote occupies position 0 and the value is the string from position 1 tothe end.If the formula starts with an equals sign (‘=’), we take the string from position 1and remove any spaces it may contain. Then we callevalExpression()tocompute the value of the expression. Theposargument is passed by reference;it indicates the position of the character where parsing should begin. After thecall toevalExpression(), the character at positionposshould be theQChar::Nullcharacter we appended, if it was successfully parsed. If the parse failed beforethe end, we setcachedValueto beInvalid.If the formula doesn’t begin with a single quote or an equals sign, we attemptto convert it to a floating-point value usingtoDouble(). If the conversion works,we setcachedValueto be the resulting number; otherwise, we setcachedValueto be the formula string. For example, a formula of “1.50” causestoDouble()to setoktotrueand return 1.5, while a formula of “World Population” causestoDouble()to setoktofalseand return 0.0.By givingtoDouble()a pointer to abool, we are able to distinguish between theconversion of a string that represents the numeric value 0.0 and a conversionerror (where 0.0 is also returned but theboolis set tofalse). Sometimes thereturning of a zero value on conversion failure is exactly what we need, inwhich case we do not bother passing a pointer to abool. For performanceand portability reasons, Qt never uses C++exceptions to report failure. Thisdoesn’t prevent you from using them in Qt programs, providing your compilersupports them.Thevalue()function is declared const. We had to declarecachedValueandcacheIsValidas mutable variables so that the compiler will allow us to modifythem in const functions. It might be tempting to makevalue()non-const andremove themutablekeywords, but that would not compile because we callvalue()fromdata(), a const function.We have now completed the Spreadsheet application, apart from parsing for-mulas. The rest of this section coversevalExpression()and the two helper func-tionsevalTerm()andevalFactor(). The code is a bit complicated, but it is includ-ed here to make the application complete. Since the code is not related to GUIprogramming, you can safely skip it and continue reading from Chapter 5.TheevalExpression()function returns the value of a spreadsheet expression.An expression is defined as one or more terms separated by ‘+’ or ‘+--’ operators.The terms themselves are defined as one or more factors separated by ‘∗’ or ‘/’operators. By breaking down expressions into terms and terms into factors, weensure that the operators are applied with the correct precedence."},{"pageNumber":114,"pageContent":"964. Implementing Application FunctionalityFor example, “2∗C5+D6” is an expression with “2∗C5” as its first term and “D6”as its second term. The term “2∗C5” has “2” as its first factor and “C5” as itssecond factor, and the term “D6” consists of the single factor “D6”. A factorcan be a number (“2”), a cell location (“C5”), or an expression in parentheses,optionally preceded by a unary minus.ExpressionTermFactorTermFactorNumber+∗+--Cell location+--/(Expression)Figure 4.10.Syntax diagram for spreadsheet expressionsThe syntax of spreadsheet expressions is defined in Figure 4.10. For each sym-bol in the grammar (Expression,Term, andFactor), there is a correspondingmember function that parses it and whose structure closely follows the gram-mar. Parsers written this way are called recursive-descent parsers.Let’s start withevalExpression(), the function that parses anExpression:QVariant Cell::evalExpression(const QString &str, int &pos) const{ QVariant result = evalTerm(str, pos); while (str[pos] != QChar::Null) { QChar op = str[pos]; if (op != ’+’ && op != ’-’) return result; ++pos; QVariant term = evalTerm(str, pos); if (result.type() == QVariant::Double && term.type() == QVariant::Double) { if (op == ’+’) { result = result.toDouble() + term.toDouble(); } else { result = result.toDouble() - term.toDouble(); } } else { result = Invalid; } } return result;}First, we callevalTerm()to get the value of the first term. If the following char-acter is ‘+’ or ‘+--’, we continue by callingevalTerm()a second time; otherwise, theexpression consists of a single term, and we return its value as the value of thewhole expression. After we have the value of the first two terms, we computethe result of the operation, depending on the operator. If both terms evaluated"},{"pageNumber":115,"pageContent":"Subclassing QTableWidgetItem97to adouble, we compute the result as adouble; otherwise, we set the result to beInvalid.We continue like this until there are no more terms. This works correctlybecause addition and subtraction are left-associative; that is, “1+--2+--3” means“(1+--2)+--3”, not “1+--(2+--3)”.QVariant Cell::evalTerm(const QString &str, int &pos) const{ QVariant result = evalFactor(str, pos); while (str[pos] != QChar::Null) { QChar op = str[pos]; if (op != ’*’ && op != ’/’) return result; ++pos; QVariant factor = evalFactor(str, pos); if (result.type() == QVariant::Double && factor.type() == QVariant::Double) { if (op == ’*’) { result = result.toDouble() * factor.toDouble(); } else { if (factor.toDouble() == 0.0) { result = Invalid; } else { result = result.toDouble() / factor.toDouble(); } } } else { result = Invalid; } } return result;}TheevalTerm()function is very similar toevalExpression(), except that it dealswith multiplication and division. The only subtlety inevalTerm()is that wemust avoid division by zero, since it is an error on some processors. While itis generally inadvisable to test floating-point values for equality because ofrounding errors, it is safe to test for equality against 0.0 to prevent divisionby zero.QVariant Cell::evalFactor(const QString &str, int &pos) const{ QVariant result; bool negative = false; if (str[pos] == ’-’) { negative = true; ++pos; } if (str[pos] == ’(’) { ++pos; result = evalExpression(str, pos);"},{"pageNumber":116,"pageContent":"984. Implementing Application Functionality if (str[pos] != ’)’) result = Invalid; ++pos; } else { QRegExp regExp(\"[A-Za-z][1-9][0-9]{0,2}\"); QString token; while (str[pos].isLetterOrNumber() || str[pos] == ’.’) { token += str[pos]; ++pos; } if (regExp.exactMatch(token)) { int column = token[0].toUpper().unicode() - ’A’; int row = token.mid(1).toInt() - 1; Cell *c = static_cast<Cell *>(  tableWidget()->item(row, column)); if (c) { result = c->value(); } else { result = 0.0; } } else { bool ok; result = token.toDouble(&ok); if (!ok) result = Invalid; } } if (negative) { if (result.type() == QVariant::Double) { result = -result.toDouble(); } else { result = Invalid; } } return result;}TheevalFactor()function is a bit more complicated thanevalExpression()andevalTerm(). We start by noting whether the factor is negated. We then seeif it begins with an open parenthesis. If it does, we evaluate the contents ofthe parentheses as an expression by callingevalExpression(). When parsing aparenthesized expression,evalExpression()callsevalTerm(), which callseval-Factor(), which callsevalExpression()again. This is where recursion occurs inthe parser.If the factor isn’t a nested expression, we extract the next token, which shouldbe a cell location or a number. If the token matches theQRegExp, we take it tobe a cell reference and we callvalue()on the cell at the given location. Thecell could be anywhere in the spreadsheet, and it could have dependencieson other cells. The dependencies are not a problem; they will simply trigger"},{"pageNumber":117,"pageContent":"Subclassing QTableWidgetItem99morevalue()calls and (for “dirty” cells) more parsing until all the dependentcell values are calculated. If the token isn’t a cell location, we take it to bea number.What happens if cell A1 contains the formula “=A1”? Or if cell A1 contains“=A2” and cell A2 contains “=A1”? Although we have not written any specialcode to detect circular dependencies, the parser handles these cases gracefullyby returning an invalidQVariant. This works because we setcacheIsDirtytofalseandcachedValuetoInvalidinvalue()before we callevalExpression(). IfevalExpression()recursively callsvalue()on the same cell, it returnsInvalidimmediately, and the whole expression then evaluates toInvalid.We have now completed the formula parser. It would be straightforward toextend it to handle predefined spreadsheet functions, like “sum()” and “avg()”,by extending the grammatical definition ofFactor. Another easy extensionis to implement the ‘+’ operator with string operands (as concatenation); thisrequires no changes to the grammar."},{"pageNumber":119,"pageContent":"5. Creating Custom WidgetsuCustomizing Qt WidgetsuSubclassing QWidgetuIntegrating Custom Widgets with QtDesigneruDouble BufferingThis chapter explains how to develop custom widgets using Qt. Custom wid-gets can be created by subclassing an existing Qt widget or by subclassingQWid-getdirectly. We will demonstrate both approaches, and we will also see howto integrate a custom widget withQt Designerso that it can be used just like abuilt-in Qt widget. We will round off the chapter by presenting a custom wid-get that uses double buffering, a powerful technique for high-speed drawing.Customizing Qt WidgetsIn some cases, we find that a Qt widget requires more customization than ispossible by setting its properties inQt Designeror by calling its functions. Asimple and direct solution is to subclass the relevant widget class and adapt itto suit our needs.Figure 5.1.TheHexSpinBoxwidgetIn this section, we will develop a hexadecimal spin box to show how this works.QSpinBoxonly supports decimal integers, but by subclassing it’s quite easy tomake it accept and display hexadecimal values.#ifndef HEXSPINBOX_H#define HEXSPINBOX_H#include <QSpinBox>class QRegExpValidator;class HexSpinBox : public QSpinBox{ Q_OBJECT101"},{"pageNumber":120,"pageContent":"1025. Creating Custom Widgetspublic: HexSpinBox(QWidget *parent = 0);protected: QValidator::State validate(QString &text, int &pos) const; int valueFromText(const QString &text) const; QString textFromValue(int value) const;private: QRegExpValidator *validator;};#endifTheHexSpinBoxinherits most of its functionality fromQSpinBox. It provides atypical constructor and reimplements three virtual functions fromQSpinBox.#include <QtGui>#include \"hexspinbox.h\"HexSpinBox::HexSpinBox(QWidget *parent) : QSpinBox(parent){ setRange(0, 255); validator = new QRegExpValidator(QRegExp(\"[0-9A-Fa-f]{1,8}\"), this);}We set the default range to be 0 to 255 (0x00to0xFF), which is more appropriatefor a hexadecimal spin box thanQSpinBox’s default of 0 to 99.The user can modify a spin box’s current value either by clicking its up anddown arrows or by typing a value into the spin box’s line editor. In the lattercase, we want to restrict the user’s input to legitimate hexadecimal numbers.To achieve this, we use aQRegExpValidatorthat accepts between one and eightcharacters, each of which must be in one of the sets, ‘0’ to ‘9’, ‘A’ to ‘F’, and ‘a’to ‘f ’.QValidator::State HexSpinBox::validate(QString &text, int &pos) const{ return validator->validate(text, pos);}This function is called byQSpinBoxto see if the text entered so far is valid.There are three possible results:Invalid(the text doesn’t match the regular ex-pression),Intermediate(the text is a plausible part of a valid value), andAccept-able(the text is valid). TheQRegExpValidatorhas a suitablevalidate()function,so we simply return the result of calling it. In theory, we should returnInvalidorIntermediatefor values that lie outside the spin box’s range, butQSpinBoxissmart enough to detect that condition without any help.QString HexSpinBox::textFromValue(int value) const{ return QString::number(value, 16).toUpper();}"},{"pageNumber":121,"pageContent":"Customizing Qt Widgets103ThetextFromValue()function converts an integer value to a string.QSpinBoxcalls it to update the editor part of the spin box when the user presses the spinbox’s up or down arrows. We use the static functionQString::number()with asecond argument of 16 to convert the value to lowercase hexadecimal, and callQString::toUpper()on the result to make it uppercase.int HexSpinBox::valueFromText(const QString &text) const{ bool ok; return text.toInt(&ok, 16);}ThevalueFromText()function performs the reverse conversion, from a stringto an integer value. It is called byQSpinBoxwhen the user types a value intothe editor part of the spin box and pressesEnter. We use theQString::toInt()function to attempt to convert the current text to an integer value, again usingbase 16. If the string is not valid hexadecimal,okis set tofalseandtoInt()returns 0. Here, we don’t have to consider this possibility because the validatoronly permits valid hexadecimal strings to be entered. Instead of passing theaddress of a dummy variable (ok), we could instead pass a null pointer as thefirst argument totoInt().We have now finished the hexadecimal spin box. Customizing other Qtwidgets follows the same pattern: Pick a suitable Qt widget, subclass it, andreimplement some virtual functions to change its behavior.Subclassing QWidgetMany custom widgets are simply a combination of existing widgets, whetherthey are built-in Qt widgets or other custom widgets such asHexSpinBox.Custom widgets that are built by composing existing widgets can usually bedeveloped inQt Designer:• Create a new form using the “Widget” template.• Add the necessary widgets to the form, and lay them out.• Set up the signals and slots connections.• If behavior beyond what can be achieved through signals and slots isrequired, write the necessary code in a class that inherits bothQWidgetandtheuic-generated class.Naturally, combining existing widgets can also be done entirely in code.Whichever approach is taken, the resulting class inherits directly fromQWid-get.If the widget has no signals and slots of its own and doesn’t reimplementany virtual functions, it is even possible to simply assemble the widget bycombining existing widgets without a subclass. That’s the approach we usedin Chapter 1 to create the Age application, with aQWidget, aQSpinBox, and a"},{"pageNumber":122,"pageContent":"1045. Creating Custom WidgetsQSlider. Even so, we could just as easily have subclassedQWidgetand createdtheQSpinBoxandQSliderin the subclass’s constructor.When none of Qt’s widgets are suitable for the task at hand, and when there’sno way to combine or adapt existing widgets to obtain the desired result, wecan still create the widget we want. This is achieved by subclassingQWidgetand reimplementing a few event handlers to paint the widget and to respondto mouse clicks. This approach gives us complete freedom to define and controlboth the appearance and the behavior of our widget. Qt’s built-in widgets, likeQLabel,QPushButton, andQTableWidget, are implemented this way. If they didn’texist in Qt, it would still be possible to create them ourselves using the publicfunctions provided byQWidgetin a completely platform-independent manner.To demonstrate how to write a custom widget using this approach, we willcreate theIconEditorwidget shown in Figure 5.2. TheIconEditoris a widgetthat could be used in an icon editing program.Figure 5.2.TheIconEditorwidgetLet’s begin by reviewing the header file.#ifndef ICONEDITOR_H#define ICONEDITOR_H#include <QColor>#include <QImage>#include <QWidget>class IconEditor : public QWidget{ Q_OBJECT Q_PROPERTY(QColor penColor READ penColor WRITE setPenColor) Q_PROPERTY(QImage iconImage READ iconImage WRITE setIconImage) Q_PROPERTY(int zoomFactor READ zoomFactor WRITE setZoomFactor)public: IconEditor(QWidget *parent = 0); void setPenColor(const QColor &newColor); QColor penColor() const { return curColor; }"},{"pageNumber":123,"pageContent":"Subclassing QWidget105 void setZoomFactor(int newZoom); int zoomFactor() const { return zoom; } void setIconImage(const QImage &newImage); QImage iconImage() const { return image; } QSize sizeHint() const;TheIconEditorclass uses theQ_PROPERTY()macro to declare three customproperties:penColor,iconImage, andzoomFactor. Each property has a data type,a “read” function, and an optional “write” function. For example, thepenColorproperty is of typeQColorand can be read and written using thepenColor()andsetPenColor()functions.When we make use of the widget inQt Designer, custom properties appearinQt Designer’s property editor below the properties inherited fromQWidget.Properties may be of any type supported byQVariant. TheQ_OBJECTmacro isnecessary for classes that define properties.protected: void mousePressEvent(QMouseEvent *event); void mouseMoveEvent(QMouseEvent *event); void paintEvent(QPaintEvent *event);private: void setImagePixel(const QPoint &pos, bool opaque); QRect pixelRect(int i, int j) const; QColor curColor; QImage image; int zoom;};#endifIconEditorreimplements three protected functions fromQWidgetand has a fewprivate functions and variables. The three private variables hold the values ofthe three properties.The implementation file begins with theIconEditor’s constructor:#include <QtGui>#include \"iconeditor.h\"IconEditor::IconEditor(QWidget *parent) : QWidget(parent){ setAttribute(Qt::WA_StaticContents); setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Minimum); curColor = Qt::black; zoom = 8; image = QImage(16, 16, QImage::Format_ARGB32); image.fill(qRgba(0, 0, 0, 0));}"},{"pageNumber":124,"pageContent":"1065. Creating Custom WidgetsThe constructor has some subtle aspects such as theQt::WA_StaticContentsattribute and thesetSizePolicy()call. We will discuss them shortly.The pen color is set to black. The zoom factor is set to 8, meaning that eachpixel in the icon will be rendered as an 8 × 8 square.The icon data is stored in theimagemember variable and can be accessedthrough thesetIconImage()andiconImage()functions. An icon editor programwould typically callsetIconImage()when the user opens an icon file andicon-Image()to retrieve the icon when the user wants to save it. Theimagevariableis of typeQImage. We initialize it to 16 × 16 pixels and 32-bit ARGB format, aformat that supports semi-transparency. We clear the image data by filling itwith a transparent color.TheQImageclass stores an image in a hardware-independent fashion. It can beset to use a 1-bit, 8-bit, or 32-bit depth. An image with 32-bit depth uses 8 bitsfor each of the red, green, and blue components of a pixel. The remaining 8 bitsstore the pixel’s alpha component (opacity). For example, a pure red color’s red,green, blue, and alpha components have the values 255, 0, 0, and 255. In Qt,this color can be specified asQRgb red = qRgba(255, 0, 0, 255);or, since the color is opaque, asQRgb red = qRgb(255, 0, 0);QRgbis simply a typedef forunsigned int, andqRgb()andqRgba()are inlinefunctions that combine their arguments into one 32-bit integer value. It is alsopossible to writeQRgb red = 0xFFFF0000;where the firstFFcorresponds to the alpha component and the secondFFtothe red component. In theIconEditorconstructor, we fill theQImagewith atransparent color by using 0 as the alpha component.Qt provides two types for storing colors:QRgbandQColor. WhileQRgbis only atypedef used inQImageto store 32-bit pixel data,QColoris a class with manyuseful functions and is widely used in Qt to store colors. In theIconEditorwid-get, we only useQRgbwhen dealing with theQImage; we useQColorfor everythingelse, including thepenColorproperty.QSize IconEditor::sizeHint() const{ QSize size = zoom * image.size(); if (zoom >= 3) size += QSize(1, 1); return size;}ThesizeHint()function is reimplemented fromQWidgetand returns the idealsize of a widget. Here, we take the image size multiplied by the zoom factor,"},{"pageNumber":125,"pageContent":"Subclassing QWidget107with one extra pixel in each direction to accommodate a grid if the zoom factoris 3 or more. (We don’t show a grid if the zoom factor is 2 or 1, because the gridwould then hardly leave any room for the icon’s pixels.)A widget’s size hint is mostly useful in conjunction with layouts. Qt’s layoutmanagers try as much as possible to respect a widget’s size hint when they layout a form’s child widgets. ForIconEditorto be a good layout citizen, it mustreport a credible size hint.In addition to the size hint, widgets have a size policy that tells the layout sys-tem whether they like to be stretched and shrunk. By callingsetSizePolicy()in the constructor withQSizePolicy::Minimumas horizontal and vertical policies,we tell any layout manager that is responsible for this widget that the widget’ssize hint is really its minimum size. In other words, the widget can be stretchedif required, but it should never shrink below the size hint. This can be overrid-den inQt Designerby setting the widget’ssizePolicyproperty. The meaning ofthe various size policies is explained in Chapter 6 (Layout Management).void IconEditor::setPenColor(const QColor &newColor){ curColor = newColor;}ThesetPenColor()function sets the current pen color. The color will be used fornewly drawn pixels.void IconEditor::setIconImage(const QImage &newImage){ if (newImage != image) { image = newImage.convertToFormat(QImage::Format_ARGB32); update(); updateGeometry(); }}ThesetIconImage()function sets the image to edit. We callconvertToFormat()to make the image 32-bit with an alpha buffer, if it isn’t already. Elsewhere inthe code, we will assume that the image data is stored as 32-bit ARGB values.After setting theimagevariable, we callQWidget::update()to force a repaintingof the widget using the new image. Next, we callQWidget::updateGeometry()totell any layout that contains the widget that the widget’s size hint has changed.The layout will then automatically adapt to the new size hint.void IconEditor::setZoomFactor(int newZoom){ if (newZoom < 1) newZoom = 1; if (newZoom != zoom) { zoom = newZoom; update(); updateGeometry();"},{"pageNumber":126,"pageContent":"1085. Creating Custom Widgets }}ThesetZoomFactor()function sets the zoom factor for the image. To prevent di-vision by zero elsewhere, we correct any value below 1. Again, we callupdate()andupdateGeometry()to repaint the widget and to notify any managing layoutabout the size hint change.ThepenColor(),iconImage(), andzoomFactor()functions are implemented asinline functions in the header file.We will now review the code for thepaintEvent()function. This function isIconEditor’s most important function. It is called whenever the widget needsrepainting. The default implementation inQWidgetdoes nothing, leaving thewidget blank.Just likecloseEvent(), which we met in Chapter 3,paintEvent()is an eventhandler. Qt has many other event handlers, each of which corresponds to adifferent type of event. Chapter 7 covers event processing in depth.There are many situations when a paint event is generated andpaintEvent()is called:• When a widget is shown for the first time, the system automaticallygenerates a paint event to force the widget to paint itself.• When a widget is resized, the system generates a paint event.• If the widget is obscured by another window and then revealed again, apaint event is generated for the area that was hidden (unless the windowsystem stored the area).We can also force a paint event by callingQWidget::update()orQWidget::re-paint(). The difference between these two functions is thatrepaint()forces animmediate repaint, whereasupdate()simply schedules a paint event for whenQt next processes events. (Both functions do nothing if the widget isn’t visibleon screen.) Ifupdate()is called multiple times, Qt compresses the consecutivepaint events into a single paint event to avoid flicker. InIconEditor, we alwaysuseupdate().Here’s the code:void IconEditor::paintEvent(QPaintEvent *event){ QPainter painter(this); if (zoom >= 3) { painter.setPen(palette().foreground().color()); for (int i = 0; i <= image.width(); ++i) painter.drawLine(zoom * i, 0,  zoom * i, zoom * image.height()); for (int j = 0; j <= image.height(); ++j) painter.drawLine(0, zoom * j,  zoom * image.width(), zoom * j); }"},{"pageNumber":127,"pageContent":"Subclassing QWidget109 for (int i = 0; i < image.width(); ++i) { for (int j = 0; j < image.height(); ++j) { QRect rect = pixelRect(i, j); if (!event->region().intersect(rect).isEmpty()) { QColor color = QColor::fromRgba(image.pixel(i, j)); painter.fillRect(rect, color); } } }}We start by constructing aQPainterobject on the widget. If the zoom factor is3 or more, we draw the horizontal and vertical lines that form the grid usingtheQPainter::drawLine()function.A call toQPainter::drawLine()has the following syntax:painter.drawLine(x1, y1, x2, y2);where (x1,y1) is the position of one end of the line and (x2,y2) is the position ofthe other end. There is also an overloaded version of the function that takestwoQPoints instead of fourints.The top-left pixel of a Qt widget is located at position (0, 0), and the bottom-right pixel is located at (width()+--1,height()+--1). This is similar to the conven-tional Cartesian coordinate system, but upside down. We can changeQPainter’scoordinate system by using transformations, such as translation, scaling, rota-tion, and shearing. This is covered in Chapter 8 (2D and 3D Graphics).(0,(0, 0)(width()(width()+--1, height()+--1)(x(x1, y1)(x(x2, y2)Figure 5.3.Drawing a line usingQPainterBefore we calldrawLine()on theQPainter, we set the line’s color usingsetPen().We could hard-code a color, like black or gray, but a better approach is to usethe widget’s palette.Every widget is equipped with a palette that specifies which colors should beused for what. For example, there is a palette entry for the background colorof widgets (usually light gray) and one for the color of text on that background(usually black). By default, a widget’s palette adopts the window system’s colorscheme. By using colors from the palette, we ensure thatIconEditorrespectsthe user’s preferences."},{"pageNumber":128,"pageContent":"1105. Creating Custom WidgetsA widget’s palette consists of three color groups: active, inactive, and disabled.Which color group should be used depends on the widget’s current state:• TheActivegroup is used for widgets in the currently active window.• TheInactivegroup is used for widgets in the other windows.• TheDisabledgroup is used for disabled widgets in any window.TheQWidget::palette()function returns the widget’s palette as aQPaletteobject. Color groups are specified as enums of typeQPalette::ColorGroup.When we want to get an appropriate brush or color for drawing, the correctapproach is to use the current palette, obtained fromQWidget::palette(), andthe required role, for example,QPalette::foreground(). Each role functionreturns a brush, which is normally what we want, but if we just need the colorwe can extract it from the brush, as we did in thepaintEvent(). By default, thebrushes returned are those appropriate to the widget’s state, so we do not needto specify a color group.ThepaintEvent()function finishes by drawing the image itself. The call toIconEditor::pixelRect()returns aQRectthat defines the region to repaint. Asan easy optimization, we don’t redraw pixels that fall outside this region.(0,(0, 0)(width()(width()+--1, height()+--1)wwhh(x,(x,(x, y)Figure 5.4.Drawing a rectangle usingQPainterWe callQPainter::fillRect()to draw a zoomed pixel.QPainter::fillRect()takes aQRectand aQBrush. By passing aQColoras the brush, we obtain a solidfill pattern.QRect IconEditor::pixelRect(int i, int j) const{ if (zoom >= 3) { return QRect(zoom * i + 1, zoom * j + 1, zoom - 1, zoom - 1); } else { return QRect(zoom * i, zoom * j, zoom, zoom); }}ThepixelRect()function returns aQRectsuitable forQPainter::fillRect(). Theiandjparameters are pixel coordinates in theQImage—not in the widget. Ifthe zoom factor is 1, the two coordinate systems coincide exactly."},{"pageNumber":129,"pageContent":"Subclassing QWidget111TheQRectconstructor has the syntaxQRect(x, y, width, height), where (x,y)is the position of the top-left corner of the rectangle andwidth×heightis thesize of the rectangle. If the zoom factor is 3 or more, we reduce the size of therectangle by one pixel horizontally and vertically so that the fill does not drawover the grid lines.void IconEditor::mousePressEvent(QMouseEvent *event){ if (event->button() == Qt::LeftButton) { setImagePixel(event->pos(), true); } else if (event->button() == Qt::RightButton) { setImagePixel(event->pos(), false); }}When the user presses a mouse button, the system generates a “mouse press”event. By reimplementingQWidget::mousePressEvent(), we can respond to thisevent and set or clear the image pixel under the mouse cursor.If the user pressed the left mouse button, we call the private functionsetIm-agePixel()withtrueas the second argument, telling it to set the pixel to thecurrent pen color. If the user pressed the right mouse button, we also callset-ImagePixel(), but passfalseto clear the pixel.void IconEditor::mouseMoveEvent(QMouseEvent *event){ if (event->buttons() & Qt::LeftButton) { setImagePixel(event->pos(), true); } else if (event->buttons() & Qt::RightButton) { setImagePixel(event->pos(), false); }}ThemouseMoveEvent()handles “mouse move” events. By default, these eventsare only generated when the user is holding down a button. It is possible tochange this behavior by callingQWidget::setMouseTracking(), but we don’t needto do so for this example.Just as pressing the left or right mouse button sets or clears a pixel, keeping itpressed and hovering over a pixel is also enough to set or clear a pixel. Sinceit’s possible to hold more than one button pressed down at a time, the valuereturned byQMouseEvent::buttons()is a bitwise OR of the mouse buttons. Wetest whether a certain button is pressed down using the&operator, and if thisis the case we callsetImagePixel().void IconEditor::setImagePixel(const QPoint &pos, bool opaque){ int i = pos.x() / zoom; int j = pos.y() / zoom; if (image.rect().contains(i, j)) { if (opaque) { image.setPixel(i, j, penColor().rgba());"},{"pageNumber":130,"pageContent":"1125. Creating Custom Widgets } else { image.setPixel(i, j, qRgba(0, 0, 0, 0)); } update(pixelRect(i, j)); }}ThesetImagePixel()function is called frommousePressEvent()andmouseMove-Event()to set or clear a pixel. Theposparameter is the position of the mouseon the widget.The first step is to convert the mouse position from widget coordinates toimage coordinates. This is done by dividing thex()andy()components of themouse position by the zoom factor. Next, we check whether the point is withinthe correct range. The check is easily made usingQImage::rect()andQRect::contains(); this effectively checks thatiis between 0 andimage.width()+--1 andthatjis between 0 andimage.height()+--1.Depending on theopaqueparameter, we set or clear the pixel in the image.Clearing a pixel is really setting it to be transparent. We must convert the penQColorto an 32-bit ARGB value for theQImage::setPixel()call. At the end, wecallupdate()with aQRectof the area that needs to be repainted.Now that we have reviewed the member functions, we will return to theQt::WA_StaticContentsattribute that we used in the constructor. This attributetells Qt that the widget’s content doesn’t change when the widget is resizedand that the content stays rooted to the widget’s top-left corner. Qt uses thisinformation to avoid needlessly repainting areas that are already shown whenresizing the widget.Normally, when a widget is resized, Qt generates a paint event for the widget’sentire visible area. But if the widget is created with theQt::WA_StaticContentsattribute, the paint event’s region is restricted to the pixels that were notpreviously shown. This implies that if the widget is resized to a smaller size,no paint event is generated at all.ççFigure 5.5.Resizing aQt::WA_StaticContentswidgetTheIconEditorwidget is now complete. Using the information and examplesfrom earlier chapters, we could write code that uses theIconEditoras a windowin its own right, as a central widget in aQMainWindow, as a child widget inside alayout, or as a child widget inside aQScrollArea(p. 148). In the next section, wewill see how to integrate it withQt Designer."},{"pageNumber":131,"pageContent":"Integrating Custom Widgets with Qt Designer113Integrating Custom Widgets with Qt DesignerBefore we can use custom widgets inQt Designer, we must makeQt Designeraware of them. There are two techniques for doing this: the “promotion”approach and the plugin approach.The promotion approach is the quickest and easiest. It consists of choosing abuilt-in Qt widget that has a similar API to the one we want our custom widgetto have and completing a dialog box inQt Designerwith some informationabout the custom widget. The widget can then be used in forms developedwithQt Designer, although it will be represented by the associated built-in Qtwidget while the form is edited or previewed.Here’s how to insert aHexSpinBoxwidget into a form using this approach:1. Create aQSpinBoxby dragging it fromQt Designer’s widget box ontothe form.2. Right-click the spin box and choosePromote to Custom Widgetfrom thecontext menu.3. Fill in the dialog that pops up with “HexSpinBox” as the class name and“hexspinbox.h” as the header file.Voilà! The code generated byuicwill includehexspinbox.hinstead of<QSpinBox>and instantiate aHexSpinBox. InQt Designer, theHexSpinBoxwidget will berepresented by aQSpinBox, allowing us to set all the properties of aQSpinBox(forexample, the range and the current value).Figure 5.6.Qt Designer’s custom widget dialogThe drawbacks of the promotion approach are that properties that are spe-cific to the custom widget aren’t accessible inQt Designerand that the widgetisn’t rendered as itself. Both these problems can be solved by using the pluginapproach.The plugin approach requires the creation of a plugin library thatQt Designercan load at run-time and use to create instances of the widget. The real widgetis then used byQt Designerwhen editing the form and for previewing, andthanks to Qt’s meta-object system,Qt Designercan dynamically obtain the listof its properties. To show how this works, we will integrate theIconEditorfromthe previous section as a plugin."},{"pageNumber":132,"pageContent":"1145. Creating Custom WidgetsFirst, we must subclassQDesignerCustomWidgetInterfaceand reimplement somevirtual functions. We will assume that the plugin source code is located in adirectory callediconeditorpluginand that theIconEditorsource code is locatedin a parallel directory callediconeditor.Here’s the class definition:#include <QDesignerCustomWidgetInterface>class IconEditorPlugin : public QObject,  public QDesignerCustomWidgetInterface{ Q_OBJECT Q_INTERFACES(QDesignerCustomWidgetInterface)public: IconEditorPlugin(QObject *parent = 0); QString name() const; QString includeFile() const; QString group() const; QIcon icon() const; QString toolTip() const; QString whatsThis() const; bool isContainer() const; QWidget *createWidget(QWidget *parent);};TheIconEditorPluginsubclass is a factory class that encapsulates theIconEd-itorwidget. It inherits bothQObjectandQDesignerCustomWidgetIterfaceanduses theQ_INTERFACES()macro to tellmocthat the second base class is a plugininterface. The functions are used byQt Designerto create instances of the classand to obtain information about it.IconEditorPlugin::IconEditorPlugin(QObject *parent) : QObject(parent){}The constructor is trivial.QString IconEditorPlugin::name() const{ return \"IconEditor\";}Thename()function returns the name of the widget provided by the plugin.QString IconEditorPlugin::includeFile() const{ return \"iconeditor.h\";}TheincludeFile()function returns the name of the header file for the specifiedwidget encapsulated by the plugin. The header file is included in the codegenerated by theuictool."},{"pageNumber":133,"pageContent":"Integrating Custom Widgets with Qt Designer115QString IconEditorPlugin::group() const{ return tr(\"Image Manipulation Widgets\");}Thegroup()function returns the name of the widget box group this customwidget should belong to. If the name isn’t already in use,Qt Designerwillcreate a new group for the widget.QIcon IconEditorPlugin::icon() const{ return QIcon(\":/images/iconeditor.png\");}Theicon()function returns the icon to use to represent the custom widget inQt Designer’s widget box. Here, we assume that theIconEditorPluginhas anassociated Qt resource file with a suitable entry for the icon editor image.QString IconEditorPlugin::toolTip() const{ return tr(\"An icon editor widget\");}ThetoolTip()function returns the tooltip to show when the mouse hovers overthe custom widget inQt Designer’s widget box.QString IconEditorPlugin::whatsThis() const{ return tr(\"This widget is presented in Chapter 5 of <i>C++ GUI \" \"Programming with Qt 4</i> as an example of a custom Qt \" \"widget.\");}ThewhatsThis()function returns the “What’s This?” text forQt Designertodisplay.bool IconEditorPlugin::isContainer() const{ return false;}TheisContainer()function returnstrueif the widget can contain other wid-gets; otherwise, it returnsfalse. For example,QFrameis a widget that can con-tain other widgets. In general, any Qt widget can contain other widgets, butQt Designerdisallows this whenisContainer()returnsfalse.QWidget *IconEditorPlugin::createWidget(QWidget *parent){ return new IconEditor(parent);}Thecreate()function is called byQt Designerto create an instance of a widgetclass with the given parent.Q_EXPORT_PLUGIN2(iconeditorplugin, IconEditorPlugin)"},{"pageNumber":134,"pageContent":"1165. Creating Custom WidgetsAt the end of the source file that implements the plugin class, we must use theQ_EXPORT_PLUGIN2()macro to make the plugin available toQt Designer. The firstargument is the name we want to give the plugin; the second argument is thename of the class that implements it.The.profile for building the plugin looks like this:TEMPLATE = libCONFIG += designer plugin releaseHEADERS = ../iconeditor/iconeditor.h \\ iconeditorplugin.hSOURCES = ../iconeditor/iconeditor.cpp \\ iconeditorplugin.cppRESOURCES = iconeditorplugin.qrcDESTDIR = $(QTDIR)/plugins/designerThe.profile assumes that theQTDIRenvironment variable is set to the directorywhere Qt is installed. When you typemakeornmaketo build the plugin, it willautomatically install itself inQt Designer’spluginsdirectory. Once the pluginis built, theIconEditorwidget can be used inQt Designerin the same way asany of Qt’s built-in widgets.If you want to integrate several custom widgets withQt Designer, you caneither create one plugin for each one of them or combine them into a singleplugin by deriving fromQDesignerCustomWidgetCollectionInterface.Double BufferingDouble buffering is a GUI programming technique that consists of rendering awidget to an off-screen pixmap and copying the pixmap onto the display. Withearlier versions of Qt, this technique was frequently used to eliminate flickerand to provide a snappier user interface.In Qt 4,QWidgethandles this automatically, so we rarely need to worry aboutwidgets flickering. Still, explicit double buffering remains beneficial if the wid-get’s rendering is complex and needed repeatedly. We can then store a pixmappermanently with the widget, always ready for the next paint event, and copythe pixmap to the widget whenever we receive a paint event. It is especial-ly helpful when we want to do small modifications, such as drawing a rubberband, without recomputing the whole widget’s rendering over and over.We will round off this chapter by reviewing thePlottercustom widget. Thiswidget uses double buffering and also demonstrates some other aspects ofQt programming, including keyboard event handling, manual layout, andcoordinate systems.ThePlotterwidget displays one or more curves specified as vectors of coor-dinates. The user can draw a rubber band on the image, and thePlotterwillzoom in on the area enclosed by the rubber band. The user draws the rubberband by clicking a point on the graph, dragging the mouse to another positionwith the left mouse button held down, and releasing the mouse button."},{"pageNumber":135,"pageContent":"Double Buffering117çFigure 5.7.Zooming in on thePlotterwidgetThe user can zoom in repeatedly by drawing a rubber band multiple times,zooming out using theZoom Outbutton, and then zooming back in using theZoom Inbutton. TheZoom InandZoom Outbuttons appear the first time theybecome available, so that they don’t clutter the display if the user doesn’t zoomthe graph.ThePlotterwidget can hold the data for any number of curves. It also main-tains a stack ofPlotSettingsobjects, each of which corresponds to a particularzoom level.Let’s review the class, starting withplotter.h:#ifndef PLOTTER_H#define PLOTTER_H#include <QMap>#include <QPixmap>#include <QVector>#include <QWidget>class QToolButton;class PlotSettings;class Plotter : public QWidget{ Q_OBJECTpublic: Plotter(QWidget *parent = 0); void setPlotSettings(const PlotSettings &settings); void setCurveData(int id, const QVector<QPointF> &data); void clearCurve(int id); QSize minimumSizeHint() const; QSize sizeHint() const;public slots: void zoomIn(); void zoomOut();"},{"pageNumber":136,"pageContent":"1185. Creating Custom WidgetsWe start by including the header files for the Qt classes that are used in theplotter file’s header, and forward declaring the classes that have pointers orreferences in the header.In thePlotterclass, we provide three public functions for setting up the plot,and two public slots for zooming in and out. We also reimplementminimum-SizeHint()andsizeHint()fromQWidget. We store a curve’s points as aQVec-tor<QPointF>, whereQPointFis a floating-point version ofQPoint.protected: void paintEvent(QPaintEvent *event); void resizeEvent(QResizeEvent *event); void mousePressEvent(QMouseEvent *event); void mouseMoveEvent(QMouseEvent *event); void mouseReleaseEvent(QMouseEvent *event); void keyPressEvent(QKeyEvent *event); void wheelEvent(QWheelEvent *event);In the protected section of the class, we declare all theQWidgetevent handlersthat we want to reimplement.private: void updateRubberBandRegion(); void refreshPixmap(); void drawGrid(QPainter *painter); void drawCurves(QPainter *painter); enum { Margin = 50 }; QToolButton *zoomInButton; QToolButton *zoomOutButton; QMap<int, QVector<QPointF> > curveMap; QVector<PlotSettings> zoomStack; int curZoom; bool rubberBandIsShown; QRect rubberBandRect; QPixmap pixmap;};In the private section of the class, we declare a few functions for painting thewidget, a constant, and several member variables. TheMarginconstant is usedto provide some spacing around the graph.Among the member variables ispixmapof typeQPixmap. This variable holdsa copy of the whole widget’s rendering, identical to what is shown on screen.The plot is always drawn onto this off-screen pixmap first; then the pixmap iscopied onto the widget.class PlotSettings{public: PlotSettings(); void scroll(int dx, int dy); void adjust();"},{"pageNumber":137,"pageContent":"Double Buffering119 double spanX() const { return maxX - minX; } double spanY() const { return maxY - minY; } double minX; double maxX; int numXTicks; double minY; double maxY; int numYTicks;private: static void adjustAxis(double &min, double &max, int &numTicks);};#endifThePlotSettingsclass specifies the range of thexandyaxes and the numberof ticks for these axes. Figure 5.8 shows the correspondence between aPlotSettingsobject and aPlotterwidget.By convention,numXTicksandnumYTicksare off by one; ifnumXTicksis 5,Plotterwill actually draw 6 tick marks on thexaxis. This simplifies the calculationslater on.maxYminYminXmaxXnumYTicksnumXTicksFigure 5.8.PlotSettings’s member variablesNow let’s review the implementation file:#include <QtGui>#include <cmath>#include \"plotter.h\"We include the expected header files and import all thestdnamespace’ssymbols into the global namespace. This allows us to access the functions thatare declared in<cmath>without prefixing them withstd::(for example,floor()instead ofstd::floor()).Plotter::Plotter(QWidget *parent) : QWidget(parent){ setBackgroundRole(QPalette::Dark);"},{"pageNumber":138,"pageContent":"1205. Creating Custom Widgets setAutoFillBackground(true); setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding); setFocusPolicy(Qt::StrongFocus); rubberBandIsShown = false; zoomInButton = new QToolButton(this); zoomInButton->setIcon(QIcon(\":/images/zoomin.png\")); zoomInButton->adjustSize(); connect(zoomInButton, SIGNAL(clicked()), this, SLOT(zoomIn())); zoomOutButton = new QToolButton(this); zoomOutButton->setIcon(QIcon(\":/images/zoomout.png\")); zoomOutButton->adjustSize(); connect(zoomOutButton, SIGNAL(clicked()), this, SLOT(zoomOut())); setPlotSettings(PlotSettings());}ThesetBackgroundRole()call tellsQWidgetto use the “dark” component of thepalette as the color for erasing the widget, instead of the “window” component.This gives Qt a default color that it can use to fill any newly revealed pixelswhen the widget is resized to a larger size, beforepaintEvent()even has thechance to paint the new pixels. We also need to callsetAutoFillBackground(true)to enable this mechanism. (By default, child widgets inherit the back-ground from their parent widget.)ThesetSizePolicy()call sets the widget’s size policy toQSizePolicy::Expandingin both directions. This tells any layout manager that is responsible for thewidget that the widget is especially willing to grow, but can also shrink. Thissetting is typical for widgets that can take up a lot of screen space. The defaultisQSizePolicy::Preferredin both directions, which means that the widgetprefers to be the size of its size hint, but it can be shrunk down to its minimumsize hint or expanded indefinitely if necessary.ThesetFocusPolicy(Qt::StrongFocus)call makes the widget accept focus byclicking or by pressingTab. When thePlotterhas focus, it will receive eventsfor key presses. ThePlotterwidget understands a few keys:+to zoom in;+--tozoom out; and the arrow keys to scroll up, down, left, and right.çFigure 5.9.Scrolling thePlotterwidget"},{"pageNumber":139,"pageContent":"Double Buffering121Still in the constructor, we create twoQToolButtons, each with an icon. Thesebuttons allow the user to zoom in and out. The button’s icons are stored ina resource file, so any application that uses thePlotterwidget will need thisentry in its.profile:RESOURCES = plotter.qrcThe resource file is similar to the one we have used for the Spreadsheet appli-cation:<!DOCTYPE RCC><RCC version=\"1.0\"><qresource> <file>images/zoomin.png</file> <file>images/zoomout.png</file></qresource></RCC>TheadjustSize()calls on the buttons set their sizes to be that of their sizehints. The buttons are not put in a layout; instead, we will position them man-ually in thePlotter’s resize event. Since we are not using any layouts, we mustspecify the buttons’ parent explicitly by passingthisto theQPushButtoncon-structor.The call tosetPlotSettings()at the end completes the initialization.void Plotter::setPlotSettings(const PlotSettings &settings){ zoomStack.clear(); zoomStack.append(settings); curZoom = 0; zoomInButton->hide(); zoomOutButton->hide(); refreshPixmap();}ThesetPlotSettings()function is used to specify thePlotSettingsto use fordisplaying the plot. It is called by thePlotterconstructor and can be called byusers of the class. The plotter starts out at its default zoom level. Each timethe user zooms in, a newPlotSettingsinstance is created and put onto the zoomstack. The zoom stack is represented by two member variables:•zoomStackholds the different zoom settings as aQVector<PlotSettings>.•curZoomholds the currentPlotSettings’s index in thezoomStack.After the call tosetPlotSettings(), the zoom stack contains only one entry, andtheZoom InandZoom Outbuttons are hidden. These buttons will not be shownuntil we callshow()on them in thezoomIn()andzoomOut()slots. (Normally, itis sufficient to callshow()on the top-level widget to show all the children. Butwhen we explicitly callhide()on a child widget, it is hidden until we callshow()on it.)The call torefreshPixmap()is necessary to update the display. Usually, wewould callupdate(), but here we do things slightly differently because we"},{"pageNumber":140,"pageContent":"1225. Creating Custom Widgetswant to keep aQPixmapup to date at all times. After regenerating the pixmap,refreshPixmap()callsupdate()to copy the pixmap onto the widget.void Plotter::zoomOut(){ if (curZoom > 0) { --curZoom; zoomOutButton->setEnabled(curZoom > 0); zoomInButton->setEnabled(true); zoomInButton->show(); refreshPixmap(); }}ThezoomOut()slot zooms out if the graph is zoomed in. It decrements thecurrent zoom level and enables theZoom Outbutton depending on whether thegraph can be zoomed out any more or not. TheZoom Inbutton is enabled andshown, and the display is updated with a call torefreshPixmap().void Plotter::zoomIn(){ if (curZoom < zoomStack.count() - 1) { ++curZoom; zoomInButton->setEnabled(curZoom < zoomStack.count() - 1); zoomOutButton->setEnabled(true); zoomOutButton->show(); refreshPixmap(); }}If the user has previously zoomed in and then out again, thePlotSettingsforthe next zoom level will be in the zoom stack, and we can zoom in. (Otherwise,it is still possible to zoom in using a rubber band.)The slot incrementscurZoomto move one level deeper into the zoom stack, setstheZoom Inbutton enabled or disabled depending on whether it’s possible tozoom in any further, and enables and shows theZoom Outbutton. Again, wecallrefreshPixmap()to make the plotter use the latest zoom settings.void Plotter::setCurveData(int id, const QVector<QPointF> &data){ curveMap[id] = data; refreshPixmap();}ThesetCurveData()function sets the curve data for a given curve ID. If acurve with the same ID already exists incurveMap, it is replaced with the newcurve data; otherwise, the new curve is simply inserted. ThecurveMapmembervariable is of typeQMap<int,QVector<QPointF>>.void Plotter::clearCurve(int id){ curveMap.remove(id);"},{"pageNumber":141,"pageContent":"Double Buffering123 refreshPixmap();}TheclearCurve()function removes the specified curve from the curve map.QSize Plotter::minimumSizeHint() const{ return QSize(6 * Margin, 4 * Margin);}TheminimumSizeHint()function is similar tosizeHint(); just assizeHint()spec-ifies a widget’s ideal size,minimumSizeHint()specifies a widget’s ideal minimumsize. A layout never resizes a widget below its minimum size hint.The value we return is 300 × 200 (sinceMarginequals 50) to allow for the marginon all four sides and some space for the plot itself. Below that size, the plotwould be too small to be useful.QSize Plotter::sizeHint() const{ return QSize(12 * Margin, 8 * Margin);}InsizeHint(), we return an “ideal” size in proportion to theMarginconstant andwith the same pleasing 3:2 aspect ratio we used for theminimumSizeHint().This finishes the review of thePlotter’s public functions and slots. Now let’sreview the protected event handlers.void Plotter::paintEvent(QPaintEvent * /* event */){ QStylePainter painter(this); painter.drawPixmap(0, 0, pixmap); if (rubberBandIsShown) { painter.setPen(palette().light().color()); painter.drawRect(rubberBandRect.normalized()  .adjusted(0, 0, -1, -1)); } if (hasFocus()) { QStyleOptionFocusRect option; option.initFrom(this); option.backgroundColor = palette().dark().color(); painter.drawPrimitive(QStyle::PE_FrameFocusRect, option); }}Normally,paintEvent()is the place where we perform all the drawing. But hereall the plot drawing is done beforehand inrefreshPixmap(), so we can render theentire plot simply by copying the pixmap onto the widget at position (0, 0).If the rubber band is visible, we draw it on top of the plot. We use the “light”component from the widget’s current color group as the pen color to ensuregood contrast with the “dark” background. Notice that we draw directly on thewidget, leaving the off-screen pixmap untouched. UsingQRect::normalized()"},{"pageNumber":142,"pageContent":"1245. Creating Custom Widgetsensures that the rubber band rectangle has positive width and height (swap-ping coordinates if necessary), andadjusted()reduces the size of the rectangleby one pixel to allow for its own 1-pixel-wide outline.If thePlotterhas focus, a focus rectangle is drawn using the widget style’sdraw-Primitive()function withQStyle::PE_FrameFocusRectas its first argument andaQStyleOptionFocusRectobject as its second argument. The focus rectangle’sdrawing options are inherited from thePlotterwidget (by theinitFrom()call).The background color must be specified explicitly.When we want to paint using the current style, we can either call aQStylefunction directly, for example,style()->drawPrimitive(QStyle::PE_FrameFocusRect, &option, &painter,  this);or we can use aQStylePainterinstead of a normalQPainter, as we have done inPlotter, and paint more conveniently using that.TheQWidget::style()function returns the style that should be used to drawthe widget. In Qt, a widget style is a subclass ofQStyle. The built-in stylesincludeQWindowsStyle,QWindowsXPStyle,QMotifStyle,QCDEStyle,QMacStyle, andQPlastiqueStyle. Each of these styles reimplements the virtual functions inQStyleto perform the drawing in the correct way for the platform the style isemulating.QStylePainter’sdrawPrimitive()function calls theQStylefunctionof the same name, which can be used for drawing “primitive elements” likepanels, buttons, and focus rectangles. The widget style is usually the same forall widgets in an application (QApplication::style()), but it can be overriddenon a per-widget basis usingQWidget::setStyle().By subclassingQStyle, it is possible to define a custom style. This can be doneto give a distinctive look to an application or a suite of applications. While it isgenerally advisable to use the target platform’s native look and feel, Qt offersa lot of flexibility if you want to be adventurous.Qt’s built-in widgets rely almost exclusively onQStyleto paint themselves.This is why they look like native widgets on all platforms supported by Qt.Custom widgets can be made style-aware either by usingQStyleto paint them-selves or by using built-in Qt widgets as child widgets. ForPlotter, we use acombination of both approaches: The focus rectangle is drawn usingQStyle(viaaQStylePainter), and theZoom InandZoom Outbuttons are built-in Qt widgets.void Plotter::resizeEvent(QResizeEvent * /* event */){ int x = width() - (zoomInButton->width()  + zoomOutButton->width() + 10); zoomInButton->move(x, 5); zoomOutButton->move(x + zoomInButton->width() + 5, 5); refreshPixmap();}"},{"pageNumber":143,"pageContent":"Double Buffering125Whenever thePlotterwidget is resized, Qt generates a “resize” event. Here, wereimplementresizeEvent()to place theZoom InandZoom Outbuttons at the topright of thePlotterwidget.We move theZoom Inbutton and theZoom Outbutton to be side by side, sepa-rated by a 5-pixel gap and with a 5-pixel offset from the top and right edges ofthe parent widget.If we wanted the buttons to stay rooted to the top-left corner, whose coordinatesare (0, 0), we would simply have moved them there in thePlotterconstructor.But we want to track the top-right corner, whose coordinates depend on the sizeof the widget. Because of this, it’s necessary to reimplementresizeEvent()andto set the buttons’ position there.We didn’t set any positions for the buttons in thePlotterconstructor. This isn’ta problem, since Qt always generates a resize event before a widget is shownfor the first time.An alternative to reimplementingresizeEvent()and laying out the child wid-gets manually would have been to use a layout manager (for example,QGridLay-out). Using a layout would have been a little more complicated and would haveconsumed more resources; on the other hand, it would gracefully handle right-to-left layouts, necessary for languages such as Arabic and Hebrew.At the end, we callrefreshPixmap()to redraw the pixmap at the new size.void Plotter::mousePressEvent(QMouseEvent *event){ QRect rect(Margin, Margin, width() - 2 * Margin, height() - 2 * Margin); if (event->button() == Qt::LeftButton) { if (rect.contains(event->pos())) { rubberBandIsShown = true; rubberBandRect.setTopLeft(event->pos()); rubberBandRect.setBottomRight(event->pos()); updateRubberBandRegion(); setCursor(Qt::CrossCursor); } }}When the user presses the left mouse button, we start displaying a rubberband. This involves settingrubberBandIsShowntotrue, initializing therubber-BandRectmember variable with the current mouse pointer position, schedulinga paint event to paint the rubber band, and changing the mouse cursor to havea crosshair shape.TherubberBandRectvariable is of typeQRect. AQRectcan be defined either as an(x,y,width,height) quadruple—where (x,y) is the position of the top-left cornerandwidth×heightis the size of the rectangle—or as a top-left and a bottom-right coordinate pair. Here, we have used the coordinate pair representation.We set the point where the user clicked as both the top-left corner and as the"},{"pageNumber":144,"pageContent":"1265. Creating Custom Widgetsbottom-right corner. Then we callupdateRubberBandRegion()to force a repaintof the (tiny) area covered by the rubber band.Qt provides two mechanisms for controlling the mouse cursor’s shape:•QWidget::setCursor()sets the cursor shape to use when the mouse hoversover a particular widget. If no cursor is set for a widget, the parent wid-get’s cursor is used. The default for top-level widgets is an arrow cursor.•QApplication::setOverrideCursor()sets the cursor shape for the entire ap-plication, overriding the cursors set by individual widgets untilrestore-OverrideCursor()is called.In Chapter 4, we calledQApplication::setOverrideCursor()withQt::WaitCursorto change the application’s cursor to the standard wait cursor.void Plotter::mouseMoveEvent(QMouseEvent *event){ if (rubberBandIsShown) { updateRubberBandRegion(); rubberBandRect.setBottomRight(event->pos()); updateRubberBandRegion(); }}When the user moves the mouse cursor while holding the left button, we firstcallupdateRubberBandRegion()to schedule a paint event to repaint the areawhere the rubber band was, then we recomputerubberBandRectto account forthe mouse move, and finally we callupdateRubberBandRegion()a second time torepaint the area where the rubber band has moved to. This effectively erasesthe rubber band and redraws it at the new coordinates.If the user moves the mouse upward or leftward, it’s likely thatrubberBand-Rect’s nominal bottom-right corner will end up above or to the left of its top-leftcorner. If this occurs, theQRectwill have a negative width or height. We usedQRect::normalized()inpaintEvent()to ensure that the top-left and bottom-rightcoordinates are adjusted to obtain a nonnegative width and height.void Plotter::mouseReleaseEvent(QMouseEvent *event){ if ((event->button() == Qt::LeftButton) && rubberBandIsShown) { rubberBandIsShown = false; updateRubberBandRegion(); unsetCursor(); QRect rect = rubberBandRect.normalized(); if (rect.width() < 4 || rect.height() < 4) return; rect.translate(-Margin, -Margin); PlotSettings prevSettings = zoomStack[curZoom]; PlotSettings settings; double dx = prevSettings.spanX() / (width() - 2 * Margin); double dy = prevSettings.spanY() / (height() - 2 * Margin);"},{"pageNumber":145,"pageContent":"Double Buffering127 settings.minX = prevSettings.minX + dx * rect.left(); settings.maxX = prevSettings.minX + dx * rect.right(); settings.minY = prevSettings.maxY - dy * rect.bottom(); settings.maxY = prevSettings.maxY - dy * rect.top(); settings.adjust(); zoomStack.resize(curZoom + 1); zoomStack.append(settings); zoomIn(); }}When the user releases the left mouse button, we erase the rubber band andrestore the standard arrow cursor. If the rubber band is at least 4 × 4, weperform the zoom. If the rubber band is smaller than that, it’s likely that theuser clicked the widget by mistake or to give it focus, so we do nothing.The code to perform the zoom is a bit complicated. This is because we deal withwidget coordinates and plotter coordinates at the same time. Most of the workwe perform here is to convert therubberBandRectfrom widget coordinates toplotter coordinates. Once we have done the conversion, we callPlotSettings::adjust()to round the numbers and find a sensible number of ticks for eachaxis. Figures 5.10 and 5.11 depict the situation.02468100246810(94, 73)13568(0, 0)(0, 0)ç024681002468102.46.83.26.5Figure 5.10.Converting the rubber band from widget to plotter coordinates024681002468102.07.03.07.0ç23456734567Figure 5.11.Adjusting plotter coordinates and zooming in on the rubber band"},{"pageNumber":146,"pageContent":"1285. Creating Custom WidgetsThen we perform the zoom. The zoom is achieved by pushing the newPlotSet-tingsthat we have just calculated on top of the zoom stack and callingzoomIn()to do the job.void Plotter::keyPressEvent(QKeyEvent *event){ switch (event->key()) { case Qt::Key_Plus: zoomIn(); break; case Qt::Key_Minus: zoomOut(); break; case Qt::Key_Left: zoomStack[curZoom].scroll(-1, 0); refreshPixmap(); break; case Qt::Key_Right: zoomStack[curZoom].scroll(+1, 0); refreshPixmap(); break; case Qt::Key_Down: zoomStack[curZoom].scroll(0, -1); refreshPixmap(); break; case Qt::Key_Up: zoomStack[curZoom].scroll(0, +1); refreshPixmap(); break; default: QWidget::keyPressEvent(event); }}When the user presses a key and thePlotterwidget has focus, thekeyPress-Event()function is called. We reimplement it here to respond to six keys:+,+--,Up,Down,Left, andRight. If the user pressed a key that we are not handling, wecall the base class implementation. For simplicity, we ignore theShift,Ctrl, andAltmodifier keys, which are available throughQKeyEvent::modifiers().void Plotter::wheelEvent(QWheelEvent *event){ int numDegrees = event->delta() / 8; int numTicks = numDegrees / 15; if (event->orientation() == Qt::Horizontal) { zoomStack[curZoom].scroll(numTicks, 0); } else { zoomStack[curZoom].scroll(0, numTicks); } refreshPixmap();}"},{"pageNumber":147,"pageContent":"Double Buffering129Wheel events occur when a mouse wheel is turned. Most mice only providea vertical wheel, but some also have a horizontal wheel. Qt supports bothkinds of wheel. Wheel events go to the widget that has the focus. Thedelta()function returns the distance the wheel was rotated in eighths of a degree.Mice typically work in steps of 15 degrees. Here, we scroll by the requestednumber of ticks by modifying the topmost item on the zoom stack and updatethe display usingrefreshPixmap().The most common use of the wheel mouse is to scroll a scroll bar. When we useQScrollArea(covered in Chapter 6) to provide scroll bars,QScrollAreahandlesthe wheel mouse events automatically, so we don’t need to reimplementwheelEvent()ourselves.This finishes the implementation of the event handlers. Now let’s review theprivate functions.void Plotter::updateRubberBandRegion(){ QRect rect = rubberBandRect.normalized(); update(rect.left(), rect.top(), rect.width(), 1); update(rect.left(), rect.top(), 1, rect.height()); update(rect.left(), rect.bottom(), rect.width(), 1); update(rect.right(), rect.top(), 1, rect.height());}TheupdateRubberBand()function is called frommousePressEvent(),mouseMove-Event(), andmouseReleaseEvent()to erase or redraw the rubber band. It consistsof four calls toupdate()that schedule a paint event for the four small rectangu-lar areas that are covered by the rubber band (two vertical and two horizontallines). Qt provides theQRubberBandclass for drawing rubber bands, but here,hand-coding provided finer control.void Plotter::refreshPixmap(){ pixmap = QPixmap(size()); pixmap.fill(this, 0, 0); QPainter painter(&pixmap); painter.initFrom(this); drawGrid(&painter); drawCurves(&painter); update();}TherefreshPixmap()function redraws the plot onto the off-screen pixmap andupdates the display. We resize the pixmap to have the same size as the widgetand fill it with the widget’s erase color. This color is the “dark” component ofthe palette, because of the call tosetBackgroundRole()in thePlotterconstructor.If the background is a non-solid brush,QPixmap::fill()needs to know the offsetin the widget where the pixmap will end up to align the brush pattern correctly.Here, the pixmap corresponds to the entire widget, so we specify position(0, 0)."},{"pageNumber":148,"pageContent":"1305. Creating Custom WidgetsThen we create aQPainterto draw on the pixmap. TheinitFrom()call sets thepainter’s pen, background, and font to the same ones as thePlotterwidget.Next we calldrawGrid()anddrawCurves()to perform the drawing. At the end,we callupdate()to schedule a paint event for the whole widget. The pixmap iscopied to the widget in thepaintEvent()function (p. 123).void Plotter::drawGrid(QPainter *painter){ QRect rect(Margin, Margin, width() - 2 * Margin, height() - 2 * Margin); if (!rect.isValid()) return; PlotSettings settings = zoomStack[curZoom]; QPen quiteDark = palette().dark().color().light(); QPen light = palette().light().color(); for (int i = 0; i <= settings.numXTicks; ++i) { int x = rect.left() + (i * (rect.width() - 1)  / settings.numXTicks); double label = settings.minX + (i * settings.spanX()  / settings.numXTicks); painter->setPen(quiteDark); painter->drawLine(x, rect.top(), x, rect.bottom()); painter->setPen(light); painter->drawLine(x, rect.bottom(), x, rect.bottom() + 5); painter->drawText(x - 50, rect.bottom() + 5, 100, 15,  Qt::AlignHCenter | Qt::AlignTop,  QString::number(label)); } for (int j = 0; j <= settings.numYTicks; ++j) { int y = rect.bottom() - (j * (rect.height() - 1)  / settings.numYTicks); double label = settings.minY + (j * settings.spanY()  / settings.numYTicks); painter->setPen(quiteDark); painter->drawLine(rect.left(), y, rect.right(), y); painter->setPen(light); painter->drawLine(rect.left() - 5, y, rect.left(), y); painter->drawText(rect.left() - Margin, y - 10, Margin - 5, 20,  Qt::AlignRight | Qt::AlignVCenter,  QString::number(label)); } painter->drawRect(rect.adjusted(0, 0, -1, -1));}ThedrawGrid()function draws the grid behind the curves and the axes. Thearea on which we draw the grid is specified byrect. If the widget isn’t largeenough to accommodate the graph, we return immediately.The firstforloop draws the grid’s vertical lines and the ticks along thexaxis.The secondforloop draws the grid’s horizontal lines and the ticks along theyaxis. At the end, we draw a rectangle along the margins. ThedrawText()"},{"pageNumber":149,"pageContent":"Double Buffering131function is used to draw the numbers corresponding to the tick marks onboth axes.The calls todrawText()have the following syntax:painter->drawText(x, y, width, height, alignment, text);where (x,y,width,height) define a rectangle,alignmentthe position of the textwithin that rectangle, andtextthe text to draw.void Plotter::drawCurves(QPainter *painter){ static const QColor colorForIds[6] = { Qt::red, Qt::green, Qt::blue, Qt::cyan, Qt::magenta, Qt::yellow }; PlotSettings settings = zoomStack[curZoom]; QRect rect(Margin, Margin, width() - 2 * Margin, height() - 2 * Margin); if (!rect.isValid()) return; painter->setClipRect(rect.adjusted(+1, +1, -1, -1)); QMapIterator<int, QVector<QPointF> > i(curveMap); while (i.hasNext()) { i.next(); int id = i.key(); const QVector<QPointF> &data = i.value(); QPolygonF polyline(data.count()); for (int j = 0; j < data.count(); ++j) { double dx = data[j].x() - settings.minX; double dy = data[j].y() - settings.minY; double x = rect.left() + (dx * (rect.width() - 1)  / settings.spanX()); double y = rect.bottom() - (dy * (rect.height() - 1)  / settings.spanY()); polyline[j] = QPointF(x, y); } painter->setPen(colorForIds[uint(id) % 6]); painter->drawPolyline(polyline); }}ThedrawCurves()function draws the curves on top of the grid. We start bycallingsetClipRect()to set theQPainter’s clip region to the rectangle thatcontains the curves (excluding the margins and the frame around the graph).QPainterwill then ignore drawing operations on pixels outside the area.Next, we iterate over all the curves using a Java-style iterator, and for eachcurve, we iterate over its constituentQPointFs. Thekey()function gives thecurve’s ID, and thevalue()function gives the corresponding curve data as aQVector<QPointF>. The innerforloop converts eachQPointFfrom plotter coordi-nates to widget coordinates and stores them in thepolylinevariable."},{"pageNumber":150,"pageContent":"1325. Creating Custom WidgetsOnce we have converted all the points of a curve to widget coordinates, weset the pen color for the curve (using one of a set of predefined colors) and calldrawPolyline()to draw a line that goes through all the curve’s points.This is the completePlotterclass. All that remains are a few functions inPlotSettings.PlotSettings::PlotSettings(){ minX = 0.0; maxX = 10.0; numXTicks = 5; minY = 0.0; maxY = 10.0; numYTicks = 5;}ThePlotSettingsconstructor initializes both axes to the range 0 to 10 with5 tick marks.void PlotSettings::scroll(int dx, int dy){ double stepX = spanX() / numXTicks; minX += dx * stepX; maxX += dx * stepX; double stepY = spanY() / numYTicks; minY += dy * stepY; maxY += dy * stepY;}Thescroll()function increments (or decrements)minX,maxX,minY, andmaxYbythe interval between two ticks times a given number. This function is used toimplement scrolling inPlotter::keyPressEvent().void PlotSettings::adjust(){ adjustAxis(minX, maxX, numXTicks); adjustAxis(minY, maxY, numYTicks);}Theadjust()function is called frommouseReleaseEvent()to round theminX,maxX,minY, andmaxYvalues to “nice” values and to determine the number of ticksappropriate for each axis. The private functionadjustAxis()does its work oneaxis at a time.void PlotSettings::adjustAxis(double &min, double &max,  int &numTicks){ const int MinTicks = 4; double grossStep = (max - min) / MinTicks; double step = pow(10.0, floor(log10(grossStep))); if (5 * step < grossStep) { step *= 5;"},{"pageNumber":151,"pageContent":"Double Buffering133 } else if (2 * step < grossStep) { step *= 2; } numTicks = int(ceil(max / step) - floor(min / step)); if (numTicks < MinTicks) numTicks = MinTicks; min = floor(min / step) * step; max = ceil(max / step) * step;}TheadjustAxis()function converts itsminandmaxparameters into “nice”numbers and sets itsnumTicksparameter to the number of ticks it calculatesto be appropriate for the given [min,max] range. BecauseadjustAxis()needs tomodify the actual variables (minX,maxX,numXTicks, etc.) and not just copies, itsparameters are non-const references.Most of the code inadjustAxis()simply attempts to determine an appropriatevalue for the interval between two ticks (the “step”). To obtain nice numbersalong the axis, we must select the step with care. For example, a step value of3.8 would lead to an axis with multiples of 3.8, which is difficult for people torelate to. For axes labeled in decimal notation, “nice” step values are numbersof the formn10 , 2 ·n10 , or 5 ·n10 .We start by computing the “gross step”, a kind of maximum for the step value.Then we find the corresponding number of the formn10 that is smaller thanor equal to the gross step. We do this by taking the decimal logarithm of thegross step, rounding that value down to a whole number, then raising 10 tothe power of this rounded number. For example, if the gross step is 236, wecompute log 236 = 2.37291...; then we round it down to 2 and obtain 102= 100as the candidate step value of the formn10 .Once we have the first candidate step value, we can use it to calculate theother two candidates: 2 ·n10 and 5 ·n10 . For the example above, the two othercandidates are 200 and 500. The 500 candidate is larger than the gross step, sowe can’t use it. But 200 is smaller than 236, so we use 200 for the step size inthis example.It’s fairly easy to derivenumTicks,min, andmaxfrom the step value. The newminvalue is obtained by rounding the originalmindown to the nearest multipleof the step, and the newmaxvalue is obtained by rounding up to the nearestmultiple of the step. The newnumTicksis the number of intervals between theroundedminandmaxvalues. For example, ifminis 240 andmaxis 1184 uponentering the function, the new range becomes [200, 1200], with 5 tick marks.This algorithm will give suboptimal results in some cases. A more sophisticatedalgorithm is described in Paul S. Heckbert’s article “Nice Numbers for GraphLabels” published inGraphics Gems(ISBN 0-12-286166-3).This chapter has brought us to the end of Part I. It has explained how tocustomize an existing Qt widget and how to build a widget from the ground upusingQWidgetas the base class. We have already seen how to compose a widget"},{"pageNumber":152,"pageContent":"1345. Creating Custom Widgetsfrom existing widgets in Chapter 2, and we will explore the theme further inChapter 6.At this point, we know enough to write complete GUI applications using Qt. InParts II and III, we will explore Qt in greater depth so that we can make fulluse of Qt’s power."},{"pageNumber":153,"pageContent":"Part IIIntermediate Qt"},{"pageNumber":155,"pageContent":"6. Layout ManagementuLaying Out Widgets on a FormuStacked LayoutsuSplittersuScrolling AreasuDock Widgets and ToolbarsuMultiple Document InterfaceEvery widget that is placed on a form must be given an appropriate size and po-sition. Qt provides several classes that lay out widgets on a form:QHBoxLayout,QVBoxLayout,QGridLayout, andQStackLayout. These classes are so convenient andeasy to use that almost every Qt developer uses them, either directly in sourcecode or throughQt Designer.Another reason to use Qt’s layout classes is that they ensure that forms adaptautomatically to different fonts, languages, and platforms. If the user changesthe system’s font settings, the application’s forms will respond immediately,resizing themselves if necessary. And if you translate the application’s userinterface to other languages, the layout classes take into consideration thewidgets’ translated contents to avoid text truncation.Other classes that perform layout management includeQSplitter,QScrollArea,QMainWindow, andQWorkspace. What these classes have in common is that theyprovide a flexible layout that the user can manipulate. For example,QSplitterprovides a splitter bar that the user can drag to resize widgets, andQWorkspaceprovides support for MDI (multiple document interface), a means of showingmany documents simultaneously within an application’s main window.Because they are often used as alternatives to the layout classes proper, theyare covered in this chapter.Laying Out Widgets on a FormThere are three basic ways of managing the layout of child widgets on a form:absolute positioning, manual layout, and layout managers. We will look at eachof these approaches in turn, using the Find File dialog shown in Figure 6.1 asour example.137"},{"pageNumber":156,"pageContent":"1386. Layout ManagementFigure 6.1.The Find File dialogAbsolute positioning is the crudest way of laying out widgets. It is achieved byassigning hard-coded sizes and positions to the form’s child widgets and a fixedsize to the form. Here’s what theFindFileDialogconstructor looks like usingabsolute positioning:FindFileDialog::FindFileDialog(QWidget *parent) : QDialog(parent){••• namedLabel->setGeometry(9, 9, 50, 25); namedLineEdit->setGeometry(65, 9, 200, 25); lookInLabel->setGeometry(9, 40, 50, 25); lookInLineEdit->setGeometry(65, 40, 200, 25); subfoldersCheckBox->setGeometry(9, 71, 256, 23); tableWidget->setGeometry(9, 100, 256, 100); messageLabel->setGeometry(9, 206, 256, 25); findButton->setGeometry(271, 9, 85, 32); stopButton->setGeometry(271, 47, 85, 32); closeButton->setGeometry(271, 84, 85, 32); helpButton->setGeometry(271, 199, 85, 32); setWindowTitle(tr(\"Find Files or Folders\")); setFixedSize(365, 240);}Absolute positioning has many disadvantages:• The user cannot resize the window.• Some text may be truncated if the user chooses an unusually large font orif the application is translated into another language.• The widgets might have inappropriate sizes for some styles.• The positions and sizes must be calculated manually. This is tedious anderror-prone, and makes maintenance painful."},{"pageNumber":157,"pageContent":"Laying Out Widgets on a Form139An alternative to absolute positioning is manual layout. With manual layout,the widgets are still given absolute positions, but their sizes are made propor-tional to the size of the window rather than being entirely hard-coded. Thiscan be achieved by reimplementing the form’sresizeEvent()function to set itschild widgets’ geometries:FindFileDialog::FindFileDialog(QWidget *parent) : QDialog(parent){••• setMinimumSize(265, 190); resize(365, 240);}void FindFileDialog::resizeEvent(QResizeEvent * /* event */){ int extraWidth = width() - minimumWidth(); int extraHeight = height() - minimumHeight(); namedLabel->setGeometry(9, 9, 50, 25); namedLineEdit->setGeometry(65, 9, 100 + extraWidth, 25); lookInLabel->setGeometry(9, 40, 50, 25); lookInLineEdit->setGeometry(65, 40, 100 + extraWidth, 25); subfoldersCheckBox->setGeometry(9, 71, 156 + extraWidth, 23); tableWidget->setGeometry(9, 100, 156 + extraWidth,  50 + extraHeight); messageLabel->setGeometry(9, 156 + extraHeight, 156 + extraWidth,  25); findButton->setGeometry(171 + extraWidth, 9, 85, 32); stopButton->setGeometry(171 + extraWidth, 47, 85, 32); closeButton->setGeometry(171 + extraWidth, 84, 85, 32); helpButton->setGeometry(171 + extraWidth, 149 + extraHeight, 85,  32);}In theFindFileDialogconstructor, we set the form’s minimum size to 265 × 190and the initial size to 365 × 240. In theresizeEvent()handler, we give any extraspace to the widgets that we want to grow. This ensures that the form scalessmoothly when the user resizes it.çFigure 6.2.Resizing a resizable dialog"},{"pageNumber":158,"pageContent":"1406. Layout ManagementJust like absolute positioning, manual layout requires a lot of hard-coded con-stants to be calculated by the programmer. Writing code like this is tiresome,especially if the design changes. And there is still the risk of text truncation.We can avoid this risk by taking account of the child widgets’ size hints, butthat would complicate the code even further.The most convenient solution for laying out widgets on a form is to use Qt’slayout managers. The layout managers provide sensible defaults for everytype of widget and take into account each widget’s size hint, which in turntypically depends on the widget’s font, style, and contents. Layout managersalso respect minimum and maximum sizes, and automatically adjust thelayout in response to font changes, content changes, and window resizing.The three most important layout managers areQHBoxLayout,QVBoxLayout, andQGridLayout. These classes inheritQLayout, which provides the basic frameworkfor layouts. All three classes are fully supported byQt Designerand can alsobe used directly in code.Here’s theFindFileDialogcode using layout managers:FindFileDialog::FindFileDialog(QWidget *parent) : QDialog(parent){••• QGridLayout *leftLayout = new QGridLayout; leftLayout->addWidget(namedLabel, 0, 0); leftLayout->addWidget(namedLineEdit, 0, 1); leftLayout->addWidget(lookInLabel, 1, 0); leftLayout->addWidget(lookInLineEdit, 1, 1); leftLayout->addWidget(subfoldersCheckBox, 2, 0, 1, 2); leftLayout->addWidget(tableWidget, 3, 0, 1, 2); leftLayout->addWidget(messageLabel, 4, 0, 1, 2); QVBoxLayout *rightLayout = new QVBoxLayout; rightLayout->addWidget(findButton); rightLayout->addWidget(stopButton); rightLayout->addWidget(closeButton); rightLayout->addStretch(); rightLayout->addWidget(helpButton); QHBoxLayout *mainLayout = new QHBoxLayout; mainLayout->addLayout(leftLayout); mainLayout->addLayout(rightLayout); setLayout(mainLayout); setWindowTitle(tr(\"Find Files or Folders\"));}The layout is handled by oneQHBoxLayout, oneQGridLayout, and oneQVBoxLayout.TheQGridLayouton the left and theQVBoxLayouton the right are placed side byside by the outerQHBoxLayout. The margin around the dialog and the spacingbetween the child widgets are set to default values based on the currentwidget style; they can be changed usingQLayout::setMargin()andQLayout::setSpacing()."},{"pageNumber":159,"pageContent":"Laying Out Widgets on a Form141The same dialog could be created visually inQt Designerby placing the childwidgets in their approximate positions; selecting those that need to be laidout together; and clickingForm|Lay Out Horizontally,Form|Lay Out Vertically, orForm|Lay Out in a Grid. We used this approach in Chapter 2 for creating theSpreadsheet application’s Go-to-Cell and Sort dialogs.Window Title5QLabelQLineEditQLabelQLineEditQCheckBoxQTreeWidgetQLabelQPushButtonQPushButtonQPushButtonεεεεεεεεεεεQPushButtonmainLamainLayoutleftLaleftLayoutightLarightLayoutFigure 6.3.The Find File dialog’s layoutUsingQHBoxLayoutandQVBoxLayoutis fairly straightforward, but usingQGrid-Layoutis a bit more involved.QGridLayoutworks on a two-dimensional grid ofcells. TheQLabelin the top-left corner of the layout is at position (0, 0), and thecorrespondingQLineEditis at position (0, 1). TheQCheckBoxspans two columns;it occupies the cells in positions (2, 0) and (2, 1). TheQTreeWidgetand theQLabelbeneath it also span two columns. The calls toaddWidget()have the followingsyntax:layout->addWidget(widget, row, column, rowSpan, columnSpan);Here,widgetis the child widget to insert into the layout, (row,column) is thetop-left cell occupied by the widget,rowSpanis the number of rows occupied bythe widget, andcolumnSpanis the number of columns occupied by the widget.If omitted, therowSpanandcolumnSpanparameters default to 1.TheaddStretch()call tells the layout manager to consume space at that pointin the layout. By adding a stretch item, we have told the layout manager to putany excess space between theClosebutton and theHelpbutton. InQt Designer,we can achieve the same effect by inserting a spacer. Spacers appear inQtDesigneras blue “springs”."},{"pageNumber":160,"pageContent":"1426. Layout ManagementUsing layout managers provides additional benefits to those we have discussedso far. If we add a widget to a layout or remove a widget from a layout, thelayout will automatically adapt to the new situation. The same applies if wecallhide()orshow()on a child widget. If a child widget’s size hint changes,the layout will be automatically redone, taking into account the new size hint.Also, layout managers automatically set a minimum size for the form as awhole, based on the form’s child widgets’ minimum sizes and size hints.In the examples presented so far, we have simply put widgets into layouts andused spacer items (stretches) to consume any excess space. In some cases,this isn’t sufficient to make the layout look exactly the way we want. In thesesituations, we can adjust the layout by changing the size policies and size hintsof the widgets being laid out.A widget’s size policy tells the layout system how it should stretch or shrink.Qt provides sensible default size policies for all its built-in widgets, but sinceno single default can account for every possible layout, it is still common fordevelopers to change the size policies for one or two widgets on a form. AQSizePolicyhas both a horizontal and a vertical component. Here are the mostuseful values:•Fixedmeans that the widget cannot grow or shrink. The widget alwaysstays at the size of its size hint.•Minimummeans that the widget’s size hint is its minimum size. The widgetcannot shrink below the size hint, but it can grow to fill available spaceif necessary.•Maximummeans that the widget’s size hint is its maximum size. The widgetcan be shrunk down to its minimum size hint.•Preferredmeans that the widget’s size hint is its preferred size, but thatthe widget can still shrink or grow if necessary.•Expandingmeans that the widget can shrink or grow and that it is especial-ly willing to grow.Figure 6.4 summarizes the meaning of the different size policies, using aQLabelshowing the text “Some Text” as an example.FixedSome TextMinimumSome TextSome TextMaximumSomSome TextPreferredSomSome TextSome TextExpandingSomSome TextSome Textsizmin size hintesize hintFigure 6.4.The meaning of the different size policies"},{"pageNumber":161,"pageContent":"Laying Out Widgets on a Form143In the figure,PreferredandExpandingare depicted the same way. So what is thedifference? When a form that contains bothPreferredandExpandingwidgetsis resized, extra space is given to theExpandingwidgets, while thePreferredwidgets stay at their size hint.There are two other size policies:MinimumExpandingandIgnored. The former wasnecessary in a few rare cases in older versions of Qt, but it isn’t useful anymore;the preferred approach is to useExpandingand reimplementminimumSizeHint()appropriately. The latter is similar toExpanding, except that it ignores the wid-get’s size hint and minimum size hint.In addition to the size policy’s horizontal and vertical components, theQSizePol-icyclass stores a horizontal and a vertical stretch factor. These stretch factorscan be used to indicate that different child widgets should grow at differentrates when the form expands. For example, if we have aQTreeWidgetabove aQTextEditand we want theQTextEditto be twice as tall as theQTreeWidget, wecan set theQTextEdit’s vertical stretch factor to 2 and theQTreeWidget’s verticalstretch factor to 1.Yet another way of influencing a layout is to set a minimum size, a maximumsize, or a fixed size on the child widgets. The layout manager will respectthese constraints when laying out the widgets. And if this isn’t sufficient, wecan always derive from the child widget’s class and reimplementsizeHint()toobtain the size hint we need.Stacked LayoutsTheQStackedLayoutclass lays out a set of child widgets, or “pages”, and showsonly one at a time, hiding the others from the user. TheQStackedLayoutitselfis invisible and provides no intrinsic means for the user to change page. Thesmall arrows and the dark gray frame in Figure 6.5 are provided byQt Design-erto make the layout easier to design with. For convenience, Qt also includesQStackedWidget, which provides aQWidgetwith a built-inQStackedLayout.Figure 6.5.QStackedLayoutThe pages are numbered from 0. To make a specific child widget visible, we cancallsetCurrentIndex()with a page number. The page number for a child widgetis available usingindexOf()."},{"pageNumber":162,"pageContent":"1446. Layout ManagementFigure 6.6.Two pages of the Preferences dialogThe Preferences dialog shown in Figure 6.6 is an example that usesQStacked-Layout. The dialog consists of aQListWidgeton the left and aQStackedLayoutonthe right. Each item in theQListWidgetcorresponds to a different page in theQStackedLayout. Here’s the relevant code from the dialog’s constructor:PreferenceDialog::PreferenceDialog(QWidget *parent) : QDialog(parent){••• listWidget = new QListWidget; listWidget->addItem(tr(\"Appearance\")); listWidget->addItem(tr(\"Web Browser\")); listWidget->addItem(tr(\"Mail & News\")); listWidget->addItem(tr(\"Advanced\")); stackedLayout = new QStackedLayout; stackedLayout->addWidget(appearancePage); stackedLayout->addWidget(webBrowserPage); stackedLayout->addWidget(mailAndNewsPage); stackedLayout->addWidget(advancedPage); connect(listWidget, SIGNAL(currentRowChanged(int)), stackedLayout, SLOT(setCurrentIndex(int)));••• listWidget->setCurrentRow(0);}We create aQListWidgetand populate it with the page names. Then we create aQStackedLayoutand calladdWidget()for each page. We connect the list widget’scurrentRowChanged(int)signal to the stacked layout’ssetCurrentIndex(int)toimplement the page switching and callsetCurrentRow()on the list widget at theend of the constructor to start on page 0.Forms like this are also very easy to create usingQt Designer:1. Create a new form based on the “Dialog” or the “Widget” template.2. Add aQListWidgetand aQStackedWidgetto the form.3. Fill each page with child widgets and layouts."},{"pageNumber":163,"pageContent":"Stacked Layouts145(To create a new page, right-click and chooseInsert Page; to switch pages,click the tiny left or right arrow located at the top-right of theQStackedWid-get.)4. Lay the widgets out side by side using a horizontal layout.5. Connect the list widget’scurrentRowChanged(int)signal to the stackedwidget’ssetCurrentIndex(int)slot.6. Set the value of the list widget’scurrentRowproperty to 0.Since we have implemented page switching using predefined signals and slots,the dialog will exhibit the correct behavior when previewed inQt Designer.SplittersAQSplitteris a widget that contains other widgets. The widgets in a splitterare separated by splitter handles. Users can change the sizes of a splitter’schild widgets by dragging the handles. Splitters can often be used as analternative to layout managers, to give more control to the user.Figure 6.7.The Splitter applicationThe child widgets of aQSplitterare automatically placed side by side (orone below the other) in the order in which they are created, with splitter barsbetween adjacent widgets. Here’s the code for creating the window depicted inFigure 6.7:int main(int argc, char *argv[]){ QApplication app(argc, argv); QTextEdit *editor1 = new QTextEdit; QTextEdit *editor2 = new QTextEdit; QTextEdit *editor3 = new QTextEdit; QSplitter splitter(Qt::Horizontal); splitter.addWidget(editor1); splitter.addWidget(editor2); splitter.addWidget(editor3);••• splitter.show(); return app.exec();}"},{"pageNumber":164,"pageContent":"1466. Layout ManagementThe example consists of threeQTextEdits laid out horizontally by aQSplitterwidget. Unlike layout managers, which simply lay out a form’s child widgetsand have no visual representation,QSplitterinherits fromQWidgetand can beused like any other widget.Window Title5QSplitterQTextEditQTextEditQTextEditFigure 6.8.The Splitter application’s widgetsComplex layouts can be achieved by nesting horizontal and verticalQSplitters.For example, the Mail Client application shown in Figure 6.9 consists of ahorizontalQSplitterthat contains a verticalQSplitteron its right side.Figure 6.9.The Mail Client application on Mac OS XHere’s the code in the constructor of the Mail Client application’sQMainWindowsubclass:MailClient::MailClient(){•••"},{"pageNumber":165,"pageContent":"Splitters147 rightSplitter = new QSplitter(Qt::Vertical); rightSplitter->addWidget(messagesTreeWidget); rightSplitter->addWidget(textEdit); rightSplitter->setStretchFactor(1, 1); mainSplitter = new QSplitter(Qt::Horizontal); mainSplitter->addWidget(foldersTreeWidget); mainSplitter->addWidget(rightSplitter); mainSplitter->setStretchFactor(1, 1); setCentralWidget(mainSplitter); setWindowTitle(tr(\"Mail Client\")); readSettings();}After creating the three widgets that we want to display, we create a verticalsplitter,rightSplitter, and add the two widgets we want on the right. Thenwe create a horizontal splitter,mainSplitter, and add the widget we want itto display on the left andrightSplitterwhose widgets we want shown on theright. We makemainSplittertheQMainWindow’s central widget.When the user resizes a window,QSplitternormally distributes the space sothat the relative sizes of the child widgets stay the same. In the Mail Clientexample, we don’t want this behavior; instead, we want theQTreeWidgetandtheQTableWidgetto keep their sizes and we want to give any extra space totheQTextEdit. This is achieved by the twosetStretchFactor()calls. The firstargument is the 0-based index of the splitter’s child widget, and the secondargument is the stretch factor we want to set; the default is 0.messagesTableWidgetfoldersTreeWidgettextEditSplittermainSplitter0011SplitterrightSplitter0011Figure 6.10.The Mail Client’s splitter indexingThe firstsetStretchFactor()call is onrightSplitter, and it sets the widget atposition 1 (textEdit) to have a stretch factor of 1. The secondsetStretchFactor()call is onmainSplitter, and it sets the widget at position 1 (rightSplitter) tohave a stretch factor of 1. This ensures that thetextEditwill get any additionalspace that is available.When the application is started,QSplittergives the child widgets appropriatesizes based on their initial sizes (or based on their size hint if no initial sizeis specified). We can move the splitter handles programmatically by callingQSplitter::setSizes(). TheQSplitterclass also provides a means of saving and"},{"pageNumber":166,"pageContent":"1486. Layout Managementrestoring its state the next time the application is run. Here’s thewriteSet-tings()function that saves the Mail Client’s settings:void MailClient::writeSettings(){ QSettings settings(\"Software Inc.\", \"Mail Client\"); settings.beginGroup(\"mainWindow\"); settings.setValue(\"size\", size()); settings.setValue(\"mainSplitter\", mainSplitter->saveState()); settings.setValue(\"rightSplitter\", rightSplitter->saveState()); settings.endGroup();}Here’s the correspondingreadSettings()function:void MailClient::readSettings(){ QSettings settings(\"Software Inc.\", \"Mail Client\"); settings.beginGroup(\"mainWindow\"); resize(settings.value(\"size\", QSize(480, 360)).toSize()); mainSplitter->restoreState( settings.value(\"mainSplitter\").toByteArray()); rightSplitter->restoreState( settings.value(\"rightSplitter\").toByteArray()); settings.endGroup();}QSplitteris fully supported byQt Designer. To put widgets into a splitter, placethe child widgets approximately in their desired positions, select them, andclickForm|Lay Out Horizontally in SplitterorForm|Lay Out Vertically in Splitter.Scrolling AreasTheQScrollAreaclass provides a scrollable viewport and two scroll bars. If wewant to add scroll bars to a widget, it is much simpler to use aQScrollAreathanto instantiate our ownQScrollBars and implement the scrolling functionalityourselves.viewport()verticalScrollBar()horizontalScrollBar()Figure 6.11.QScrollArea’s constituent widgets"},{"pageNumber":167,"pageContent":"Scrolling Areas149The way to useQScrollAreais to callsetWidget()with the widget we want toadd scroll bars to.QScrollAreaautomatically reparents the widget to make ita child of the viewport (accessible throughQScrollArea::viewport()) if it isn’talready. For example, if we want scroll bars around theIconEditorwidget wedeveloped in Chapter 5, we can write this:int main(int argc, char *argv[]){ QApplication app(argc, argv); IconEditor *iconEditor = new IconEditor; iconEditor->setIconImage(QImage(\":/images/mouse.png\")); QScrollArea scrollArea; scrollArea.setWidget(iconEditor); scrollArea.viewport()->setBackgroundRole(QPalette::Dark); scrollArea.viewport()->setAutoFillBackground(true); scrollArea.setWindowTitle(QObject::tr(\"Icon Editor\")); scrollArea.show(); return app.exec();}TheQScrollAreapresents the widget at its current size or uses the size hint ifthe widget hasn’t been resized yet. By callingsetWidgetResizable(true), we cantellQScrollAreato automatically resize the widget to take advantage of anyextra space beyond its size hint.By default, the scroll bars are only displayed when the viewport is smaller thanthe child widget. We can force the scroll bars to always be shown by settingscroll bar policies:scrollArea.setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOn);scrollArea.setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);çFigure 6.12.Resizing aQScrollArea"},{"pageNumber":168,"pageContent":"1506. Layout ManagementQScrollAreainherits much of its functionality fromQAbstractScrollArea. ClasseslikeQTextEditandQAbstractItemView(the base class of Qt’s item view classes)derive fromQAbstractScrollArea, so we don’t need to wrap them in aQScrollAreato get scroll bars.Dock Widgets and ToolbarsDock widgets are widgets that can be docked inside aQMainWindowor floatedas independent windows.QMainWindowprovides four dock widget areas: oneabove, one below, one to the left, and one to the right of the central widget.Applications like Microsoft Visual Studio andQt Linguistmake extensive useof dock windows to provide a very flexible user interface. In Qt, dock widgetsare instances ofQDockWidget.Figure 6.13.AQMainWindowwith a dock widgetEvery dock widget has its own title bar, even when it is docked. Users can movedock windows from one dock area to another by dragging the title bar. Theycan also detach a dock window from an area and let the dock window float as anindependent window by dragging the dock window outside of any dock area.Free-floating dock windows are always “on top” of their main window. Userscan close aQDockWidgetby clicking the close button in the widget’s title bar.Any combination of these features can be disabled by callingQDockWidget::setFeatures().In earlier versions of Qt, toolbars were treated like dock widgets and sharedthe same dock areas. Starting with Qt 4, toolbars occupy their own areas"},{"pageNumber":169,"pageContent":"Dock Widgets and Toolbars151around the central widget (as shown in Figure 6.14) and can’t be undocked. Ifa floating toolbar is required, we can simply put it inside aQDockWindow.Window Title5Menu BarTop Toolbar AreaLeft Toolbar AreaTop Dock AreaLeft Dock AreaRight Dock AreaBottom Dock AreaRight Toolbar AreaBottom Toolbar AreaStatus BarFigure 6.14.QMainWindow’s dock and toolbar areasThe corners indicated with dotted lines can belong to either of their twoadjoining dock areas. For example, we could make the top-left corner belongto the left dock area by callingQMainWindow::setCorner(Qt::TopLeftCorner, Qt::LeftDockWidgetArea).The following code snippet shows how to wrap an existing widget (in this case,aQTreeWidget) in aQDockWidgetand insert it into the right dock area: QDockWidget *shapesDockWidget = new QDockWidget(tr(\"Shapes\")); shapesDockWidget->setWidget(treeWidget); shapesDockWidget->setAllowedAreas(Qt::LeftDockWidgetArea  | Qt::RightDockWidgetArea); addDockWidget(Qt::RightDockWidgetArea, shapesDockWidget);ThesetAllowedAreas()call specifies constraints on which dock areas can acceptthe dock window. Here, we only allow the user to drag the dock widget intothe left and right dock areas, where there is enough vertical space for it to bedisplayed sensibly. If no allowed areas are explicitly set, the user can drag thedock widget to any of the four areas.Here’s how to create a toolbar containing aQComboBox, aQSpinBox, and a fewQToolButtons from aQMainWindowsubclass’s constructor:"},{"pageNumber":170,"pageContent":"1526. Layout Management QToolBar *fontToolBar = new QToolBar(tr(\"Font\")); fontToolBar->addWidget(familyComboBox); fontToolBar->addWidget(sizeSpinBox); fontToolBar->addAction(boldAction); fontToolBar->addAction(italicAction); fontToolBar->addAction(underlineAction); fontToolBar->setAllowedAreas(Qt::TopToolBarArea  | Qt::BottomToolBarArea); addToolBar(fontToolBar);If we want to save the position of all the dock widgets and toolbars so that wecan restore them the next time the application is run, we can write code thatis similar to the code we used to save aQSplitter’s state, usingQMainWindow’ssaveState()andrestoreState()functions:void MainWindow::writeSettings(){ QSettings settings(\"Software Inc.\", \"Icon Editor\"); settings.beginGroup(\"mainWindow\"); settings.setValue(\"size\", size()); settings.setValue(\"state\", saveState()); settings.endGroup();}void MainWindow::readSettings(){ QSettings settings(\"Software Inc.\", \"Icon Editor\"); settings.beginGroup(\"mainWindow\"); resize(settings.value(\"size\").toSize()); restoreState(settings.value(\"state\").toByteArray()); settings.endGroup();}Finally,QMainWindowprovides a context menu that lists all the dock windowsand toolbars. The user can close and restore dock windows and hide andrestore toolbars using this menu.Figure 6.15.AQMainWindowcontext menuMultiple Document InterfaceApplications that provide multiple documents within the main window’s cen-tral area are called multiple document interface applications, or MDI appli-cations. In Qt, an MDI application is created by using theQWorkspaceclass"},{"pageNumber":171,"pageContent":"Multiple Document Interface153as the central widget and by making each document window a child of theQWorkspace.It is conventional for MDI applications to provide aWindowmenu that includessome commands for managing the windows and the list of windows. The activewindow is identified with a checkmark. The user can make any window activeby clicking its entry in theWindowmenu.In this section, we will develop the MDI Editor application shown in Fig-ure 6.16 to demonstrate how to create an MDI application and how to imple-ment itsWindowmenu.Figure 6.16.The MDI Editor applicationThe application consists of two classes:MainWindowandEditor. The code ison the CD, and since most of it is the same or similar to the Spreadsheetapplication from Part I, we will only present the new code.Figure 6.17.The MDI Editor application’s menus"},{"pageNumber":172,"pageContent":"1546. Layout ManagementLet’s start with theMainWindowclass.MainWindow::MainWindow(){ workspace = new QWorkspace; setCentralWidget(workspace); connect(workspace, SIGNAL(windowActivated(QWidget *)), this, SLOT(updateMenus())); createActions(); createMenus(); createToolBars(); createStatusBar(); setWindowTitle(tr(\"MDI Editor\")); setWindowIcon(QPixmap(\":/images/icon.png\"));}In theMainWindowconstructor, we create aQWorkspacewidget and make it thecentral widget. We connect theQWorkspace’swindowActivated()signal to the slotwe will use to keep the window menu up to date.void MainWindow::newFile(){ Editor *editor = createEditor(); editor->newFile(); editor->show();}ThenewFile()slot corresponds to theFile|Newmenu option. It depends on thecreateEditor()private function to create a childEditorwidget.Editor *MainWindow::createEditor(){ Editor *editor = new Editor; connect(editor, SIGNAL(copyAvailable(bool)), cutAction, SLOT(setEnabled(bool))); connect(editor, SIGNAL(copyAvailable(bool)), copyAction, SLOT(setEnabled(bool))); workspace->addWindow(editor); windowMenu->addAction(editor->windowMenuAction()); windowActionGroup->addAction(editor->windowMenuAction()); return editor;}ThecreateEditor()function creates anEditorwidget and sets up twosignal–slot connections. These connections ensure thatEdit|CutandEdit|Copyare enabled or disabled depending on whether there is any selected text.Because we are using MDI, it is possible that there will be multipleEditorwidgets in use. This is a concern since we are only interested in respondingto thecopyAvailable(bool)signal from the activeEditorwindow, not from theothers. But these signals can only ever be emitted by the active window, so thisisn’t a problem in practice."},{"pageNumber":173,"pageContent":"Multiple Document Interface155Once we have set up theEditor, we add aQActionrepresenting the windowto theWindowmenu. The action is provided by theEditorclass, which wewill cover in a moment. We also add the action to aQActionGroupobject. TheQActionGroupensures that only oneWindowmenu item is checked at a time.void MainWindow::open(){ Editor *editor = createEditor(); if (editor->open()) { editor->show(); } else { editor->close(); }}Theopen()function corresponds toFile|Open. It creates anEditorfor the newdocument and callsopen()on theEditor. It makes more sense to implementthe file operations in theEditorclass than in theMainWindowclass, because eachEditorneeds to maintain its own independent state.If theopen()fails, we simply close the editor since the user will have alreadybeen notified of the error. We don’t need to explicitly delete theEditorobjectourselves; this is done automatically byEditorthrough theQt::WA_DeleteOn-Closewidget attribute, which is set in theEditorconstructor.void MainWindow::save(){ if (activeEditor()) activeEditor()->save();}Thesave()slot callsEditor::save()on the active editor, if there is one. Again,the code that performs the real work is located in theEditorclass.Editor *MainWindow::activeEditor(){ return qobject_cast<Editor *>(workspace->activeWindow());}TheactiveEditor()private function returns the active child window as anEditorpointer, or a null pointer if there isn’t one.void MainWindow::cut(){ if (activeEditor()) activeEditor()->cut();}Thecut()slot callsEditor::cut()on the active editor. We don’t show thecopy()andpaste()slots because they follow the same pattern.void MainWindow::updateMenus(){ bool hasEditor = (activeEditor() != 0);"},{"pageNumber":174,"pageContent":"1566. Layout Management bool hasSelection = activeEditor() && activeEditor()->textCursor().hasSelection(); saveAction->setEnabled(hasEditor); saveAsAction->setEnabled(hasEditor); pasteAction->setEnabled(hasEditor); cutAction->setEnabled(hasSelection); copyAction->setEnabled(hasSelection); closeAction->setEnabled(hasEditor); closeAllAction->setEnabled(hasEditor); tileAction->setEnabled(hasEditor); cascadeAction->setEnabled(hasEditor); nextAction->setEnabled(hasEditor); previousAction->setEnabled(hasEditor); separatorAction->setVisible(hasEditor); if (activeEditor()) activeEditor()->windowMenuAction()->setChecked(true);}TheupdateMenus()slot is called whenever a window is activated (and whenthe last window is closed) to update the menu system, due to the signal–slotconnection we put in theMainWindowconstructor.Most menu options only make sense if there is an active window, so wedisable them if there isn’t one. At the end, we callsetChecked()on theQActionrepresenting the active window. Thanks to theQActionGroup, we don’t need toexplicitly uncheck the previously active window.void MainWindow::createMenus(){••• windowMenu = menuBar()->addMenu(tr(\"&Window\")); windowMenu->addAction(closeAction); windowMenu->addAction(closeAllAction); windowMenu->addSeparator(); windowMenu->addAction(tileAction); windowMenu->addAction(cascadeAction); windowMenu->addSeparator(); windowMenu->addAction(nextAction); windowMenu->addAction(previousAction); windowMenu->addAction(separatorAction);•••}ThecreateMenus()private function fills theWindowmenu with actions. Theactions are all typical of such menus and are easily implemented usingQWorkspace’scloseActiveWindow(),closeAllWindows(),tile(), andcascade()slots.Every time the user opens a new window, it is added to theWindowmenu’s listof actions. (This is done in thecreateEditor()function that we saw on page154.) When the user closes an editor window, its action in theWindowmenu isdeleted (since the action is owned by the editor window), and so the action isautomatically removed from theWindowmenu."},{"pageNumber":175,"pageContent":"Multiple Document Interface157void MainWindow::closeEvent(QCloseEvent *event){ workspace->closeAllWindows(); if (activeEditor()) { event->ignore(); } else { event->accept(); }}ThecloseEvent()function is reimplemented to close all child windows, causingeach child to receive a close event. If one of the child widgets “ignores” itsclose event (because the user canceled an “unsaved changes” message box), weignore the close event for theMainWindow; otherwise, we accept it, resulting in Qtclosing the entire window. If we didn’t reimplementcloseEvent()inMainWindow,the user would not be given the opportunity to save unsaved changes.We have now finished our review ofMainWindow, so we can move on to theEditorimplementation. TheEditorclass represents one child window. It inheritsQTextEdit, which provides the text editing functionality. Just as any Qt widgetcan be used as a stand-alone window, any Qt widget can be used as a childwindow in an MDI workspace.Here’s the class definition:class Editor : public QTextEdit{ Q_OBJECTpublic: Editor(QWidget *parent = 0); void newFile(); bool open(); bool openFile(const QString &fileName); bool save(); bool saveAs(); QSize sizeHint() const; QAction *windowMenuAction() const { return action; }protected: void closeEvent(QCloseEvent *event);private slots: void documentWasModified();private: bool okToContinue(); bool saveFile(const QString &fileName); void setCurrentFile(const QString &fileName); bool readFile(const QString &fileName); bool writeFile(const QString &fileName); QString strippedName(const QString &fullFileName); QString curFile; bool isUntitled;"},{"pageNumber":176,"pageContent":"1586. Layout Management QString fileFilters; QAction *action;};Four of the private functions that were in the Spreadsheet application’sMain-Windowclass (p. 57) are also present in theEditorclass:okToContinue(),save-File(),setCurrentFile(), andstrippedName().Editor::Editor(QWidget *parent) : QTextEdit(parent){ action = new QAction(this); action->setCheckable(true); connect(action, SIGNAL(triggered()), this, SLOT(show())); connect(action, SIGNAL(triggered()), this, SLOT(setFocus())); isUntitled = true; fileFilters = tr(\"Text files (*.txt)\\n\" \"All files (*)\"); connect(document(), SIGNAL(contentsChanged()), this, SLOT(documentWasModified())); setWindowIcon(QPixmap(\":/images/document.png\")); setAttribute(Qt::WA_DeleteOnClose);}First, we create aQActionrepresenting the editor in the application’sWindowmenu and connect that action to theshow()andsetFocus()slots.Since we allow users to create any number of editor windows, we must makesome provision for naming them so that they can be distinguished before theyhave been saved for the first time. One common way of handling this is toallocate names that include a number (for example,document1.txt). We use theisUntitledvariable to distinguish between names supplied by the user andnames we have created programmatically.We connect the text document’scontentsChanged()signal to the privatedocu-mentWasModified()slot. This slot simply callssetWindowModified(true).Finally, we set theQt::WA_DeleteOnCloseattribute to prevent memory leakswhen the user closes anEditorwindow.After the constructor, we expect eithernewFile()oropen()to be called.void Editor::newFile(){ static int documentNumber = 1; curFile = tr(\"document%1.txt\").arg(documentNumber); setWindowTitle(curFile + \"[*]\"); action->setText(curFile); isUntitled = true; ++documentNumber;}"},{"pageNumber":177,"pageContent":"Multiple Document Interface159ThenewFile()function generates a name likedocument1.txtfor the new docu-ment. The code belongs innewFile(), rather than the constructor, because wedon’t want to consume numbers when we callopen()to open an existing doc-ument in a newly createdEditor. SincedocumentNumberis declared static, it isshared across allEditorinstances.The “[*]” marker in the window title is a place marker for where we want theasterisk to appear when the file has unsaved changes on platforms other thanMac OS X. We covered this place marker in Chapter 3 (p. 58).bool Editor::open(){ QString fileName = QFileDialog::getOpenFileName(this, tr(\"Open\"), \".\",  fileFilters); if (fileName.isEmpty()) return false; return openFile(fileName);}Theopen()function tries to open an existing file usingopenFile().bool Editor::save(){ if (isUntitled) { return saveAs(); } else { return saveFile(curFile); }}Thesave()function uses theisUntitledvariable to determine whether itshould callsaveFile()orsaveAs().void Editor::closeEvent(QCloseEvent *event){ if (okToContinue()) { event->accept(); } else { event->ignore(); }}ThecloseEvent()function is reimplemented to allow the user to save unsavedchanges. The logic is coded in theokToContinue()function, which pops up amessage box that asks, “Do you want to save your changes?” IfokToContinue()returnstrue, we accept the close event; otherwise, we “ignore” it and leave thewindow unaffected by it.void Editor::setCurrentFile(const QString &fileName){ curFile = fileName; isUntitled = false; action->setText(strippedName(curFile));"},{"pageNumber":178,"pageContent":"1606. Layout Management document()->setModified(false); setWindowTitle(strippedName(curFile) + \"[*]\"); setWindowModified(false);}ThesetCurrentFile()function is called fromopenFile()andsaveFile()to up-date thecurFileandisUntitledvariables, to set the window title and actiontext, and to set the document’s “modified” flag tofalse. Whenever the usermodifies the text in the editor, the underlyingQTextDocumentemits thecontents-Changed()signal and sets its internal “modified” flag totrue.QSize Editor::sizeHint() const{ return QSize(72 * fontMetrics().width(’x’), 25 * fontMetrics().lineSpacing());}ThesizeHint()function returns a size based on the width of the letter ‘x’ andthe height of a text line.QWorkspaceuses the size hint to give an initial size tothe window.Here’s the MDI Editor application’smain.cppfile:#include <QApplication>#include \"mainwindow.h\"int main(int argc, char *argv[]){ QApplication app(argc, argv); QStringList args = app.arguments(); MainWindow mainWin; if (args.count() > 1) { for (int i = 1; i < args.count(); ++i) mainWin.openFile(args[i]); } else { mainWin.newFile(); } mainWin.show(); return app.exec();}If the user specifies any files on the command line, we attempt to load them.Otherwise, we start with an empty document. Qt-specific command-line op-tions, such as-styleand-font, are automatically removed from the argumentlist by theQApplicationconstructor. So if we writemdieditor -style motif readme.txton the command line,QApplication::arguments()returns aQStringListcontain-ing two items (“mdieditor” and “readme.txt”), and the MDI Editor applicationstarts up with the documentreadme.txt."},{"pageNumber":179,"pageContent":"Multiple Document Interface161MDI is one way of handling multiple documents simultaneously. On Mac OS X,the preferred approach is to use multiple top-level windows. This approach iscovered in the “Multiple Documents” section of Chapter 3."},{"pageNumber":181,"pageContent":"7. Event ProcessinguReimplementing Event HandlersuInstalling Event FiltersuStaying Responsive During IntensiveProcessingEvents are generated by the window system or by Qt itself in response tovarious occurrences. When the user presses or releases a key or mouse button,a key or mouse event is generated; when a window is shown for the first time, apaint event is generated to tell the newly visible window that it needs to drawitself. Most events are generated in response to user actions, but some, liketimer events, are generated independently by the system.When we program with Qt, we seldom need to think about events, becauseQt widgets emit signals when something significant occurs. Events becomeuseful when we write our own custom widgets or when we want to modify thebehavior of existing Qt widgets.Events should not be confused with signals. As a rule, signals are useful whenusinga widget, whereas events are useful whenimplementinga widget. Forexample, when we are usingQPushButton, we are more interested in itsclicked()signal than in the low-level mouse or key events that caused the signal to beemitted. But if we are implementing a class likeQPushButton, we need to writecode to handle mouse and key events and emit theclicked()signal when nec-essary.Reimplementing Event HandlersIn Qt, an event is an object that inheritsQEvent. Qt handles more than a hun-dred types of event, each identified by an enum value. For example,QEvent::type()returnsQEvent::MouseButtonPressfor mouse press events.Many event types require more information than can be stored in a plainQEventobject; for example, mouse press events need to store which mousebutton triggered the event as well as where the mouse pointer was positionedwhen the event occurred. This additional information is stored in dedicatedQEventsubclasses, such asQMouseEvent.163"},{"pageNumber":182,"pageContent":"1647. Event ProcessingEvents are notified to objects through theirevent()function, inherited fromQObject. Theevent()implementation inQWidgetforwards the most commontypes of event to specific event handlers, such asmousePressEvent(),keyPress-Event(), andpaintEvent().We have already seen many event handlers when implementingMainWindow,IconEditor, andPlotterin earlier chapters. There are many other types ofevent listed in theQEventreference documentation, and it is also possible tocreate custom event types and to dispatch events ourselves. Here, we willreview two common event types that deserve more explanation: key events andtimer events.Key events are handled by reimplementingkeyPressEvent()andkeyRelease-Event(). ThePlotterwidget reimplementskeyPressEvent(). Normally, we onlyneed to reimplementkeyPressEvent()since the only keys for which release isimportant are the modifier keysCtrl,Shift, andAlt, and these can be checked forin akeyPressEvent()usingQKeyEvent::modifiers(). For example, if we were im-plementing aCodeEditorwidget, its stripped-downkeyPressEvent()that distin-guishes betweenHomeandCtrl+Homewould look like this:void CodeEditor::keyPressEvent(QKeyEvent *event){ switch (event->key()) { case Qt::Key_Home: if (event->modifiers() & Qt::ControlModifier) { goToBeginningOfDocument(); } else { goToBeginningOfLine(); } break; case Qt::Key_End:••• default: QWidget::keyPressEvent(event); }}TheTabandBacktab(Shift+Tab) keys are special cases. They are handled byQWidget::event()before it callskeyPressEvent(), with the semantic of passingthe focus to the next or previous widget in the focus chain. This behavior isusually what we want, but in aCodeEditorwidget, we might prefer to makeTabindent a line. Theevent()reimplementation would then look like this:bool CodeEditor::event(QEvent *event){ if (event->type() == QEvent::KeyPress) { QKeyEvent *keyEvent = static_cast<QKeyEvent *>(event); if (keyEvent->key() == Qt::Key_Tab) { insertAtCurrentPosition(’\\t’); return true; } }"},{"pageNumber":183,"pageContent":"Reimplementing Event Handlers165 return QWidget::event(event);}If the event is a key press, we cast theQEventobject to aQKeyEventand checkwhich key was pressed. If the key isTab, we do some processing and returntrueto tell Qt that we have handled the event. If we returnedfalse, Qt wouldpropagate the event to the parent widget.A higher-level approach for implementing key bindings is to use aQAction.For example, ifgoToBeginningOfLine()andgoToBeginningOfDocument()are publicslots in theCodeEditorwidget, and theCodeEditoris used as the central widgetin aMainWindowclass, we could add the key bindings with the following code:MainWindow::MainWindow(){ editor = new CodeEditor; setCentralWidget(editor); goToBeginningOfLineAction = new QAction(tr(\"Go to Beginning of Line\"), this); goToBeginningOfLineAction->setShortcut(tr(\"Home\")); connect(goToBeginningOfLineAction, SIGNAL(activated()), editor, SLOT(goToBeginningOfLine())); goToBeginningOfDocumentAction = new QAction(tr(\"Go to Beginning of Document\"), this); goToBeginningOfDocumentAction->setShortcut(tr(\"Ctrl+Home\")); connect(goToBeginningOfDocumentAction, SIGNAL(activated()), editor, SLOT(goToBeginningOfDocument()));•••}This makes it easy to add the commands to a menu or a toolbar, as we sawin Chapter 3. If the commands don’t appear in the user interface, theQActionobjects could be replaced with aQShortcutobject, the class used byQActioninternally to support key bindings.By default, key bindings set usingQActionorQShortcuton a widget are enabledwhenever the window that contains the widget is active. This can be changedusingQAction::setShortcutContext()orQShortcut::setContext().Another common type of event is the timer event. While most other eventtypes occur as a result of a user action, timer events allow applications to per-form processing at regular time intervals. Timer events can be used to imple-ment blinking cursors and other animations, or simply to refresh the display.To demonstrate timer events, we will implement aTickerwidget. This widgetshows a text banner that scrolls left by one pixel every 30 milliseconds. If thewidget is wider than the text, the text is repeated as often as necessary to fillthe entire width of the widget."},{"pageNumber":184,"pageContent":"1667. Event ProcessingFigure 7.1.TheTickerwidgetHere’s the header file:#ifndef TICKER_H#define TICKER_H#include <QWidget>class Ticker : public QWidget{ Q_OBJECT Q_PROPERTY(QString text READ text WRITE setText)public: Ticker(QWidget *parent = 0); void setText(const QString &newText); QString text() const { return myText; } QSize sizeHint() const;protected: void paintEvent(QPaintEvent *event); void timerEvent(QTimerEvent *event); void showEvent(QShowEvent *event); void hideEvent(QHideEvent *event);private: QString myText; int offset; int myTimerId;};#endifWe reimplement four event handlers inTicker, three of which we have not seenbefore:timerEvent(),showEvent(), andhideEvent().Now let’s review the implementation:#include <QtGui>#include \"ticker.h\"Ticker::Ticker(QWidget *parent) : QWidget(parent){ offset = 0; myTimerId = 0;}The constructor initializes theoffsetvariable to 0. Thexcoordinate at whichthe text is drawn is derived from theoffsetvalue. Timer IDs are alwaysnon-zero, so we use 0 to indicate that no timer has been started."},{"pageNumber":185,"pageContent":"Reimplementing Event Handlers167void Ticker::setText(const QString &newText){ myText = newText; update(); updateGeometry();}ThesetText()function sets the text to display. It callsupdate()to request arepaint andupdateGeometry()to notify any layout manager responsible for theTickerwidget about a size hint change.QSize Ticker::sizeHint() const{ return fontMetrics().size(0, text());}ThesizeHint()function returns the space needed by the text as the widget’sideal size.QWidget::fontMetrics()returns aQFontMetricsobject that can bequeried to obtain information relating to the widget’s font. In this case, we askfor the size required by the given text. (The first argument toQFontMetrics::size()is a flag that isn’t needed for simple strings, so we just pass 0.)void Ticker::paintEvent(QPaintEvent * /* event */){ QPainter painter(this); int textWidth = fontMetrics().width(text()); if (textWidth < 1) return; int x = -offset; while (x < width()) { painter.drawText(x, 0, textWidth, height(),  Qt::AlignLeft | Qt::AlignVCenter, text()); x += textWidth; }}ThepaintEvent()function draws the text usingQPainter::drawText(). It usesfontMetrics()to ascertain how much horizontal space the text requires, andthen draws the text as many times as necessary to fill the entire width of thewidget, takingoffsetinto account.void Ticker::showEvent(QShowEvent * /* event */){ myTimerId = startTimer(30);}TheshowEvent()function starts a timer. The call toQObject::startTimer()returns an ID number, which we can use later to identify the timer.QObjectsupports multiple independent timers, each with its own time interval. Afterthe call tostartTimer(), Qt will generate a timer event approximately every30 milliseconds; the accuracy depends on the underlying operating system."},{"pageNumber":186,"pageContent":"1687. Event ProcessingWe could have calledstartTimer()in theTickerconstructor, but we savesome resources by having Qt generate timer events only when the widget isactually visible.void Ticker::timerEvent(QTimerEvent *event){ if (event->timerId() == myTimerId) { ++offset; if (offset >= fontMetrics().width(text())) offset = 0; scroll(-1, 0); } else { QWidget::timerEvent(event); }}ThetimerEvent()function is called at intervals by the system. It incrementsoffsetby 1 to simulate movement, wrapping at the width of the text. Then itscrolls the contents of the widget one pixel to the left usingQWidget::scroll().It would have been sufficient to callupdate()instead ofscroll(), butscroll()is more efficient because it simply moves the existing pixels on screen and onlygenerates a paint event for the widget’s newly revealed area (a 1-pixel-widestrip in this case).If the timer event isn’t for the timer we are interested in, we pass it on to ourbase class.void Ticker::hideEvent(QHideEvent * /* event */){ killTimer(myTimerId);}ThehideEvent()function callsQObject::killTimer()to stop the timer.Timer events are low level, and if we need multiple timers, it can becomecumbersome to keep track of all the timer IDs. In such situations, it is usuallyeasier to create aQTimerobject for each timer.QTimeremits thetimeout()signal at each time interval.QTimeralso provides a convenient interface forsingle-shot timers (timers that time out just once).Installing Event FiltersOne really powerful feature of Qt’s event model is that aQObjectinstance canbe set to monitor the events of anotherQObjectinstance before the latter objecteven sees them.Let’s suppose that we have aCustomerInfoDialogwidget composed of severalQLineEdits and that we want to use theSpacekey to move the focus to the nextQLineEdit. This non-standard behavior might be appropriate for an in-houseapplication whose users are trained in its use. A straightforward solution isto subclassQLineEditand reimplementkeyPressEvent()to callfocusNextChild(),like this:"},{"pageNumber":187,"pageContent":"Installing Event Filters169void MyLineEdit::keyPressEvent(QKeyEvent *event){ if (event->key() == Qt::Key_Space) { focusNextChild(); } else { QLineEdit::keyPressEvent(event); }}This approach has one main disadvantage: If we use several different kindsof widgets in the form (for example,QComboBoxes andQSpinBoxes), we must alsosubclass them to make them exhibit the same behavior. A better solution isto makeCustomerInfoDialogmonitor its child widgets’ key press events andimplement the required behavior in the monitoring code. This can be achievedusing event filters. Setting up an event filter involves two steps:1. Register the monitoring object with the target object by callinginstall-EventFilter()on the target.2. Handle the target object’s events in the monitor’seventFilter()function.A good place to register the monitoring object is in theCustomerInfoDialogcon-structor:CustomerInfoDialog::CustomerInfoDialog(QWidget *parent) : QDialog(parent){••• firstNameEdit->installEventFilter(this); lastNameEdit->installEventFilter(this); cityEdit->installEventFilter(this); phoneNumberEdit->installEventFilter(this);}Once the event filter is registered, the events that are sent to thefirstName-Edit,lastNameEdit,cityEdit, andphoneNumberEditwidgets are first sent to theCustomerInfoDialog’seventFilter()function before they are sent on to their in-tended destination.Here’s theeventFilter()function that receives the events:bool CustomerInfoDialog::eventFilter(QObject *target, QEvent *event){ if (target == firstNameEdit || target == lastNameEdit || target == cityEdit || target == phoneNumberEdit) { if (event->type() == QEvent::KeyPress) { QKeyEvent *keyEvent = static_cast<QKeyEvent *>(event); if (keyEvent->key() == Qt::Key_Space) { focusNextChild(); return true; } } } return QDialog::eventFilter(target, event);}"},{"pageNumber":188,"pageContent":"1707. Event ProcessingFirst, we check to see if the target widget is one of theQLineEdits. If the eventwas a key press, we cast it toQKeyEventand check which key was pressed. Ifthe pressed key wasSpace, we callfocusNextChild()to pass focus on to the nextwidget in the focus chain, and we returntrueto tell Qt that we have handledthe event. If we returnedfalse, Qt would send the event to its intended target,resulting in a spurious space being inserted into theQLineEdit.If the target widget isn’t aQLineEdit, or if the event isn’t aSpacekey press,we pass control to the base class’s implementation ofeventFilter(). The targetwidget could also be some widget that the base class,QDialog, is monitoring. (InQt 4.1, this is not the case forQDialog. However, other Qt widget classes, suchasQScrollArea, do monitor some of their child widgets for various reasons.)Qt offers five levels at which events can be processed and filtered:1. We can reimplement a specific event handler.Reimplementing event handlers such asmousePressEvent(),keyPress-Event(), andpaintEvent()is by far the most common way to process events.We have already seen many examples of this.2. We can reimplement QObject::event().By reimplementing theevent()function, we can process events beforethey reach the specific event handlers. This approach is mostly neededto override the default meaning of theTabkey, as shown earlier (p. 164).This is also used to handle rare types of event for which no specific eventhandler exists (for example,QEvent::HoverEnter). When we reimplementevent(), we must call the base class’sevent()function for handling thecases we don’t explicitly handle.3. We can install an event filter on a single QObject.Once an object has been registered usinginstallEventFilter(), all theevents for the target object are first sent to the monitoring object’sevent-Filter()function. If multiple event filters are installed on the same object,the filters are activated in turn, from the most recently installed back tothe first installed.4. We can install an event filter on the QApplication object.Once an event filter has been registered forqApp(the uniqueQApplicationobject), every event for every object in the application is sent to theevent-Filter()function before it is sent to any other event filter. This approachis mostly useful for debugging. It can also be used to handle mouse eventssent to disabled widgets, whichQApplicationnormally discards.5. We can subclass QApplication and reimplement notify().Qt callsQApplication::notify()to send out an event. Reimplementing thisfunction is the only way to get all the events, before any event filters getthe opportunity to look at them. Event filters are generally more useful,"},{"pageNumber":189,"pageContent":"Installing Event Filters171because there can be any number of concurrent event filters, but only onenotify()function.Many event types, including mouse and key events, can be propagated. Ifthe event has not been handled on the way to its target object or by the targetobject itself, the whole event processing process is repeated, but this time withthe target object’s parent as the new target. This continues, going from parentto parent, until either the event is handled or the top-level object is reached.Window Title5QDialogQGroupBoxQCheckBoxQCheckBoxQCheckBoxQCheckBoxÊÊËËÌÌFigure 7.2.Event propagation in a dialogFigure 7.2 shows how a key press event is propagated from child to parent ina dialog. When the user presses a key, the event is first sent to the widget thathas focus, in this case the bottom-rightQCheckBox. If theQCheckBoxdoesn’t han-dle the event, Qt sends it to theQGroupBox, and finally to theQDialogobject.Staying Responsive During Intensive ProcessingWhen we callQApplication::exec(), we start Qt’s event loop. Qt issues a fewevents on startup to show and paint the widgets. After that, the event loop isrunning, constantly checking to see if any events have occurred and dispatch-ing these events toQObjects in the application.While one event is being processed, additional events may be generated and ap-pended to Qt’s event queue. If we spend too much time processing a particularevent, the user interface will become unresponsive. For example, any eventsgenerated by the window system while the application is saving a file to diskwill not be processed until the file is saved. During the save, the applicationwill not respond to requests from the window system to repaint itself.One solution is to use multiple threads: one thread for the application’s user in-terface and another thread to perform file saving (or any other time-consumingoperation). This way, the application’s user interface will stay responsive whilethe file is being saved. We will see how to achieve this in Chapter 18.A simpler solution is to make frequent calls toQApplication::processEvents()inthe file saving code. This function tells Qt to process any pending events, and"},{"pageNumber":190,"pageContent":"1727. Event Processingthen returns control to the caller. In fact,QApplication::exec()is little morethan awhileloop around aprocessEvents()function call.Here’s an example of how we can keep the user interface responsive usingprocessEvents(), based on the file saving code forSpreadsheet(p. 80):bool Spreadsheet::writeFile(const QString &fileName){ QFile file(fileName);••• for (int row = 0; row < RowCount; ++row) { for (int column = 0; column < ColumnCount; ++column) { QString str = formula(row, column); if (!str.isEmpty()) out << quint16(row) << quint16(column) << str; } qApp->processEvents(); } return true;}One danger with this approach is that the user might close the main windowwhile the application is still saving, or even clickFile|Savea second time, result-ing in undefined behavior. The easiest solution to this problem is to replaceqApp->processEvents();withqApp->processEvents(QEventLoop::ExcludeUserInputEvents);telling Qt to ignore mouse and key events.Often, we want to show aQProgressDialogwhile a long-running operationis taking place.QProgressDialoghas a progress bar that keeps the user in-formed about the progress being made by the application.QProgressDialogalsoprovides aCancelbutton that allows the user to abort the operation. Here’sthe code for saving a Spreadsheet file using this approach:bool Spreadsheet::writeFile(const QString &fileName){ QFile file(fileName);••• QProgressDialog progress(this); progress.setLabelText(tr(\"Saving %1\").arg(fileName)); progress.setRange(0, RowCount); progress.setModal(true); for (int row = 0; row < RowCount; ++row) { progress.setValue(row); qApp->processEvents(); if (progress.wasCanceled()) { file.remove(); return false; }"},{"pageNumber":191,"pageContent":"Staying Responsive During Intensive Processing173 for (int column = 0; column < ColumnCount; ++column) { QString str = formula(row, column); if (!str.isEmpty()) out << quint16(row) << quint16(column) << str; } } return true;}We create aQProgressDialogwithNumRowsas the total number of steps. Then,for each row, we callsetValue()to update the progress bar.QProgressDialogautomatically computes a percentage by dividing the current progress valueby the total number of steps. We callQApplication::processEvents()to processany repaint events or any user clicks or key presses (for example, to allow theuser to clickCancel). If the user clicksCancel, we abort the save and removethe file.We don’t callshow()on theQProgressDialogbecause progress dialogs do that forthemselves. If the operation turns out to be short, presumably because the fileto save is small or because the machine is fast,QProgressDialogwill detect thisand will not show itself at all.In addition to multithreading and usingQProgressDialog, there is a completelydifferent way of dealing with long-running operations: Instead of performingthe processing when the user requests, we can defer the processing until theapplication is idle. This can work if the processing can be safely interruptedand resumed, since we cannot predict how long the application will be idle.In Qt, this approach can be implemented by using a 0-millisecond timer. Thesetimers time out whenever there are no pending events. Here’s an exampletimerEvent()implementation that shows the idle processing approach:void Spreadsheet::timerEvent(QTimerEvent *event){ if (event->timerId() == myTimerId) { while (step < MaxStep && !qApp->hasPendingEvents()) { performStep(step); ++step; } } else { QTableWidget::timerEvent(event); }}IfhasPendingEvents()returnstrue, we stop processing and give control back toQt. The processing will resume when Qt has handled all its pending events."},{"pageNumber":193,"pageContent":"8. 2D and 3D GraphicsuPainting with QPainteruPainter TransformationsuHigh-Quality Rendering withQImageuPrintinguGraphics with OpenGLQt’s 2D graphics engine is based on theQPainterclass.QPaintercan drawgeometric shapes (points, lines, rectangles, ellipses, arcs, chords, pie segments,polygons, and Bézier curves), as well as pixmaps, images, and text. Further-more,QPaintersupports advanced features such as antialiasing (for text andshape edges), alpha blending, gradient filling, and vector paths.QPainteralsosupports transformations, which makes it possible to draw resolution-indepen-dent 2D graphics.QPaintercan be used to draw on a “paint device”, such as aQWidget, aQPixmap, oraQImage. It is useful when we write custom widgets or custom item classes withtheir own look and feel.QPaintercan also be used in conjunction withQPrinterfor printing and for generating PDFs. This means that we can often use thesame code to display data on screen and to produce printed reports.An alternative toQPainteris to use OpenGL. OpenGL is a standard library fordrawing 2D and 3D graphics. TheQtOpenGLmodule makes it very easy tointegrate OpenGL code into Qt applications.Painting with QPainterTo start painting to a paint device (typically a widget), we simply create aQPainterand pass a pointer to the device. For example:void MyWidget::paintEvent(QPaintEvent *event){ QPainter painter(this); ...}We can draw various shapes usingQPainter’sdraw...()functions. Figure 8.1lists the most important ones. The way the drawing is performed is influencedbyQPainter’s settings. Some of these are adopted from the device, others areinitialized to default values. The three main painter settings are the pen, thebrush, and the font:175"},{"pageNumber":194,"pageContent":"1768. 2D and 3D Graphics• Thepenis used for drawing lines and shape outlines. It consists of a color,a width, a line style, a cap style, and a join style.• Thebrushis the pattern used for filling geometric shapes. It normallyconsists of a color and a style, but can also be a texture (a pixmap that isrepeated infinitely) or a gradient.• Thefontis used for drawing text. A font has many attributes, including afamily and a point size.These settings can be modified at any time by callingsetPen(),setBrush(), andsetFont()with aQPen,QBrush, orQFontobject.drawPoint() drawLine() drawPolyline()drawPoints() drawLines() drawPolygon()drawRect() drawRoundRect() drawEllipse()drawArc() drawChord() drawPie()AgdrawText() drawPixmap() drawPath()(x1,(x1, y1)(x2,(x2, y2)p2p2pp3p1p1pp4p2p2pp3p1p1pp4p2p2pp3p1p1pp4p2p2pp3p1p1pp4(x, y)(x, y)(x, y)(x, y)(x, y)(x, y)hhwwhhwwhhww++(x, y)(x, y)hhww++ββαα(x, y)(x, y)hhww++ββαα(x, y)(x, y)hhww++ββαα(x, y)(x, y)(x, y)(x, y)(x, y)(x, y)Figure 8.1.QPainter’s most frequently useddraw...()functions"},{"pageNumber":195,"pageContent":"Painting with QPainter177FlatCap SquareCap RoundCapMiterJoin BevelJoin RoundJoinFigure 8.2.Cap and join stylesline width1234NoPenSolidLineDashLineDotLineDashDotLineDashDotDotLineFigure 8.3.Pen stylesSolidPatternDense1PatternDense2PatternDense3PatternDense4PatternDense5Pattern Dense6PatternDense7PatternHorPatternVerPatternCrossPatternBDiagPattern FDiagPattern DiagCrossPat.NoBrushFigure 8.4.Predefined brush styles"},{"pageNumber":196,"pageContent":"1788. 2D and 3D Graphics(a) An ellipse(b) A pie segment(c) A Bézier curveFigure 8.5.Geometric shape examplesLet’s see a few examples in practice. Here’s the code to draw the ellipse shownin Figure 8.5 (a):QPainter painter(this);painter.setRenderHint(QPainter::Antialiasing, true);painter.setPen(QPen(Qt::black, 12, Qt::DashDotLine, Qt::RoundCap));painter.setBrush(QBrush(Qt::green, Qt::SolidPattern));painter.drawEllipse(80, 80, 400, 240);ThesetRenderHint()call enables antialiasing, tellingQPainterto use differentcolor intensities on the edges to reduce the visual distortion that normallyoccurs when the edges of a shape are converted into pixels. The result issmoother edges on platforms and devices that support this feature.Here’s the code to draw the pie segment shown in Figure 8.5 (b):QPainter painter(this);painter.setRenderHint(QPainter::Antialiasing, true);painter.setPen(QPen(Qt::black, 15, Qt::SolidLine, Qt::RoundCap, Qt::MiterJoin));painter.setBrush(QBrush(Qt::blue, Qt::DiagCrossPattern));painter.drawPie(80, 80, 400, 240, 60 * 16, 270 * 16);The last two arguments todrawPie()are expressed in sixteenths of a degree.Here’s the code to draw the cubic Bézier curve shown in Figure 8.5 (c):QPainter painter(this);painter.setRenderHint(QPainter::Antialiasing, true);QPainterPath path;path.moveTo(80, 320);path.cubicTo(200, 80, 320, 80, 480, 320);painter.setPen(QPen(Qt::black, 8));painter.drawPath(path);TheQPainterPathclass can specify arbitrary vector shapes by connecting basicgraphical elements together: straight lines, ellipses, polygons, arcs, quadraticand cubic Bézier curves, and other painter paths. Painter paths are theultimate drawing primitive in the sense that any shape or combination ofshapes can be expressed as a path."},{"pageNumber":197,"pageContent":"Painting with QPainter179A path specifies an outline, and the area described by the outline can be filledusing a brush. In the example of Figure 8.5 (c), we didn’t set a brush, so onlythe outline is drawn.The three examples above use built-in brush patterns (Qt::SolidPattern,Qt::DiagCrossPattern, andQt::NoBrush). In modern applications, gradient fills area popular alternative to monochrome fill patterns. Gradients rely on colorinterpolation to obtain smooth transitions between two or more colors. Theyare frequently used to produce 3D effects; for example, the Plastique style usesgradients to renderQPushButtons.Qt supports three types of gradients: linear, conical, and radial. The OvenTimer example in the next section combines all three types of gradients in asingle widget to make it look like the real thing.(x1,(x1, y1)2,(x2, y2)c,(xc, yc)(xf,(xf, yf)rrc,(xc, yc)ααQLinearGradient QRadialGradient QConicalGradientFigure 8.6.QPainter’s gradient brushes•Linear gradientsare defined by two control points and by a series of “colorstops” on the line that connects these two points. For example, the lineargradient of Figure 8.6 is created using the following code:QLinearGradient gradient(50, 100, 300, 350);gradient.setColorAt(0.0, Qt::white);gradient.setColorAt(0.2, Qt::green);gradient.setColorAt(1.0, Qt::black);We specify three colors at three different positions between the two controlpoints. Positions are specified as floating-point values between 0 and 1,"},{"pageNumber":198,"pageContent":"1808. 2D and 3D Graphicswhere 0 corresponds to the first control point and 1 to the second controlpoint. Colors between the specified stops are interpolated.•Radial gradientsare defined by a center point (xc,yc), a radiusr, and a focalpoint (xf,yf), in addition to the color stops. The center point and the radiusspecify a circle. The colors spread outward from the focal point, which canbe the center point or any other point inside the circle.•Conical gradientsare defined by a center point (xc,yc) and an angleα.The colors spread around the center point like the sweep of a watch’sseconds hand.So far we have mentionedQPainter’s pen, brush, and font settings. In additionto these,QPainterhas other settings that influence the way shapes and textare drawn:• Thebackground brushis used to fill the background of geometric shapes(underneath the brush pattern), text, or bitmaps when thebackgroundmodeisQt::OpaqueMode(the default isQt::TransparentMode).• Thebrush originis the starting point for brush patterns, normally thetop-left corner of the widget.• Theclip regionis the area of the device that can be painted. Paintingoutside the clip region has no effect.• Theviewport,window, andworld matrixdetermine how logicalQPaintercoordinates map to physical paint device coordinates. By default, theseare set up so that the logical and physical coordinate systems coincide.Coordinate systems are covered in the next section.• Thecomposition modespecifies how the newly drawn pixels shouldinteract with the pixels already present on the paint device. The default is“source over”, where drawn pixels are drawn on top of existing pixels. Thisis supported only on certain devices and is covered later in this chapter.At any time, we can save the current state of a painter on an internal stack bycallingsave()and restore it later on by callingrestore(). This can be useful ifwe want to temporarily change some painter settings and then reset them totheir previous values, as we will see in the next section.Painter TransformationsWithQPainter’s default coordinate system, the point (0, 0) is located at thetop-left corner of the paint device;xcoordinates increase rightward andycoordinates increase downward. Each pixel occupies an area of size 1 × 1 in thedefault coordinate system.One important thing to understand is that the center of a pixel lies on“half-pixel” coordinates. For example, the top-left pixel covers the area be-tween points (0, 0) and (1, 1), and its center is located at (0.5, 0.5). If we askQPainterto draw a pixel at, say, (100, 100), it will approximate the result by"},{"pageNumber":199,"pageContent":"Painter Transformations181shifting the coordinate by +0.5 in both directions, resulting in the pixel cen-tered at (100.5, 100.5) being drawn.This distinction may seem rather academic at first, but it has importantconsequences in practice. First, the shifting by +0.5 only occurs if antialiasingis disabled (the default); if antialiasing is enabled and we try to draw a pixelat (100, 100) in black,QPainterwill actually color the four pixels (99.5, 99.5),(99.5, 100.5), (100.5, 99.5), and (100.5, 100.5) light gray, to give the impressionof a pixel lying exactly at the meeting point of the four pixels. If this effect isundesirable, we can avoid it by specifying half-pixel coordinates, for example,(100.5, 100.5).When drawing shapes such as lines, rectangles, and ellipses, similar rules ap-ply. Figure 8.7 shows how the result of adrawRect(2, 2, 6, 5)call varies accord-ing to the pen’s width, when antialiasing is off. In particular, it is important tonotice that a 6 × 5 rectangle drawn with a pen width of 1 effectively covers anarea of size 7 × 6. This is different from older toolkits, including earlier versionsof Qt, but it is essential for making truly scalable, resolution-independent vec-tor graphics possible.(0,(0, 0)No penPen width 1Pen width 2Pen width 3Figure 8.7.Drawing a 6 × 5 rectangle with no antialiasingNow that we understand the default coordinate system, we can take a closerlook at how it can be changed usingQPainter’s viewport, window, and worldmatrix. (In this context, the term “window” does not refer to a window inthe sense of a top-level widget, and the “viewport” has nothing to do withQScrollArea’s viewport.)The viewport and the window are tightly bound. The viewport is an arbitraryrectangle specified in physical coordinates. The window specifies the same rect-angle, but in logical coordinates. When we do the painting, we specify pointsin logical coordinates, and those coordinates are converted into physical coor-dinates in a linear algebraic manner, based on the current window–viewportsettings.By default, the viewport and the window are set to the device’s rectangle. Forexample, if the device is a 320 × 200 widget, both the viewport and the windoware the same 320 × 200 rectangle with its top-left corner at position (0, 0). Inthis case, the logical and physical coordinate systems are the same."},{"pageNumber":200,"pageContent":"1828. 2D and 3D GraphicsThe window–viewport mechanism is useful to make the drawing code inde-pendent of the size or resolution of the paint device. For example, if we wantthe logical coordinates to extend from (+--50,+--50) to (+50, +50), with (0, 0) in themiddle, we can set the window as follows:painter.setWindow(-50, -50, 100, 100);The (+--50,+--50) pair specifies the origin, and the (100, 100) pair specifies thewidth and height. This means that the logical coordinates (+--50,+--50) now cor-respond to the physical coordinates (0, 0), and the logical coordinates (+50, +50)correspond to the physical coordinates (320, 200). In this example, we didn’tchange the viewport.50,(+--50,+--50)30,(+--30,+--20)(+10,(+10, +20)(+50,(+50, +50)ç(0,(0, 0)(64,(64, 60)(192,(192, 140)(320,(320, 200)windowviewportFigure 8.8.Converting logical coordinates into physical coordinatesNow comes the world matrix. The world matrix is a transformation matrixthat is applied in addition to the window–viewport conversion. It allows us totranslate, scale, rotate, or shear the items we are drawing. For example, if wewanted to draw text at a 45° angle, we would use this code:QMatrix matrix;matrix.rotate(45.0);painter.setMatrix(matrix);painter.drawText(rect, Qt::AlignCenter, tr(\"Revenue\"));The logical coordinates we pass todrawText()are transformed by the worldmatrix, then mapped to physical coordinates using the window–viewportsettings.If we specify multiple transformations, they are applied in the order inwhich they are given. For example, if we want to use the point (10, 20) as therotation’s pivot point, we can do so by translating the window, performing therotation, and then translating the window back to its original position:QMatrix matrix;matrix.translate(-10.0, -20.0);matrix.rotate(45.0);matrix.translate(+10.0, +20.0);painter.setMatrix(matrix);painter.drawText(rect, Qt::AlignCenter, tr(\"Revenue\"));"},{"pageNumber":201,"pageContent":"Painter Transformations183A simpler way to specify transformations is to useQPainter’stranslate(),scale(),rotate(), andshear()convenience functions:painter.translate(-10.0, -20.0);painter.rotate(45.0);painter.translate(+10.0, +20.0);painter.drawText(rect, Qt::AlignCenter, tr(\"Revenue\"));But if we want to use the same transformations repeatedly, it’s more efficientto store them in aQMatrixobject and set the world matrix on the painterwhenever the transformations are needed.Figure 8.9.TheOvenTimerwidgetTo illustrate painter transformations, we will review the code of theOvenTimerwidget shown in Figure 8.9. TheOvenTimerwidget is modeled after the kitchentimers that were used before it was common to have ovens with clocks built-in.The user can click a notch to set the duration. The wheel automaticallyturns counterclockwise until 0 is reached, at which pointOvenTimeremits thetimeout()signal.class OvenTimer : public QWidget{ Q_OBJECTpublic: OvenTimer(QWidget *parent = 0); void setDuration(int secs); int duration() const; void draw(QPainter *painter);signals: void timeout();protected: void paintEvent(QPaintEvent *event); void mousePressEvent(QMouseEvent *event);private: QDateTime finishTime; QTimer *updateTimer; QTimer *finishTimer;};"},{"pageNumber":202,"pageContent":"1848. 2D and 3D GraphicsTheOvenTimerclass inheritsQWidgetand reimplements two virtual functions:paintEvent()andmousePressEvent().const double DegreesPerMinute = 7.0;const double DegreesPerSecond = DegreesPerMinute / 60;const int MaxMinutes = 45;const int MaxSeconds = MaxMinutes * 60;const int UpdateInterval = 1;We start by defining a few constants that control the oven timer’s lookand feel.OvenTimer::OvenTimer(QWidget *parent) : QWidget(parent){ finishTime = QDateTime::currentDateTime(); updateTimer = new QTimer(this); connect(updateTimer, SIGNAL(timeout()), this, SLOT(update())); finishTimer = new QTimer(this); finishTimer->setSingleShot(true); connect(finishTimer, SIGNAL(timeout()), this, SIGNAL(timeout())); connect(finishTimer, SIGNAL(timeout()), updateTimer, SLOT(stop()));}In the constructor, we create twoQTimerobjects:updateTimeris used to refreshthe appearance of the widget every second, andfinishTimeremits the widget’stimeout()signal when the oven timer reaches 0. ThefinishTimeronly needs totimeout once, so we callsetSingleShot(true); by default, timers fire repeatedlyuntil they are stopped or destroyed. The lastconnect()call is an optimizationto stop updating the widget every second when the timer is inactive.void OvenTimer::setDuration(int secs){ if (secs > MaxSeconds) { secs = MaxSeconds; } else if (secs <= 0) { secs = 0; } finishTime = QDateTime::currentDateTime().addSecs(secs); if (secs > 0) { updateTimer->start(UpdateInterval * 1000); finishTimer->start(secs * 1000); } else { updateTimer->stop(); finishTimer->stop(); } update();}ThesetDuration()function sets the duration of the oven timer to the givennumber of seconds. We compute the finish time by adding the duration to the"},{"pageNumber":203,"pageContent":"Painter Transformations185current time (obtained fromQDateTime::currentDateTime()) and store it in thefinishTimeprivate variable. At the end, we callupdate()to redraw the widgetwith the new duration.ThefinishTimevariable is of typeQDateTime. Since the variable holds both adate and a time, we avoid a wrap-around bug when the current time is beforemidnight and the finish time is after midnight.int OvenTimer::duration() const{ int secs = QDateTime::currentDateTime().secsTo(finishTime); if (secs < 0) secs = 0; return secs;}Theduration()function returns the number of seconds left before the timer isdue to finish. If the timer is inactive, we return 0.void OvenTimer::mousePressEvent(QMouseEvent *event){ QPointF point = event->pos() - rect().center(); double theta = atan2(-point.x(), -point.y()) * 180 / 3.14159265359; setDuration(duration() + int(theta / DegreesPerSecond)); update();}If the user clicks the widget, we find the closest notch using a subtle buteffective mathematical formula, and we use the result to set the new duration.Then we schedule a repaint. The notch that the user clicked will now be at thetop and will move counterclockwise as time passes until 0 is reached.void OvenTimer::paintEvent(QPaintEvent * /* event */){ QPainter painter(this); painter.setRenderHint(QPainter::Antialiasing, true); int side = qMin(width(), height()); painter.setViewport((width() - side) / 2, (height() - side) / 2, side, side); painter.setWindow(-50, -50, 100, 100); draw(&painter);}InpaintEvent(), we set the viewport to be the largest square area that fits in-side the widget, and we set the window to be the rectangle (+--50,+--50, 100, 100),that is, the 100 × 100 rectangle extending from (+--50,+--50) to (+50, +50). TheqMin()template function returns the lowest of its two arguments. Then we callthedraw()function to actually perform the drawing."},{"pageNumber":204,"pageContent":"1868. 2D and 3D GraphicsFigure 8.10.TheOvenTimerwidget at three different sizesIf we had not set the viewport to be a square, the oven timer would be anellipse when the widget is resized to a non-square rectangle. To avoid suchdeformations, we must set the viewport and the window to rectangles with thesame aspect ratio.Now let’s look at the drawing code:void OvenTimer::draw(QPainter *painter){ static const int triangle[3][2] = { { -2, -49 }, { +2, -49 }, { 0, -47 } }; QPen thickPen(palette().foreground(), 1.5); QPen thinPen(palette().foreground(), 0.5); QColor niceBlue(150, 150, 200); painter->setPen(thinPen); painter->setBrush(palette().foreground()); painter->drawPolygon(QPolygon(3, &triangle[0][0]));We start by drawing the tiny triangle that marks the 0 position at the top ofthe widget. The triangle is specified by three hard-coded coordinates, and weusedrawPolygon()to render it.What is so convenient about the window–viewport mechanism is that we canhard-code the coordinates we use in the draw commands and still get goodresizing behavior. QConicalGradient coneGradient(0, 0, -90.0); coneGradient.setColorAt(0.0, Qt::darkGray); coneGradient.setColorAt(0.2, niceBlue); coneGradient.setColorAt(0.5, Qt::white); coneGradient.setColorAt(1.0, Qt::darkGray); painter->setBrush(coneGradient); painter->drawEllipse(-46, -46, 92, 92);"},{"pageNumber":205,"pageContent":"Painter Transformations187We draw the outer circle and fill it using a conical gradient. The gradient’scenter point is located at (0, 0), and the angle is+--90°. QRadialGradient haloGradient(0, 0, 20, 0, 0); haloGradient.setColorAt(0.0, Qt::lightGray); haloGradient.setColorAt(0.8, Qt::darkGray); haloGradient.setColorAt(0.9, Qt::white); haloGradient.setColorAt(1.0, Qt::black); painter->setPen(Qt::NoPen); painter->setBrush(haloGradient); painter->drawEllipse(-20, -20, 40, 40);We fill the inner circle using a radial gradient. The center point and the focalpoint of the gradient are located at (0, 0). The radius of the gradient is 20. QLinearGradient knobGradient(-7, -25, 7, -25); knobGradient.setColorAt(0.0, Qt::black); knobGradient.setColorAt(0.2, niceBlue); knobGradient.setColorAt(0.3, Qt::lightGray); knobGradient.setColorAt(0.8, Qt::white); knobGradient.setColorAt(1.0, Qt::black); painter->rotate(duration() * DegreesPerSecond); painter->setBrush(knobGradient); painter->setPen(thinPen); painter->drawRoundRect(-7, -25, 14, 50, 150, 50); for (int i = 0; i <= MaxMinutes; ++i) { if (i % 5 == 0) { painter->setPen(thickPen); painter->drawLine(0, -41, 0, -44); painter->drawText(-15, -41, 30, 25,  Qt::AlignHCenter | Qt::AlignTop,  QString::number(i)); } else { painter->setPen(thinPen); painter->drawLine(0, -42, 0, -44); } painter->rotate(-DegreesPerMinute); }}We callrotate()to rotate the painter’s coordinate system. In the old coordinatesystem, the 0-minute mark was on top; now, the 0-minute mark is moved tothe place that is appropriate for the time left. We draw the rectangular knobhandle after the rotation, since its orientation depends on the rotation angle.In theforloop, we draw the tick marks along the outer circle’s edge and thenumbers for each multiple of 5 minutes. The text is drawn in an invisiblerectangle underneath the tick mark. At the end of each iteration, we rotatethe painter clockwise by 7°, which corresponds to one minute. The next timewe draw a tick mark, it will be at a different position around the circle, even"},{"pageNumber":206,"pageContent":"1888. 2D and 3D Graphicsthough the coordinates we pass to thedrawLine()anddrawText()calls arealways the same.The code in theforloop suffers from a minor flaw, which would quickly becomeapparent if we performed more iterations. Each time we callrotate(), we ef -fectively multiply the current world matrix with a rotation matrix, producinga new world matrix. The rounding errors associated with floating-point arith-metic add up, resulting in an increasingly inaccurate world matrix. Here’s oneway to rewrite the code to avoid this issue, usingsave()andrestore()to saveand reload the original transformation matrix for each iteration: for (int i = 0; i <= MaxMinutes; ++i) { painter->save(); painter->rotate(-i * DegreesPerMinute); if (i % 5 == 0) { painter->setPen(thickPen); painter->drawLine(0, -41, 0, -44); painter->drawText(-15, -41, 30, 25,  Qt::AlignHCenter | Qt::AlignTop,  QString::number(i)); } else { painter->setPen(thinPen); painter->drawLine(0, -42, 0, -44); } painter->restore(); }Another way of implementing an oven timer would have been to compute the(x,y) positions ourselves, usingsin()andcos()to find the positions along thecircle. But then we would still need to use a translation and a rotation to drawthe text at an angle.High-Quality Rendering with QImageWhen drawing, we may be faced with a trade-off between speed and accuracy.For example, on X11 and Mac OS X, drawing on aQWidgetorQPixmaprelies onthe platform’s native paint engine. On X11, this ensures that communicationwith the X server is kept to a minimum; only paint commands are sent ratherthan actual image data. The main drawback of this approach is that Qt islimited by the platform’s native support:• On X11, features such as antialiasing and support for fractional coordi-nates are available only if the X Render extension is present on the Xserver.• On Mac OS X, the native aliased graphics engine uses different algorithmsfor drawing polygons than X11 and Windows, with slightly differentresults.When accuracy is more important than efficiency, we can draw to aQImageand copy the result onto the screen. This always uses Qt’s own internal paint"},{"pageNumber":207,"pageContent":"High-Quality Rendering with QImage189engine, giving identical results on all platforms. The only restriction is thattheQImageon which we paint must be created with an argument of eitherQImage::Format_RGB32orQImage::Format_ARGB32_Premultiplied.The premultiplied ARGB32 format is almost identical to the conventionalARGB32 format (0xaarrggbb), the difference being that the red, green, and bluechannels are “premultiplied” with the alpha channel. This means that theRGB values, which normally range from0x00to0xFF, are scaled from0x00tothe alpha value. For example, a 50%-transparent blue color is representedas0x7F0000FFin ARGB32 format, but0x7F00007Fin premultiplied ARGB32format, and similarly a 75%-transparent dark green of0x3F008000in ARGB32format would be0x3F002000in premultiplied ARGB32 format.Let’s suppose we want to use antialiasing for drawing a widget, and we wantto obtain good results even on X11 systems with no X Render extension. TheoriginalpaintEvent()handler, which relies on X Render for the antialiasing,might look like this:void MyWidget::paintEvent(QPaintEvent *event){ QPainter painter(this); painter.setRenderHint(QPainter::Antialiasing, true); draw(&painter);}Here’s how to rewrite the widget’spaintEvent()function to use Qt’s platform-independent graphics engine:void MyWidget::paintEvent(QPaintEvent *event){ QImage image(size(), QImage::Format_ARGB32_Premultiplied); QPainter imagePainter(&image); imagePainter.initFrom(this); imagePainter.setRenderHint(QPainter::Antialiasing, true); imagePainter.eraseRect(rect()); draw(&imagePainter); imagePainter.end(); QPainter widgetPainter(this); widgetPainter.drawImage(0, 0, image);}We create aQImageof the same size as the widget in premultiplied ARGB32format, and aQPainterto draw on the image. TheinitFrom()call initializesthe painter’s pen, background, and font based on the widget. We perform thedrawing using theQPainteras usual, and at the end we reuse theQPainterobject to copy the image onto the widget.This approach produces identical high-quality results on all platforms, withthe exception of font rendering, which depends on the installed fonts.One particularly powerful feature of Qt’s graphics engine is its support for com-position modes. These specify how a source and a destination pixel are merged"},{"pageNumber":208,"pageContent":"1908. 2D and 3D Graphicstogether when drawing. This applies to all painting operations, including pen,brush, gradient, and image drawing.The default composition mode isQImage::CompositionMode_SourceOver, meaningthat the source pixel (the pixel we are drawing) is blended on top of thedestination pixel (the existing pixel) in such a way that the alpha componentof the source defines its translucency. Figure 8.11 shows the result of drawinga semi-transparent butterfly on top of a checker pattern with the differentmodes.Source SourceOver SourceIn SourceOut SourceAtop ClearDestinationDestination-OverDestination-InDestination-OutDestination-AtopXorFigure 8.11.QPainter’s composition modesCompositions modes are set usingQPainter::setCompositionMode(). For exam-ple, here’s how to create aQImagecontaining the XOR of the butterfly and thechecker pattern:QImage resultImage = checkerPatternImage;QPainter painter(&resultImage);painter.setCompositionMode(QPainter::CompositionMode_Xor);painter.drawImage(0, 0, butterflyImage);One issue to be aware of is that theQImage::CompositionMode_Xoroperationapplies to the alpha channel. This means that if we XOR the color white(0xFFFFFFFF) with itself, we obtain a transparent color (0x00000000), not black(0xFF000000).PrintingPrinting in Qt is similar to drawing on aQWidget,QPixmap, orQImage. It consistsof the following steps:1. Create aQPrinterto serve as the paint device.2. Pop up aQPrintDialog, allowing the user to choose a printer and to set afew options.3. Create aQPainterto operate on theQPrinter.4. Draw a page using theQPainter."},{"pageNumber":209,"pageContent":"Printing1915. CallQPrinter::newPage()to advance to the next page.6. Repeat steps 4 and 5 until all the pages are printed.On Windows and Mac OS X,QPrinteruses the system’s printer drivers. OnUnix, it generates PostScript and sends it tolporlpr(or to the program setusingQPrinter::setPrintProgram()).QPrintercan also be used to generate PDFfiles by callingsetOutputFormat(QPrinter::PdfFormat).Figure 8.12.Printing aQImageLet’s start with some simple examples that all print on a single page. The firstexample prints aQImage:void PrintWindow::printImage(const QImage &image){ QPrintDialog printDialog(&printer, this); if (printDialog.exec()) { QPainter painter(&printer); QRect rect = painter.viewport(); QSize size = image.size(); size.scale(rect.size(), Qt::KeepAspectRatio); painter.setViewport(rect.x(), rect.y(),  size.width(), size.height()); painter.setWindow(image.rect()); painter.drawImage(0, 0, image); }}We assume that thePrintWindowclass has a member variable calledprinterof typeQPrinter. We could simply have created theQPrinteron the stack in"},{"pageNumber":210,"pageContent":"1928. 2D and 3D GraphicsprintImage(), but then it would not remember the user’s settings from one printrun to another.We create aQPrintDialogand callexec()to show it. It returnstrueif the userclicked theOKbutton; otherwise, it returnsfalse. After the call toexec(), theQPrinterobject is ready to use. (It is also possible to print without using aQPrintDialog, by directly callingQPrintermember functions to set things up.)Next, we create aQPainterto draw on theQPrinter. We set the window to theimage’s rectangle and the viewport to a rectangle with the same aspect ratio,and we draw the image at position (0, 0).By default,QPainter’s window is initialized so that the printer appears to havea similar resolution as the screen (usually somewhere between 72 and 100 dotsper inch), making it easy to reuse widget painting code for printing. Here, itdidn’t matter, because we set our own window.Printing items that take up no more than a single page is simple, but manyapplications need to print multiple pages. For those, we need to paint onepage at a time and callnewPage()to advance to the next page. This raises theproblem of determining how much information we can print on each page.There are two main approaches to handling multi-page documents with Qt:• We can convert our data to HTML and render it usingQTextDocument, Qt’srich text engine.• We can perform the drawing and the page breaking by hand.We will review both approaches in turn. As an example, we will print a flowerguide: a list of flower names, each with a textual description. Each entry inthe guide is stored as a string of the format “name:description”, for example:Miltonopsis santanae: A most dangerous orchid species.Since each flower’s data is represented by a single string, we can represent allthe flowers in the guide using oneQStringList. Here’s the function that printsa flower guide using Qt’s rich text engine:void PrintWindow::printFlowerGuide(const QStringList &entries){ QString html; foreach (QString entry, entries) { QStringList fields = entry.split(\": \"); QString title = Qt::escape(fields[0]); QString body = Qt::escape(fields[1]); html += \"<table width=\\\"100%\\\" border=1 cellspacing=0>\\n\" \"<tr><td bgcolor=\\\"lightgray\\\"><font size=\\\"+1\\\">\" \"<b><i>\" + title + \"</i></b></font>\\n<tr><td>\" + body + \"\\n</table>\\n<br>\\n\"; } printHtml(html);}"},{"pageNumber":211,"pageContent":"Printing193The first step is to convert theQStringListinto HTML. Each flower becomesan HTML table with two cells. We useQt::escape()to replace the specialcharacters ‘&’, ‘<’, ‘>’ with the corresponding HTML entities (“&amp;”, “&lt;”,“&gt;”). Then we callprintHtml()to print the text.void PrintWindow::printHtml(const QString &html){ QPrintDialog printDialog(&printer, this); if (printDialog.exec()) { QPainter painter(&printer); QTextDocument textDocument; textDocument.setHtml(html); textDocument.print(&printer); }}TheprintHtml()function pops up aQPrintDialogand takes care of printingan HTML document. It can be reused “as is” in any Qt application to printarbitrary HTML pages.Aponogeton distachyosThe Cape pondweed (water hawthorn) is a deciduous perennial that has floating, oblong, dark green leaves which are sometimes splashed purple. The waxy-white flowers have a characteristic 'forked' appearance, sweet scent and black stamens. They appear from early spring until fall. They grow in deep or shallow water and spread to 1.2 m. Cabomba carolinianaThe Fish grass (or fanwort or Washington grass) is a useful oxygenator for ponds. It is a deciduous or semi-evergreen submerged perennial that is used by fish as a source of food and as a place in which to spawn. Plants form spreading hummocks of fan-shaped, coarsly divided leaves which are bright green. Tiny white flowers appear in the summer. Caltha palustrisThe Marsh marigold (or kingcup) is a deciduous perennial that grows in shallow water around the edges of ponds. It is equally well suited to a bog garden, moist rock garden or herbaceous border. The rounded dark green leaves set off its large, cup-shaped golden-yellow flowers. Plants can grow to 60 cm in height, with a spread of 45 cm. The double-flowered cultivar 'Flore Plena' only reaches 10 cm. Ceratophyllum demersumThe Hornwort is a deciduous perennial that produces feathery submerged foliage. It sometimes floats and spreads over a large area. It is a good oxygenator and grows best in cool deep water. It has no roots. Juncus effusus 'Spiralis'The Corkscrew rush is a tufted evergreen perennial with mid-green leafless stems which are twisted and curled like a corkscrew. The stems often lie on the ground. The greenish-brown flowers appear in summer. Plants are best used at the edge of a pond, so that the stems can be seen against the reflective water surface. Strong plants can send up 90 cm-tall twisted shoots which are used in modern flower arranging. Nuphar luteaThe Yellow water lily has small (6 cm diameter) yellow flowers that are bottle-shaped and sickly smelling. They are held above a mat of broad, oval, mid-green leaves which are about 40 cm wide, giving the plant a spread of up to 1.5 m. The seed heads are rounded and warty. This hardy deciduous perennial thrives in deep water, in sun or shade, and is useful for a water-lily effect where Nymphaea will not grow. Orontium aquaticumThe Golden club's flowers lack the spathe typical of other aroids, leaving the central yellow and white spadix to provide color. A deciduous perennial, the golden club grows equally well in shallow or deep water. In spring, the pencil-like flower spikes (spadices) emerge from among the floating mass of waxy leaves which are a bluish or greyish green. Plants grow to 25 cm high spreading up to 60 cm. Large seeds develop later in the summer and are used to propagate plants while they are still fresh. 1Trapa natansThe Jesuit's nut (or water chestnut) has mid-green diamond-shaped leaves with deeply toothed edges that grow in neat rosettes. The center of each leaf is often marked with deep purple blotches. White flowers are produced in summer. Each floating plant can spread to 23 cm. Zantedeschia aethiopicaThe Arum lily is a South African native that grows well in shallow water. It flowers throughout the summer, with the erect funnel-shaped spathes being held well above the arrow-shaped glossy, deep green leaves. Each spathe surrounds a central yellow spadix. The leaves and flowering stems arise from a tuber. Plants can reach up to 90 cm in height, spreading to 45 cm. 2Figure 8.13.Printing a flower guide usingQTextDocumentConverting a document to HTML and usingQTextDocumentto print it is byfar the most convenient alternative for printing reports and other complexdocuments. In cases where we need more control, we can do the page layoutand the drawing by hand. Let’s now see how we can use this approach to printa flower guide. Here’s the newprintFlowerGuide()function:void PrintWindow::printFlowerGuide(const QStringList &entries){ QPrintDialog printDialog(&printer, this); if (printDialog.exec()) {"},{"pageNumber":212,"pageContent":"1948. 2D and 3D Graphics QPainter painter(&printer); QList<QStringList> pages; paginate(&painter, &pages, entries); printPages(&painter, pages); }}After setting up the printer and constructing the painter, we call thepaginate()helper function to determine which entry should appear on which page. Theresult of this is a list ofQStringLists, with eachQStringListholding the entriesfor one page. We pass on that result toprintPages().For example, let’s suppose that the flower guide contains 6 entries, which wewill refer to asA,B,C,D,E, andF. Now let’s suppose that there is room forAandBon the first page;C,D, andEon the second page; andFon the thirdpage. Thepageslist would then have the list [A,B] at index position 0, thelist [C,D,E] at index position 1, and the list [F] at index position 2.void PrintWindow::paginate(QPainter *painter, QList<QStringList> *pages,  const QStringList &entries){ QStringList currentPage; int pageHeight = painter->window().height() - 2 * LargeGap; int y = 0; foreach (QString entry, entries) { int height = entryHeight(painter, entry); if (y + height > pageHeight && !currentPage.empty()) { pages->append(currentPage); currentPage.clear(); y = 0; } currentPage.append(entry); y += height + MediumGap; } if (!currentPage.empty()) pages->append(currentPage);}Thepaginate()function distributes the flower guide entries into pages. Itrelies on theentryHeight()function, which computes the height of one entry.It also takes into account the vertical gaps at the top and bottom of the page,of sizeLargeGap.We iterate through the entries and append them to the current page until wecome to an entry that doesn’t fit; then we append the current page to thepageslist and start a new page.int PrintWindow::entryHeight(QPainter *painter, const QString &entry){ QStringList fields = entry.split(\": \"); QString title = fields[0]; QString body = fields[1];"},{"pageNumber":213,"pageContent":"Printing195 int textWidth = painter->window().width() - 2 * SmallGap; int maxHeight = painter->window().height(); painter->setFont(titleFont); QRect titleRect = painter->boundingRect(0, 0, textWidth, maxHeight,  Qt::TextWordWrap, title); painter->setFont(bodyFont); QRect bodyRect = painter->boundingRect(0, 0, textWidth, maxHeight,  Qt::TextWordWrap, body); return titleRect.height() + bodyRect.height() + 4 * SmallGap;}TheentryHeight()function usesQPainter::boundingRect()to compute thevertical space needed by one entry. Figure 8.14 shows the layout of a flowerentry and the meaning of theSmallGapandMediumGapconstants.TitleBodyMediumMediumGapSmallSmallGapSmallSmallGapSmallSmallGapSmallSmallGapSmallSmallGapSmallSmallGapFigure 8.14.A flower entry’s layoutvoid PrintWindow::printPages(QPainter *painter,  const QList<QStringList> &pages){ int firstPage = printer.fromPage() - 1; if (firstPage >= pages.size()) return; if (firstPage == -1) firstPage = 0; int lastPage = printer.toPage() - 1; if (lastPage == -1 || lastPage >= pages.size()) lastPage = pages.size() - 1; int numPages = lastPage - firstPage + 1; for (int i = 0; i < printer.numCopies(); ++i) { for (int j = 0; j < numPages; ++j) { if (i != 0 || j != 0) printer.newPage(); int index; if (printer.pageOrder() == QPrinter::FirstPageFirst) { index = firstPage + j; } else {"},{"pageNumber":214,"pageContent":"1968. 2D and 3D Graphics index = lastPage - j; } printPage(painter, pages[index], index + 1); } }}TheprintPages()function’s role is to print each page usingprintPage()in thecorrect order and the correct amount of times. Using theQPrintDialog, theuser might request several copies, specify a print range, or request the pagesin reverse order. It is our responsibility to honor these options—or to disablethem usingQPrintDialog::setEnabledOptions().We start by determining the range to print.QPrinter’sfromPage()andtoPage()functions return the page numbers selected by the user, or 0 if no rangewas chosen. We subtract 1 because ourpageslist is indexed from 0, and setfirstPageandlastPageto cover the full range if the user didn’t set any range.Then we print each page. The outerforloop iterates as many times as nec-essary to produce the number of copies requested by the user. Most printerdrivers support multiple copies, so for thoseQPrinter::numCopies()always re-turns 1. If the printer driver can’t handle multiple copies,numCopies()returnsthe number of copies requested by the user, and the application is responsiblefor printing that number of copies. (In theQImageexample earlier in this sec-tion, we ignorednumCopies()for the sake of simplicity.)Aponogeton distachyosThe Cape pondweed (water hawthorn) is a deciduous perennial that has floating, oblong, dark green leaves which are sometimes splashed purple. The waxy-white flowers have a characteristic 'forked' appearance, sweet scent and black stamens. They appear from early spring until fall. They grow in deep or shallow water and spread to 1.2 m.Cabomba carolinianaThe Fish grass (or fanwort or Washington grass) is a useful oxygenator for ponds. It is a deciduous or semi-evergreen submerged perennial that is used by fish as a source of food and as a place in which to spawn. Plants form spreading hummocks of fan-shaped, coarsly divided leaves which are bright green. Tiny white flowers appear in the summer.Caltha palustrisThe Marsh marigold (or kingcup) is a deciduous perennial that grows in shallow water around the edges of ponds. It is equally well suited to a bog garden, moist rock garden or herbaceous border. The rounded dark green leaves set off its large, cup-shaped golden-yellow flowers. Plants can grow to 60 cm in height, with a spread of 45 cm. The double-flowered cultivar 'Flore Plena' only reaches 10 cm.Ceratophyllum demersumThe Hornwort is a deciduous perennial that produces feathery submerged foliage. It sometimes floats and spreads over a large area. It is a good oxygenator and grows best in cool deep water. It has no roots.Juncus effusus 'Spiralis'The Corkscrew rush is a tufted evergreen perennial with mid-green leafless stems which are twisted and curled like a corkscrew. The stems often lie on the ground. The greenish-brown flowers appear in summer. Plants are best used at the edge of a pond, so that the stems can be seen against the reflective water surface. Strong plants can send up 90 cm-tall twisted shoots which are used in modern flower arranging.1Nuphar luteaThe Yellow water lily has small (6 cm diameter) yellow flowers that are bottle-shaped and sickly smelling. They are held above a mat of broad, oval, mid-green leaves which are about 40 cm wide, giving the plant a spread of up to 1.5 m. The seed heads are rounded and warty. This hardy deciduous perennial thrives in deep water, in sun or shade, and is useful for a water-lily effect where Nymphaea will not grow.Orontium aquaticumThe Golden club's flowers lack the spathe typical of other aroids, leaving the central yellow and white spadix to provide color. A deciduous perennial, the golden club grows equally well in shallow or deep water. In spring, the pencil-like flower spikes (spadices) emerge from among the floating mass of waxy leaves which are a bluish or greyish green. Plants grow to 25 cm high spreading up to 60 cm. Large seeds develop later in the summer and are used to propagate plants while they are still fresh.Trapa natansThe Jesuit's nut (or water chestnut) has mid-green diamond-shaped leaves with deeply toothed edges that grow in neat rosettes. The center of each leaf is often marked with deep purple blotches. White flowers are produced in summer. Each floating plant can spread to 23 cm.Zantedeschia aethiopicaThe Arum lily is a South African native that grows well in shallow water. It flowers throughout the summer, with the erect funnel-shaped spathes being held well above the arrow-shaped glossy, deep green leaves. Each spathe surrounds a central yellow spadix. The leaves and flowering stems arise from a tuber. Plants can reach up to 90 cm in height, spreading to 45 cm.2Figure 8.15.Printing a flower guide usingQPainterThe innerforloop iterates through the pages. If the page isn’t the first page,we callnewPage()to flush the old page and start painting on a fresh page. WecallprintPage()to paint each page."},{"pageNumber":215,"pageContent":"Printing197void PrintWindow::printPage(QPainter *painter,  const QStringList &entries, int pageNumber){ painter->save(); painter->translate(0, LargeGap); foreach (QString entry, entries) { QStringList fields = entry.split(\": \"); QString title = fields[0]; QString body = fields[1]; printBox(painter, title, titleFont, Qt::lightGray); printBox(painter, body, bodyFont, Qt::white); painter->translate(0, MediumGap); } painter->restore(); painter->setFont(footerFont); painter->drawText(painter->window(), Qt::AlignHCenter | Qt::AlignBottom, QString::number(pageNumber));}TheprintPage()function iterates through all the flower guide entries andprints them using two calls toprintBox(): one for the title (the flower’s name)and one for the body (its description). It also draws the page number centeredat the bottom of the page.windowindowentriesflower entries print areanumber][page number](0,(0,(0,(0,(0, 0)Large(0,LargeGap)LargeLargeGapLargeLargeGapHeightpageHeightFigure 8.16.The flower guide’s page layoutvoid PrintWindow::printBox(QPainter *painter, const QString &str,  const QFont &font, const QBrush &brush){ painter->setFont(font); int boxWidth = painter->window().width(); int textWidth = boxWidth - 2 * SmallGap; int maxHeight = painter->window().height();"},{"pageNumber":216,"pageContent":"1988. 2D and 3D Graphics QRect textRect = painter->boundingRect(SmallGap, SmallGap,  textWidth, maxHeight,  Qt::TextWordWrap, str); int boxHeight = textRect.height() + 2 * SmallGap; painter->setPen(QPen(Qt::black, 2, Qt::SolidLine)); painter->setBrush(brush); painter->drawRect(0, 0, boxWidth, boxHeight); painter->drawText(textRect, Qt::TextWordWrap, str); painter->translate(0, boxHeight);}TheprintBox()function draws the outline of a box, then draws the text insidethe box.Graphics with OpenGLOpenGL is a standard API for rendering 2D and 3D graphics. Qt applica-tions can draw 3D graphics by using theQtOpenGLmodule, which relieson the system’s OpenGL library. This section assumes that you are familiarwith OpenGL. If OpenGL is new to you, a good place to start learning it ishttp://www.opengl.org/.Figure 8.17.The Tetrahedron applicationDrawing graphics with OpenGL from a Qt application is straightforward: Wemust subclassQGLWidget, reimplement a few virtual functions, and link theapplication against theQtOpenGLand OpenGL libraries. BecauseQGLWidgetinherits fromQWidget, most of what we already know still applies. The maindifference is that we use standard OpenGL functions to perform the drawinginstead ofQPainter."},{"pageNumber":217,"pageContent":"Graphics with OpenGL199To show how this works, we will review the code of the Tetrahedron applicationshown in Figure 8.17. The application presents a 3D tetrahedron, or four-sideddie, with each face drawn using a different color. The user can rotate thetetrahedron by pressing a mouse button and dragging. The user can set thecolor of a face by double-clicking it and choosing a color from theQColorDialogthat pops up.class Tetrahedron : public QGLWidget{ Q_OBJECTpublic: Tetrahedron(QWidget *parent = 0);protected: void initializeGL(); void resizeGL(int width, int height); void paintGL(); void mousePressEvent(QMouseEvent *event); void mouseMoveEvent(QMouseEvent *event); void mouseDoubleClickEvent(QMouseEvent *event);private: void draw(); int faceAtPosition(const QPoint &pos); GLfloat rotationX; GLfloat rotationY; GLfloat rotationZ; QColor faceColors[4]; QPoint lastPos;};TheTetrahedronclass inherits fromQGLWidget. TheinitializeGL(),resizeGL(),andpaintGL()functions are reimplemented fromQGLWidget. The mouse eventhandlers are reimplemented fromQWidgetas usual.Tetrahedron::Tetrahedron(QWidget *parent) : QGLWidget(parent){ setFormat(QGLFormat(QGL::DoubleBuffer | QGL::DepthBuffer)); rotationX = -21.0; rotationY = -57.0; rotationZ = 0.0; faceColors[0] = Qt::red; faceColors[1] = Qt::green; faceColors[2] = Qt::blue; faceColors[3] = Qt::yellow;}In the constructor, we callQGLWidget::setFormat()to specify the OpenGLdisplay context, and we initialize the class’s private variables.void Tetrahedron::initializeGL(){"},{"pageNumber":218,"pageContent":"2008. 2D and 3D Graphics qglClearColor(Qt::black); glShadeModel(GL_FLAT); glEnable(GL_DEPTH_TEST); glEnable(GL_CULL_FACE);}TheinitializeGL()function is called just once, beforepaintGL()is called. Thisis the place where we can set up the OpenGL rendering context, define displaylists, and perform other initializations.All the code is standard OpenGL, except for the call toQGLWidget’sqglClear-Color()function. If we wanted to stick to standard OpenGL, we would callgl-ClearColor()in RGBA mode andglClearIndex()in color index mode instead.void Tetrahedron::resizeGL(int width, int height){ glViewport(0, 0, width, height); glMatrixMode(GL_PROJECTION); glLoadIdentity(); GLfloat x = GLfloat(width) / height; glFrustum(-x, x, -1.0, 1.0, 4.0, 15.0); glMatrixMode(GL_MODELVIEW);}TheresizeGL()function is called beforepaintGL()is called the first time, butafterinitializeGL()is called. It is also called whenever the widget is resized.This is the place where we can set up the OpenGL viewport, projection, andany other settings that depend on the widget’s size.void Tetrahedron::paintGL(){ glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); draw();}ThepaintGL()function is called whenever the widget needs to be repainted.This is similar toQWidget::paintEvent(), but instead ofQPainterfunctionswe use OpenGL functions. The actual drawing is performed by the privatefunctiondraw().void Tetrahedron::draw(){ static const GLfloat P1[3] = { 0.0, -1.0, +2.0 }; static const GLfloat P2[3] = { +1.73205081, -1.0, -1.0 }; static const GLfloat P3[3] = { -1.73205081, -1.0, -1.0 }; static const GLfloat P4[3] = { 0.0, +2.0, 0.0 }; static const GLfloat * const coords[4][3] = { { P1, P2, P3 }, { P1, P3, P4 }, { P1, P4, P2 }, { P2, P4, P3 } }; glMatrixMode(GL_MODELVIEW); glLoadIdentity(); glTranslatef(0.0, 0.0, -10.0); glRotatef(rotationX, 1.0, 0.0, 0.0);"},{"pageNumber":219,"pageContent":"Graphics with OpenGL201 glRotatef(rotationY, 0.0, 1.0, 0.0); glRotatef(rotationZ, 0.0, 0.0, 1.0); for (int i = 0; i < 4; ++i) { glLoadName(i); glBegin(GL_TRIANGLES); qglColor(faceColors[i]); for (int j = 0; j < 3; ++j) { glVertex3f(coords[i][j][0], coords[i][j][1],  coords[i][j][2]); } glEnd(); }}Indraw(), we draw the tetrahedron, taking into account thex,y, andzrotationsand the colors stored in thefaceColorsarray. Everything is standard OpenGL,except for theqglColor()call. We could have used one of the OpenGL functionsglColor3d()orglIndex()instead, depending on the mode.void Tetrahedron::mousePressEvent(QMouseEvent *event){ lastPos = event->pos();}void Tetrahedron::mouseMoveEvent(QMouseEvent *event){ GLfloat dx = GLfloat(event->x() - lastPos.x()) / width(); GLfloat dy = GLfloat(event->y() - lastPos.y()) / height(); if (event->buttons() & Qt::LeftButton) { rotationX += 180 * dy; rotationY += 180 * dx; updateGL(); } else if (event->buttons() & Qt::RightButton) { rotationX += 180 * dy; rotationZ += 180 * dx; updateGL(); } lastPos = event->pos();}ThemousePressEvent()andmouseMoveEvent()functions are reimplemented fromQWidgetto allow the user to rotate the view by clicking and dragging. The leftmouse button allows the user to rotate around thexandyaxes, the right mousebutton around thexandzaxes.After modifying therotationXvariable, and either therotationYor therota-tionZvariable, we callupdateGL()to redraw the scene.void Tetrahedron::mouseDoubleClickEvent(QMouseEvent *event){ int face = faceAtPosition(event->pos()); if (face != -1) { QColor color = QColorDialog::getColor(faceColors[face], this);"},{"pageNumber":220,"pageContent":"2028. 2D and 3D Graphics if (color.isValid()) { faceColors[face] = color; updateGL(); } }}ThemouseDoubleClickEvent()is reimplemented fromQWidgetto allow the userto set the color of a tetrahedron face by double-clicking it. We call the privatefunctionfaceAtPosition()to determine which face, if any, is located under thecursor. If a face was double-clicked, we callQColorDialog::getColor()to obtaina new color for that face. Then we update thefaceColorsarray with the newcolor, and we callupdateGL()to redraw the scene.int Tetrahedron::faceAtPosition(const QPoint &pos){ const int MaxSize = 512; GLuint buffer[MaxSize]; GLint viewport[4]; glGetIntegerv(GL_VIEWPORT, viewport); glSelectBuffer(MaxSize, buffer); glRenderMode(GL_SELECT); glInitNames(); glPushName(0); glMatrixMode(GL_PROJECTION); glPushMatrix(); glLoadIdentity(); gluPickMatrix(GLdouble(pos.x()), GLdouble(viewport[3] - pos.y()), 5.0, 5.0, viewport); GLfloat x = GLfloat(width()) / height(); glFrustum(-x, x, -1.0, 1.0, 4.0, 15.0); draw(); glMatrixMode(GL_PROJECTION); glPopMatrix(); if (!glRenderMode(GL_RENDER)) return -1; return buffer[3];}ThefaceAtPosition()function returns the number of the face at a certainposition on the widget, or+--1 if there is no face at that position. The code fordetermining this in OpenGL is a bit complicated. Essentially, what we do isrender the scene inGL_SELECTmode to take advantage of OpenGL’s pickingcapabilities and then retrieve the face number (its “name”) from the OpenGLhit record.Here’smain.cpp:#include <QApplication>#include <iostream>"},{"pageNumber":221,"pageContent":"Graphics with OpenGL203#include \"tetrahedron.h\"using namespace std;int main(int argc, char *argv[]){ QApplication app(argc, argv); if (!QGLFormat::hasOpenGL()) { cerr << \"This system has no OpenGL support\" << endl; return 1; } Tetrahedron tetrahedron; tetrahedron.setWindowTitle(QObject::tr(\"Tetrahedron\")); tetrahedron.resize(300, 300); tetrahedron.show(); return app.exec();}If the user’s system doesn’t support OpenGL, we print an error message to theconsole and return immediately.To link the application against theQtOpenGLmodule and the system’sOpenGL library, the.profile needs this entry:QT += openglThat completes the Tetrahedron application. For more information about theQtOpenGLmodule, see the reference documentation forQGLWidget,QGLFormat,QGLContext,QGLColormap, andQGLPixelBuffer."},{"pageNumber":223,"pageContent":"9. Drag and DropuEnabling Drag and DropuSupporting Custom Drag TypesuClipboard HandlingDrag and drop is a modern and intuitive way of transferring informationwithin an application or between different applications. It is often provided inaddition to clipboard support for moving and copying data.In this chapter, we will see how to add drag and drop support to an applicationand how to handle custom formats. Then we will show how to reuse the dragand drop code to add clipboard support. This code reuse is possible becauseboth mechanisms are based onQMimeData, a class that can provide data inseveral formats.Enabling Drag and DropDrag and drop involves two distinct actions: dragging and dropping. Qtwidgets can serve as drag sites, as drop sites, or as both.Our first example shows how to make a Qt application accept a drag initiatedby another application. The Qt application is a main window with aQTextEditas its central widget. When the user drags a text file from the desktop or froma file explorer and drops it onto the application, the application loads the fileinto theQTextEdit.Here’s the definition of the example’sMainWindowclass:class MainWindow : public QMainWindow{ Q_OBJECTpublic: MainWindow();protected: void dragEnterEvent(QDragEnterEvent *event); void dropEvent(QDropEvent *event);private: bool readFile(const QString &fileName);205"},{"pageNumber":224,"pageContent":"2069. Drag and Drop QTextEdit *textEdit;};TheMainWindowclass reimplementsdragEnterEvent()anddropEvent()fromQWidget. Since the purpose of the example is to show drag and drop, much of thefunctionality we would expect to be in a main window class has been omitted.MainWindow::MainWindow(){ textEdit = new QTextEdit; setCentralWidget(textEdit); textEdit->setAcceptDrops(false); setAcceptDrops(true); setWindowTitle(tr(\"Text Editor\"));}In the constructor, we create aQTextEditand set it as the central widget. Bydefault,QTextEditaccepts textual drags from other applications, and if the userdrops a file onto it, it will insert the file name into the text. Since drop eventsare propagated from child to parent, by disabling dropping on theQTextEditand enabling it on the main window, we get the drop events for the wholewindow inMainWindow.void MainWindow::dragEnterEvent(QDragEnterEvent *event){ if (event->mimeData()->hasFormat(\"text/uri-list\")) event->acceptProposedAction();}ThedragEnterEvent()is called whenever the user drags an object onto a widget.If we callacceptProposedAction()on the event, we indicate that the user candrop the drag object on this widget. By default, the widget wouldn’t accept thedrag. Qt automatically changes the cursor to indicate to the user whether ornot the widget is a legitimate drop site.Here we want the user to be allowed to drag files but nothing else. To doso, we check the MIME type of the drag. The MIME typetext/uri-listisused to store a list of universal resource identifiers (URIs), which can be filenames, URLs (such as HTTP or FTP paths), or other global resource identi-fiers. Standard MIME types are defined by the Internet Assigned NumbersAuthority (IANA). They consist of a type and a subtype separated by a slash.MIME types are used by the clipboard and by the drag and drop system toidentify different types of data. The official list of MIME types is availableathttp://www.iana.org/assignments/media-types/.void MainWindow::dropEvent(QDropEvent *event){ QList<QUrl> urls = event->mimeData()->urls(); if (urls.isEmpty()) return; QString fileName = urls.first().toLocalFile();"},{"pageNumber":225,"pageContent":"Enabling Drag and Drop207 if (fileName.isEmpty()) return; if (readFile(fileName)) setWindowTitle(tr(\"%1 - %2\").arg(fileName)  .arg(tr(\"Drag File\")));}ThedropEvent()is called when the user drops an object onto the widget. WecallQMimeData::urls()to obtain a list ofQUrls. Typically, users only drag onefile at a time, but it is possible for them to drag multiple files by dragging aselection. If there’s more that one URL, or if the URL is not a local file name,we return immediately.QWidgetalso providesdragMoveEvent()anddragLeaveEvent(), but for mostapplications they don’t need to be reimplemented.The second example illustrates how to initiate a drag and accept a drop. Wewill create aQListWidgetsubclass that supports drag and drop, and use it as acomponent in the Project Chooser application shown in Figure 9.1.Figure 9.1.The Project Chooser applicationThe Project Chooser application presents the user with two list widgets,populated with names. Each list widget represents a project. The user candrag and drop the names in the list widgets to move a person from one projectto another.The drag and drop code is all located in theQListWidgetsubclass. Here’s theclass definition:class ProjectListWidget : public QListWidget{ Q_OBJECTpublic: ProjectListWidget(QWidget *parent = 0);protected: void mousePressEvent(QMouseEvent *event); void mouseMoveEvent(QMouseEvent *event); void dragEnterEvent(QDragEnterEvent *event);"},{"pageNumber":226,"pageContent":"2089. Drag and Drop void dragMoveEvent(QDragMoveEvent *event); void dropEvent(QDropEvent *event);private: void startDrag(); QPoint startPos;};TheProjectListWidgetclass reimplements five event handlers declared inQWidget.ProjectListWidget::ProjectListWidget(QWidget *parent) : QListWidget(parent){ setAcceptDrops(true);}In the constructor, we enable drops on the list widget.void ProjectListWidget::mousePressEvent(QMouseEvent *event){ if (event->button() == Qt::LeftButton) startPos = event->pos(); QListWidget::mousePressEvent(event);}When the user presses the left mouse button, we store the mouse positionin thestartPosprivate variable. We callQListWidget’s implementation ofmousePressEvent()to ensure that theQListWidgethas the opportunity to processmouse press events as usual.void ProjectListWidget::mouseMoveEvent(QMouseEvent *event){ if (event->buttons() & Qt::LeftButton) { int distance = (event->pos() - startPos).manhattanLength(); if (distance >= QApplication::startDragDistance()) startDrag(); } QListWidget::mouseMoveEvent(event);}When the user moves the mouse cursor while holding the left mouse button,we consider starting a drag. We compute the distance between the currentmouse position and the position where the left mouse button was pressed. Ifthe distance is larger thanQApplication’s recommended drag start distance(normally 4 pixels), we call the private functionstartDrag()to start dragging.This avoids initiating a drag just because the user’s hand shakes.void ProjectListWidget::startDrag(){ QListWidgetItem *item = currentItem(); if (item) { QMimeData *mimeData = new QMimeData; mimeData->setText(item->text());"},{"pageNumber":227,"pageContent":"Enabling Drag and Drop209 QDrag *drag = new QDrag(this); drag->setMimeData(mimeData); drag->setPixmap(QPixmap(\":/images/person.png\")); if (drag->start(Qt::MoveAction) == Qt::MoveAction) delete item; }}InstartDrag(), we create an object of typeQDragwiththisas its parent. TheQDragobject stores the data in aQMimeDataobject. For this example, we providethe data as atext/plainstring usingQMimeData::setText().QMimeDataprovidesseveral functions for handling the most common types of drags (images, URLs,colors, etc.) and can handle arbitrary MIME types represented asQByteArrays.The call toQDrag::setPixmap()sets the icon that follows the cursor while thedrag is taking place.TheQDrag::start()call starts the dragging operation and blocks until the userdrops or cancels the drag. It takes a combination of supported “drag actions”as argument (Qt::CopyAction,Qt::MoveAction, andQt::LinkAction) and returnsthe drag action that was executed (orQt::IgnoreActionif none was executed).Which action is executed depends on what the source widget allows, what thetarget supports, and which modifier keys are pressed when the drop occurs.After thestart()call, Qt takes ownership of the drag object and will delete itwhen it is no longer required.void ProjectListWidget::dragEnterEvent(QDragEnterEvent *event){ ProjectListWidget *source = qobject_cast<ProjectListWidget *>(event->source()); if (source && source != this) { event->setDropAction(Qt::MoveAction); event->accept(); }}TheProjectListWidgetwidget not only originates drags, it also accepts suchdrags if they come from anotherProjectListWidgetin the same application.QDragEnterEvent::source()returns a pointer to the widget that initiated thedrag if that widget is part of the same application; otherwise, it returns anull pointer. We useqobject_cast<T>()to ensure that the drag comes from aProjectListWidget. If all is correct, we tell Qt that we are ready to accept theaction as a move action.void ProjectListWidget::dragMoveEvent(QDragMoveEvent *event){ ProjectListWidget *source = qobject_cast<ProjectListWidget *>(event->source()); if (source && source != this) { event->setDropAction(Qt::MoveAction); event->accept(); }}"},{"pageNumber":228,"pageContent":"2109. Drag and DropThe code indragMoveEvent()is identical to what we did indragEnterEvent(). Itis necessary because we need to overrideQListWidget’s (actually,QAbstractItem-View’s) implementation of the function.void ProjectListWidget::dropEvent(QDropEvent *event){ ProjectListWidget *source = qobject_cast<ProjectListWidget *>(event->source()); if (source && source != this) { addItem(event->mimeData()->text()); event->setDropAction(Qt::MoveAction); event->accept(); }}IndropEvent(), we retrieve the dragged text usingQMimeData::text()and createan item with that text. We also need to accept the event as a “move action”to tell the source widget that it can now remove the original version of thedragged item.Drag and drop is a powerful mechanism for transferring data between applica-tions. But in some cases, it’s possible to implement drag and drop without usingQt’s drag and drop facilities. If all we want to do is to move data within onewidget in one application, we can often simply reimplementmousePressEvent()andmouseReleaseEvent().Supporting Custom Drag TypesIn the examples so far, we have relied onQMimeData’s support for common MIMEtypes. Thus, we calledQMimeData::setText()to create a text drag, and we usedQMimeData:urls()to retrieve the contents of atext/uri-listdrag. If we wantto drag plain text, HTML text, images, URLs, or colors, we can useQMimeDatawithout formality. But if we want to drag custom data, we must choosebetween the following alternatives:1. We can provide arbitrary data as aQByteArrayusingQMimeData::setData()and extract it later usingQMimeData::data().2. We can subclassQMimeDataand reimplementformats()andretrieveData()to handle our custom data types.3. For drag and drop operations within a single application, we can subclassQMimeDataand store the data using any data structure we want.The first approach does not involve any subclassing, but does have some draw-backs: We need to convert our data structure to aQByteArrayeven if the dragis not ultimately accepted, and if we want to provide several MIME types tointeract nicely with a wide range of applications, we need to store the data sev-eral times (once per MIME type). If the data is large, this can slow down theapplication needlessly. The second and third approaches can avoid or minimizethese problems. They give us complete control and can be used together."},{"pageNumber":229,"pageContent":"Supporting Custom Drag Types211To show how these approaches work, we will show how to add drag and dropcapabilities to aQTableWidget. The drag will support the following MIME types:text/plain,text/html, andtext/csv. Using the first approach, starting a draglooks like this:void MyTableWidget::mouseMoveEvent(QMouseEvent *event){ if (event->buttons() & Qt::LeftButton) { int distance = (event->pos() - startPos).manhattanLength(); if (distance >= QApplication::startDragDistance()) startDrag(); } QTableWidget::mouseMoveEvent(event);}void MyTableWidget::startDrag(){ QString plainText = selectionAsPlainText(); if (plainText.isEmpty()) return; QMimeData *mimeData = new QMimeData; mimeData->setText(plainText); mimeData->setHtml(toHtml(plainText)); mimeData->setData(\"text/csv\", toCsv(plainText).toUtf8()); QDrag *drag = new QDrag(this); drag->setMimeData(mimeData); if (drag->start(Qt::CopyAction | Qt::MoveAction) == Qt::MoveAction) deleteSelection();}ThestartDrag()private function is called frommouseMoveEvent()to start drag-ging a rectangular selection. We set thetext/plainandtext/htmlMIMEtypes usingsetText()andsetHtml(), and we set thetext/csvtype usingset-Data(), which takes an arbitrary MIME type and aQByteArray. The code for theselectionAsString()is more or less the same as theSpreadsheet::copy()func-tion from Chapter 4 (p. 83).QString MyTableWidget::toCsv(const QString &plainText){ QString result = plainText; result.replace(\"\\\\\", \"\\\\\\\\\"); result.replace(\"\\\"\", \"\\\\\\\"\"); result.replace(\"\\t\", \"\\\", \\\"\"); result.replace(\"\\n\", \"\\\"\\n\\\"\"); result.prepend(\"\\\"\"); result.append(\"\\\"\"); return result;}QString MyTableWidget::toHtml(const QString &plainText){ QString result = Qt::escape(plainText); result.replace(\"\\t\", \"<td>\");"},{"pageNumber":230,"pageContent":"2129. Drag and Drop result.replace(\"\\n\", \"\\n<tr><td>\"); result.prepend(\"<table>\\n<tr><td>\"); result.append(\"\\n</table>\"); return result;}ThetoCsv()andtoHtml()functions convert a “tabs and newlines” string into aCSV (comma-separated values) or an HTML string. For example, the dataRed Green BlueCyan Yellow Magentais converted to\"Red\", \"Green\", \"Blue\"\"Cyan\", \"Yellow\", \"Magenta\"or to<table><tr><td>Red<td>Green<td>Blue<tr><td>Cyan<td>Yellow<td>Magenta</table>The conversion is performed in the simplest way possible, usingQString::replace(). To escape HTML special characters, we useQt::escape().void MyTableWidget::dropEvent(QDropEvent *event){ if (event->mimeData()->hasFormat(\"text/csv\")) { QByteArray csvData = event->mimeData()->data(\"text/csv\"); QString csvText = QString::fromUtf8(csvData);••• event->acceptProposedAction(); } else if (event->mimeData()->hasFormat(\"text/plain\")) { QString plainText = event->mimeData()->text();••• event->acceptProposedAction(); }}Although we provide the data in three different formats, we only accept twoof them indropEvent(). If the user drags cells from aQTableWidgetto an HTMLeditor, we want the cells to be converted into an HTML table. But if the userdrags arbitrary HTML into aQTableWidget, we don’t want to accept it.To make this example work, we also need to callsetAcceptDrops(true)andsetSelectionMode(ContiguousSelection)in theMyTableWidgetconstructor.We will now redo the example, but this time we will subclassQMimeDatato post-pone or avoid the (potentially expensive) conversions betweenQTableWidget-Items andQByteArray. Here’s the definition of our subclass:class TableMimeData : public QMimeData{ Q_OBJECT"},{"pageNumber":231,"pageContent":"Supporting Custom Drag Types213public: TableMimeData(const QTableWidget *tableWidget, const QTableWidgetSelectionRange &range); const QTableWidget *tableWidget() const { return myTableWidget; } QTableWidgetSelectionRange range() const { return myRange; } QStringList formats() const;protected: QVariant retrieveData(const QString &format,  QVariant::Type preferredType) const;private: static QString toHtml(const QString &plainText); static QString toCsv(const QString &plainText); QString text(int row, int column) const; QString rangeAsPlainText() const; const QTableWidget *myTableWidget; QTableWidgetSelectionRange myRange; QStringList myFormats;};Instead of storing actual data, we store aQTableWidgetSelectionRangethat spec-ifies which cells are being dragged and keep a pointer to theQTableWidget. Theformats()andretrieveData()functions are reimplemented fromQMimeData.TableMimeData::TableMimeData(const QTableWidget *tableWidget,  const QTableWidgetSelectionRange &range){ myTableWidget = tableWidget; myRange = range; myFormats << \"text/csv\" << \"text/html\" << \"text/plain\";}In the constructor, we initialize the private variables.QStringList TableMimeData::formats() const{ return myFormats;}Theformats()function returns a list of MIME types provided by the MIMEdata object. The precise order of the formats is usually irrelevant, but it’sgood practice to put the “best” formats first. Applications that support manyformats will sometimes use the first one that matches.QVariant TableMimeData::retrieveData(const QString &format,  QVariant::Type preferredType) const{ if (format == \"text/plain\") { return rangeAsPlainText(); } else if (format == \"text/csv\") { return toCsv(rangeAsPlainText()); } else if (format == \"text/html\") {"},{"pageNumber":232,"pageContent":"2149. Drag and Drop return toHtml(rangeAsPlainText()); } else { return QMimeData::retrieveData(format, preferredType); }}TheretrieveData()function returns the data for a given MIME type as aQVari-ant. The value of theformatparameter is normally one of the strings returnedbyformats(), but we cannot assume that, since not all applications check theMIME type againstformats(). The getter functionstext(),html(),urls(),image-Data(),colorData(), anddata()provided byQMimeDataare implemented in termsofretrieveData().ThepreferredTypeparameter gives us a hint about which type we should put intheQVariant. Here, we ignore it and trustQMimeDatato convert the return valueinto the desired type, if necessary.void MyTableWidget::dropEvent(QDropEvent *event){ const TableMimeData *tableData = qobject_cast<const TableMimeData *>(event->mimeData()); if (tableData) { const QTableWidget *otherTable = tableData->tableWidget(); QTableWidgetSelectionRange otherRange = tableData->range();••• event->acceptProposedAction(); } else if (event->mimeData()->hasFormat(\"text/csv\")) { QByteArray csvData = event->mimeData()->data(\"text/csv\"); QString csvText = QString::fromUtf8(csvData);••• event->acceptProposedAction(); } else if (event->mimeData()->hasFormat(\"text/plain\")) { QString plainText = event->mimeData()->text();••• event->acceptProposedAction(); } QTableWidget::mouseMoveEvent(event);}ThedropEvent()function is similar to the one we had earlier in this section,but this time we optimize it by checking first if we can safely cast theQMimeDataobject to aTableMimeData. If theqobject_cast<T>()works, this means the dragwas originated by aMyTableWidgetin the same application, and we can directlyaccess the table data instead of going throughQMimeData’s API. If the cast fails,we extract the data the standard way.In this example, we encoded the CSV text using the UTF-8 encoding. Ifwe want to be certain of using the right encoding, we could use thecharsetparameter of thetext/plainMIME type to specify an explicit encoding. Hereare a few examples:text/plain;charset=US-ASCIItext/plain;charset=ISO-8859-1"},{"pageNumber":233,"pageContent":"Supporting Custom Drag Types215text/plain;charset=Shift_JIStext/plain;charset=UTF-8Clipboard HandlingMost applications make use of Qt’s built-in clipboard handling in one way oranother. For example, theQTextEditclass providescut(),copy(), andpaste()slots as well as keyboard shortcuts, so little or no additional code is required.When writing our own classes, we can access the clipboard throughQApplica-tion::clipboard(), which returns a pointer to the application’sQClipboardob-ject. Handling the system clipboard is easy: CallsetText(),setImage(), orset-Pixmap()to put data onto the clipboard, and calltext(),image(), orpixmap()toretrieve data from the clipboard. We have already seen examples of clipboarduse in the Spreadsheet application from Chapter 4.For some applications, the built-in functionality might not be sufficient. Forexample, we might want to provide data that isn’t just text or an image, or wemight want to provide data in many different formats for maximum interop-erability with other applications. The issue is very similar to what we encoun-tered earlier with drag and drop, and the answer is also similar: We can sub-classQMimeDataand reimplement a few virtual functions.If our application supports drag and drop through a customQMimeDatasubclass,we can simply reuse theQMimeDatasubclass and put it on the clipboard usingthesetMimeData()function. To retrieve the data, we can callmimeData()onthe clipboard.On X11, it is usually possible to paste a selection by clicking the middle buttonof a three-button mouse. This is done using a separate “selection” clipboard.If you want your widgets to support this kind of clipboard as well as the stan-dard one, you must passQClipboard::Selectionas an additional argument tothe various clipboard calls. For example, here’s how we would reimplementmouseReleaseEvent()in a text editor to support pasting using the middle mousebutton:void MyTextEditor::mouseReleaseEvent(QMouseEvent *event){ QClipboard *clipboard = QApplication::clipboard(); if (event->button() == Qt::MidButton && clipboard->supportsSelection()) { QString text = clipboard->text(QClipboard::Selection); pasteText(text); }}On X11, thesupportsSelection()function returnstrue. On other platforms, itreturnsfalse.If we want to be notified whenever the clipboard’s contents change, we canconnect theQClipboard::dataChanged()signal to a custom slot."},{"pageNumber":235,"pageContent":"10. Item View ClassesuUsing the Item View ConvenienceClassesuUsing Predefined ModelsuImplementing Custom ModelsuImplementing Custom DelegatesMany applications let the user search, view, and edit individual items that be-long to a data set. The data might be held in files or accessed from a databaseor a network server. The standard approach to dealing with data sets like thisis to use Qt’s item view classes.In earlier versions of Qt, the item view widgets were populated with the entirecontents of a data set; the users would perform all their searches and edits onthe data held in the widget, and at some point the changes would be writtenback to the data source. Although simple to understand and use, this approachdoesn’t scale well to very large data sets and doesn’t lend itself to situationswhere we want to display the same data set in two or more different widgets.The Smalltalk language popularized a flexible approach to visualizing largedata sets: model–view–controller (MVC). In the MVC approach, themodelrep-resents the data set and is responsible for fetching the data that is needed forviewing and for writing back any changes. Each type of data set has its ownmodel, but the API that the models provide to the views is uniform no matterwhat the underlying data set. Theviewpresents the data to the user. With anylarge data set only a limited amount of data will be visible at any one time, sothat is the only data that the view asks for. Thecontrollermediates betweenthe user and the view, converting user actions into requests to navigate or editdata, which the view then transmits to the model as necessary.DelegateData SourceModelViewFigure 10.1.Qt’s model/view architectureQt provides a model/view architecture inspired by the MVC approach. InQt, the model behaves the same as it does for classic MVC. But instead of acontroller, Qt uses a slightly different abstraction: thedelegate. The delegate217"},{"pageNumber":236,"pageContent":"21810. Item View Classesis used to provide fine control over how items are rendered and edited. Qtprovides a default delegate for every type of view. This is sufficient for mostapplications, so we usually don’t need to care about it.Using Qt’s model/view architecture, we can use models that only fetch the datathat is actually needed for display in the view. This makes handling very largedata sets much faster and less memory hungry than reading all the data. Andby registering a model with two or more views, we can give the user the oppor-tunity of viewing and interacting with the data in different ways, with littleoverhead. Qt automatically keeps multiple views in sync, reflecting changesto one in all the others. An additional benefit of the model/view architecture isthat if we decide to change how the underlying data set is stored, we just needto change the model; the views will continue to behave correctly.List View 1List View 2List View 3Table View 1Table View 2ModelData SourceFigure 10.2.One model can serve multiple viewsIn many situations, we only need to present relatively small numbers of itemsto the user. In these common cases, we can use Qt’s convenience item viewclasses (QListWidget,QTableWidget, andQTreeWidget) and populate them withitems directly. These classes behave in a similar way to the item view class-es provided by earlier versions of Qt. They store their data in “items” (for ex-ample, aQTableWidgetcontainsQTableWidgetItems). Internally, the convenienceclasses use custom models that make the items visible to the views.For large data sets, duplicating the data is often not an option. In these cases,we can use Qt’s views (QListView,QTableView, andQTreeView), in conjunction witha data model, which can be a custom model or one of Qt’s predefined models.For example, if the data set is held in a database, we can combine aQTableViewwith aQSqlTableModel.Using the Item View Convenience ClassesUsing Qt’s item view convenience subclasses is usually simpler than defininga custom model and is appropriate when we don’t need the benefits of sepa-rating the model and the view. We used this technique in Chapter 4 when wesubclassedQTableWidgetandQTableWidgetItemto implement spreadsheet func-tionality."},{"pageNumber":237,"pageContent":"Using the Item View Convenience Classes219In this section, we will show how to use the convenience item view subclassesto display items. The first example shows a read-onlyQListWidget, the secondexample shows an editableQTableWidget, and the third example shows aread-onlyQTreeWidget.We begin with a simple dialog that lets the user pick a flowchart symbol froma list. Each item consists of an icon, a text, and a unique ID.Figure 10.3.The Flowchart Symbol Picker applicationLet’s start with an extract from the dialog’s header file:class FlowChartSymbolPicker : public QDialog{ Q_OBJECTpublic: FlowChartSymbolPicker(const QMap<int, QString> &symbolMap,  QWidget *parent = 0); int selectedId() const { return id; } void done(int result);•••};When we construct the dialog, we must pass it aQMap<int,QString>, and after ithas executed we can retrieve the chosen ID (or+--1 if the user didn’t select anyitem) by callingselectedId().FlowChartSymbolPicker::FlowChartSymbolPicker( const QMap<int, QString> &symbolMap, QWidget *parent) : QDialog(parent){ id = -1; listWidget = new QListWidget; listWidget->setIconSize(QSize(60, 60)); QMapIterator<int, QString> i(symbolMap);"},{"pageNumber":238,"pageContent":"22010. Item View Classes while (i.hasNext()) { i.next(); QListWidgetItem *item = new QListWidgetItem(i.value(),   listWidget); item->setIcon(iconForSymbol(i.value())); item->setData(Qt::UserRole, i.key()); }•••}We initializeid(the last selected ID) to+--1. Next we construct aQListWidget, aconvenience item view widget. We iterate over each item in the flowchart sym-bol map and create aQListWidgetItemto represent each one. TheQListWidget-Itemconstructor takes aQStringthat represents the text to display, followed bythe parentQListWidget.Then we set the item’s icon and we callsetData()to store our arbitrary ID intheQListWidgetItem. TheiconForSymbol()private function returns aQIconfor agiven symbol name.QListWidgetItem’s have several roles, each of which has an associatedQVariant.The most common roles areQt::DisplayRole,Qt::EditRole, andQt::IconRole,and for these there are convenience setter and getter functions (setText(),setIcon()), but there are several other roles. We can also define custom roles byspecifying a numeric value ofQt::UserRoleor higher. In our example, we useQt::UserRoleto store each item’s ID.The omitted part of the constructor is concerned with creating the buttons,laying out the widgets, and setting the window’s title.void FlowChartSymbolPicker::done(int result){ id = -1; if (result == QDialog::Accepted) { QListWidgetItem *item = listWidget->currentItem(); if (item) id = item->data(Qt::UserRole).toInt(); } QDialog::done(result);}Thedone()function is reimplemented fromQDialog. It is called when the userpressesOKorCancel. If the user clickedOK, we retrieve the relevant item andextract the ID using thedata()function. If we were interested in the item’stext, we could retrieve it by callingitem->data(Qt::DisplayRole).toString()ormore conveniently,item->text().By default,QListWidgetis read-only. If we wanted the user to edit the items, wecould set the view’s edit triggers usingQAbstractItemView::setEditTriggers();for example, a setting ofQAbstractItemView::AnyKeyPressedmeans that the usercan begin editing an item just by starting to type. Alternatively, we couldprovide anEditbutton (and perhapsAddandDeletebuttons) and connect themto slots so that we could handle the editing operations programmatically."},{"pageNumber":239,"pageContent":"Using the Item View Convenience Classes221Now that we have seen how to use a convenience item view class for viewingand selecting data, we will look at an example where we can edit data. Againwe are using a dialog, this time one that presents a set of (x,y) coordinates thatthe user can edit.Figure 10.4.The Coordinate Setter applicationAs with the previous example, we will focus on the item view relevant code,starting with the constructor.CoordinateSetter::CoordinateSetter(QList<QPointF> *coords,  QWidget *parent) : QDialog(parent){ coordinates = coords; tableWidget = new QTableWidget(0, 2); tableWidget->setHorizontalHeaderLabels( QStringList() << tr(\"X\") << tr(\"Y\")); for (int row = 0; row < coordinates->count(); ++row) { QPointF point = coordinates->at(row); addRow(); tableWidget->item(row, 0)->setText(QString::number(point.x())); tableWidget->item(row, 1)->setText(QString::number(point.y())); }•••}TheQTableWidgetconstructor takes the initial number of table rows andcolumns to display. Every item in aQTableWidgetis represented by aQTable-WidgetItem, including horizontal and vertical header items. ThesetHorizontal-HeaderLabels()function sets the text for each horizontal table widget item tothe corresponding text in the string list it is passed. By default,QTableWidgetprovides a vertical header with rows labeled from 1, which is exactly what wewant, so we don’t need to set the vertical header labels manually."},{"pageNumber":240,"pageContent":"22210. Item View ClassesOnce we have created and centered the column labels, we iterate through thecoordinate data that was passed in. For every (x,y) pair, we create twoQTable-WidgetItems corresponding to thexandycoordinates. The items are added tothe table usingQTableWidget::setItem(), which takes a row and a column inaddition to the item.By default,QTableWidgetallows editing. The user can edit any cell in the tableby navigating to it and then either pressingF2or simply by typing. All changesmade by the user in the view will be automatically reflected into theQTableWid-getItems. To prevent editing, we can callsetEditTriggers(QAbstractItemView::NoEditTriggers).void CoordinateSetter::addRow(){ int row = tableWidget->rowCount(); tableWidget->insertRow(row); QTableWidgetItem *item0 = new QTableWidgetItem; item0->setTextAlignment(Qt::AlignRight | Qt::AlignVCenter); tableWidget->setItem(row, 0, item0); QTableWidgetItem *item1 = new QTableWidgetItem; item1->setTextAlignment(Qt::AlignRight | Qt::AlignVCenter); tableWidget->setItem(row, 1, item1); tableWidget->setCurrentItem(item0);}TheaddRow()slot is invoked when the user clicks theAdd Rowbutton. Weappend a new row usinginsertRow(). If the user attempts to edit a cell in thenew row, theQTableWidgetwill automatically create a newQTableWidgetItem.void CoordinateSetter::done(int result){ if (result == QDialog::Accepted) { coordinates->clear(); for (int row = 0; row < tableWidget->rowCount(); ++row) { double x = tableWidget->item(row, 0)->text().toDouble(); double y = tableWidget->item(row, 1)->text().toDouble(); coordinates->append(QPointF(x, y)); } } QDialog::done(result);}Finally, when the user clicksOK, we clear the coordinates that were passed into the dialog, and create a new set based on the coordinates in theQTableWid-get’s items.For our third and final example of Qt’s convenience item view widgets, we willlook at some snippets from an application that shows Qt application settingsusing aQTreeWidget. Read-only is the default forQTreeWidget."},{"pageNumber":241,"pageContent":"Using the Item View Convenience Classes223Figure 10.5.The Settings Viewer applicationHere’s an extract from the constructor:SettingsViewer::SettingsViewer(QWidget *parent) : QDialog(parent){ organization = \"Trolltech\"; application = \"Designer\"; treeWidget = new QTreeWidget; treeWidget->setColumnCount(2); treeWidget->setHeaderLabels( QStringList() << tr(\"Key\") << tr(\"Value\")); treeWidget->header()->setResizeMode(0, QHeaderView::Stretch); treeWidget->header()->setResizeMode(1, QHeaderView::Stretch);••• setWindowTitle(tr(\"Settings Viewer\")); readSettings();}To access an application’s settings, aQSettingsobject must be created with theorganization’s name and the application’s name as parameters. We set defaultnames (“Designer” by “Trolltech”) and then construct a newQTreeWidget. At theend, we call thereadSettings()function.void SettingsViewer::readSettings(){ QSettings settings(organization, application); treeWidget->clear(); addChildSettings(settings, 0, \"\"); treeWidget->sortByColumn(0); treeWidget->setFocus(); setWindowTitle(tr(\"Settings Viewer - %1 by %2\") .arg(application).arg(organization));}"},{"pageNumber":242,"pageContent":"22410. Item View ClassesApplication settings are stored in a hierarchy of keys and values. Theadd-ChildSettings()private function takes a settings object, a parentQTreeWid-getItem, and the current “group”. A group is theQSettingsequivalent of a filesystem directory. TheaddChildSettings()function can call itself recursively totraverse an arbitrary tree structure. The initial call from thereadSettings()function passes 0 as the parent item to represent the root.void SettingsViewer::addChildSettings(QSettings &settings, QTreeWidgetItem *parent, const QString &group){ QTreeWidgetItem *item; settings.beginGroup(group); foreach (QString key, settings.childKeys()) { if (parent) { item = new QTreeWidgetItem(parent); } else { item = new QTreeWidgetItem(treeWidget); } item->setText(0, key); item->setText(1, settings.value(key).toString()); } foreach (QString group, settings.childGroups()) { if (parent) { item = new QTreeWidgetItem(parent); } else { item = new QTreeWidgetItem(treeWidget); } item->setText(0, group); addChildSettings(settings, item, group); } settings.endGroup();}TheaddChildSettings()function is used to create all theQTreeWidgetItems. Ititerates over all the keys at the current level in the settings hierarchy andcreates oneQTableWidgetItemper key. If 0 was passed as theparentitem, wecreate the item as a child of theQTreeWidgetitself (making it a top-level item);otherwise, we create the item as a child ofparent. The first column is set to thename of the key and the second column to the corresponding value.Next, the function iterates over every group at the current level. For eachgroup, a newQTreeWidgetItemis created with its first column set to the group’sname. The function then calls itself recursively with the group item as theparent to populate theQTreeWidgetwith the group’s child items.The item view widgets shown in this section allow us to use a style of program-ming that is very similar to that used in earlier versions of Qt: reading an en-tire data set into an item view widget, using item objects to represent data el-ements, and (if the items are editable) writing back to the data source. In thefollowing sections, we will go beyond this simple approach and take full advan-tage of Qt’s model/view architecture."},{"pageNumber":243,"pageContent":"Using Predefined Models225Using Predefined ModelsQt provides several predefined models for use with the view classes:QStringListModelStores a list of stringsQStandardItemModelStores arbitrary hierarchical dataQDirModelEncapsulates the local file systemQSqlQueryModelEncapsulates an SQL result setQSqlTableModelEncapsulates an SQL tableQSqlRelationalTableModelEncapsulates an SQL table with foreign keysQSortFilterProxyModelSorts and/or filters another modelIn this section, we will look at how to use theQStringListModel, theQDirModel,and theQSortFilterProxyModel. The SQL models are covered in Chapter 13.Let’s begin with a simple dialog that users can use to add, delete, and edit aQStringList, where each string represents a team leader.Figure 10.6.The Team Leaders applicationHere’s the relevant extract from the constructor:TeamLeadersDialog::TeamLeadersDialog(const QStringList &leaders,  QWidget *parent) : QDialog(parent){ model = new QStringListModel(this); model->setStringList(leaders); listView = new QListView; listView->setModel(model); listView->setEditTriggers(QAbstractItemView::AnyKeyPressed  | QAbstractItemView::DoubleClicked);•••}"},{"pageNumber":244,"pageContent":"22610. Item View ClassesWe begin by creating and populating aQStringListModel. Next we create aQListViewand set its model to the one we have just created. We also set someediting triggers to allow the user to edit a string simply by starting to type onit or by double-clicking it. By default, no editing triggers are set on aQListView,making the view effectively read-only.void TeamLeadersDialog::insert(){ int row = listView->currentIndex().row(); model->insertRows(row, 1); QModelIndex index = model->index(row); listView->setCurrentIndex(index); listView->edit(index);}When the user clicks theInsertbutton, theinsert()slot is invoked. The slot be-gins by retrieving the row number for the list view’s current item. Every dataitem in a model has a corresponding “model index”, which is represented by aQModelIndexobject. We will look at model indexes in detail in the next section,but for now it is sufficient to know that an index has three main components: arow, a column, and a pointer to the model to which it belongs. For a one-dimen-sional list model, the column is always 0.Once we have the row number, we insert one new row at that position. Theinsertion is performed on the model, and the model automatically updates thelist view. We then set the list view’s current index to the blank row we justinserted. Finally, we set the list view to editing mode on the new row, just asif the user had pressed a key or double-clicked to initiate editing.void TeamLeadersDialog::del(){ model->removeRows(listView->currentIndex().row(), 1);}In the constructor, theDeletebutton’sclicked()signal is connected to thedel()slot. Since we are just deleting the current row, we can callremoveRows()withthe current index position and a row count of 1. Just like with insertion, werely on the model to update the view accordingly.QStringList TeamLeadersDialog::leaders() const{ return model->stringList();}Finally, theleaders()function provides a means of reading back the editedstrings when the dialog is closed.TeamLeadersDialogcould be made into a generic string list editing dialog sim-ply by parameterizing its window title. Another generic dialog that is oftenrequired is one that presents a list of files or directories to the user. The nextexample uses theQDirModelclass, which encapsulates the computer’s file sys-tem and is capable of showing (and hiding) various file attributes. This model"},{"pageNumber":245,"pageContent":"Using Predefined Models227can apply a filter to restrict the kinds of file system entries that are shown andcan order the entries in various ways.Figure 10.7.The Directory Viewer applicationWe will begin by looking at the creation and setting up of the model and theview in the Directory Viewer dialog’s constructor.DirectoryViewer::DirectoryViewer(QWidget *parent) : QDialog(parent){ model = new QDirModel; model->setReadOnly(false); model->setSorting(QDir::DirsFirst | QDir::IgnoreCase | QDir::Name); treeView = new QTreeView; treeView->setModel(model); treeView->header()->setStretchLastSection(true); treeView->header()->setSortIndicator(0, Qt::AscendingOrder); treeView->header()->setSortIndicatorShown(true); treeView->header()->setClickable(true); QModelIndex index = model->index(QDir::currentPath()); treeView->expand(index); treeView->scrollTo(index); treeView->resizeColumnToContents(0);•••}Once the model has been constructed, we make it editable and set variousinitial sort ordering attributes. We then create theQTreeViewthat will displaythe model’s data. TheQTreeView’s header can be used to provide user-controlledsorting. By making the header clickable, the user can sort by whichevercolumn header they click, with repeated clicks alternating between ascendingand descending orders. Once the tree view’s header has been set up, we getthe model index of the current directory and make sure that this directory isvisible by expanding its parents if necessary usingexpand(), and scrolling to"},{"pageNumber":246,"pageContent":"22810. Item View Classesit usingscrollTo(). Then we make sure that the first column is wide enough toshow all its entries without using ellipses (...).In the part of the constructor code that isn’t shown here, we connected theCreate DirectoryandRemovebuttons to slots to perform these actions. We donot need aRenamebutton since users can rename in-place by pressingF2and typing.void DirectoryViewer::createDirectory(){ QModelIndex index = treeView->currentIndex(); if (!index.isValid()) return; QString dirName = QInputDialog::getText(this,  tr(\"Create Directory\"),  tr(\"Directory name\")); if (!dirName.isEmpty()) { if (!model->mkdir(index, dirName).isValid()) QMessageBox::information(this, tr(\"Create Directory\"), tr(\"Failed to create the directory\")); }}If the user enters a directory name in the input dialog, we attempt to createa directory with this name as a child of the current directory. TheQDirModel::mkdir()function takes the parent directory’s index and the name of the newdirectory, and returns the model index of the directory it created. If theoperation fails, it returns an invalid model index.void DirectoryViewer::remove(){ QModelIndex index = treeView->currentIndex(); if (!index.isValid()) return; bool ok; if (model->fileInfo(index).isDir()) { ok = model->rmdir(index); } else { ok = model->remove(index); } if (!ok) QMessageBox::information(this, tr(\"Remove\"), tr(\"Failed to remove %1\").arg(model->fileName(index)));}If the user clicksRemove, we attempt to remove the file or directory associatedwith the current item. We could useQDirto accomplish that, butQDirModeloffers convenience functions that work onQModelIndexes.The last example in this section shows how to useQSortFilterProxyModel. Un-like the other predefined models, this model encapsulates an existing modeland manipulates the data that passes between the underlying model and the"},{"pageNumber":247,"pageContent":"Using Predefined Models229view. In our example, the underlying model is aQStringListModelinitializedwith the list of color names recognized by Qt (obtained throughQColor::col-orNames()). The user can type a filter string in aQLineEditand specify how thisstring is to be interpreted (as a regular expression, a wildcard pattern, or afixed string) using a combobox.Figure 10.8.The Color Names applicationHere’s an extract from theColorNamesDialogconstructor:ColorNamesDialog::ColorNamesDialog(QWidget *parent) : QDialog(parent){ sourceModel = new QStringListModel(this); sourceModel->setStringList(QColor::colorNames()); proxyModel = new QSortFilterProxyModel(this); proxyModel->setSourceModel(sourceModel); proxyModel->setFilterKeyColumn(0); listView = new QListView; listView->setModel(proxyModel);••• syntaxComboBox = new QComboBox; syntaxComboBox->addItem(tr(\"Regular expression\"), QRegExp::RegExp); syntaxComboBox->addItem(tr(\"Wildcard\"), QRegExp::Wildcard); syntaxComboBox->addItem(tr(\"Fixed string\"), QRegExp::FixedString);•••}TheQStringListModelis created and populated in the usual way. This is fol-lowed by the construction of theQSortFilterProxyModel. We pass the underly-ing model usingsetSourceModel()and tell the proxy to filter based on column0 of the original model. TheQComboBox::addItem()function accepts an optional“data” argument of typeQVariant; we use this to store theQRegExp::PatternSyn-taxvalue that corresponds to each item’s text."},{"pageNumber":248,"pageContent":"23010. Item View Classesvoid ColorNamesDialog::reapplyFilter(){ QRegExp::PatternSyntax syntax = QRegExp::PatternSyntax(syntaxComboBox->itemData( syntaxComboBox->currentIndex()).toInt()); QRegExp regExp(filterLineEdit->text(), Qt::CaseInsensitive, syntax); proxyModel->setFilterRegExp(regExp);}ThereapplyFilter()slot is invoked whenever the user changes the filter stringor the pattern syntax combobox. We create aQRegExpusing the text in the lineedit. Then we set its pattern syntax to the one stored in the syntax combobox’scurrent item’s data. When we callsetFilterRegExp(), the new filter becomesactive and the view is automatically updated.Implementing Custom ModelsQt’s predefined models offer a convenient means of handling and viewing data.However, some data sources cannot be used efficiently using the predefinedmodels, and for these situations it is necessary to create custom modelsoptimized for the underlying data source.Before we embark on creating custom models, let’s first review the key con-cepts used in Qt’s model/view architecture. Every data element in a modelhas a model index and a set of attributes, called roles, that can take arbitraryvalues. We saw earlier in the chapter that the most commonly used roles areQt::DisplayRoleandQt::EditRole. Other roles are used for supplementary data(for example,Qt::ToolTipRole,Qt::StatusTipRole, andQt::WhatsThisRole), andyet others for controlling basic display attributes (such asQt::FontRole,Qt::TextAlignmentRole,Qt::TextColorRole, andQt::BackgroundColorRole).List Modelrootrow012Table Modelrootrow012column012Tree Modelrootrow00112column0 1 2Figure 10.9.Schematic view of Qt’s models"},{"pageNumber":249,"pageContent":"Implementing Custom Models231For a list model, the only relevant index component is the row number, accessi-ble fromQModelIndex::row(). For a table model, the relevant index componentsare the row and column numbers, accessible fromQModelIndex::row()andQMod-elIndex::column(). For both list and table models, every item’s parent is theroot, which is represented by an invalidQModelIndex. The first two examples inthis section show how to implement custom table models.A tree model is similar to a table model, with the following differences. Likea table model, the parent of top-level items is the root (an invalidQModelIndex),but every other item’s parent is some other item in the hierarchy. Parents areaccessible fromQModelIndex::parent(). Every item has its role data, and zero ormore children, each an item in its own right. Since items can have other itemsas children, it is possible to represent recursive (tree-like) data structures, asthe final example in this section will show.The first example in this section is a read-only table model that shows currencyvalues in relation to each other.Figure 10.10.The Currencies applicationThe application could be implemented using a simple table, but we want touse a custom model to take advantage of certain properties of the data tominimize storage. If we were to store the 162 currently traded currencies in atable, we would need to store 162 × 162 = 26 244 values; with the custom modelpresented below, we only need to store 162 values (the value of each currencyin relation to the U.S. dollar).TheCurrencyModelclass will be used with a standardQTableView. TheCurrency-Modelis populated with aQMap<QString,double>; each key is a currency code andeach value is the value of the currency in U.S. dollars. Here’s a code snippetthat shows how the map is populated and how the model is used: QMap<QString, double> currencyMap; currencyMap.insert(\"AUD\", 1.3259); currencyMap.insert(\"CHF\", 1.2970);••• currencyMap.insert(\"SGD\", 1.6901); currencyMap.insert(\"USD\", 1.0000);"},{"pageNumber":250,"pageContent":"23210. Item View Classes CurrencyModel currencyModel; currencyModel.setCurrencyMap(currencyMap); QTableView tableView; tableView.setModel(&currencyModel); tableView.setAlternatingRowColors(true);Now we can look at the implementation of the model, starting with itsheader:class CurrencyModel : public QAbstractTableModel{public: CurrencyModel(QObject *parent = 0); void setCurrencyMap(const QMap<QString, double> &map); int rowCount(const QModelIndex &parent) const; int columnCount(const QModelIndex &parent) const; QVariant data(const QModelIndex &index, int role) const; QVariant headerData(int section, Qt::Orientation orientation, int role) const;private: QString currencyAt(int offset) const; QMap<QString, double> currencyMap;};We have chosen to subclassQAbstractTableModelfor our model since that mostclosely matches our data source. Qt provides several model base classes, in-cludingQAbstractListModel,QAbstractTableModel, andQAbstractItemModel. TheQAbstractItemModelclass is used to support a wide variety of models, includingthose that are based on recursive data structures, while theQAbstractListModelandQAbstractTableModelclasses are provided for convenience when using one-dimensional or two-dimensional data sets.QObjectQAbstractItemModelQAbstractListModelQAbstractTableModelFigure 10.11.Inheritance tree for the abstract model classesFor a read-only table model, we must reimplement three functions:rowCount(),columnCount(), anddata(). In this case, we have also reimplementedheader-Data(), and we provide a function to initialize the data (setCurrencyMap()).CurrencyModel::CurrencyModel(QObject *parent) : QAbstractTableModel(parent){}"},{"pageNumber":251,"pageContent":"Implementing Custom Models233We do not need to do anything in the constructor, except pass theparentparameter to the base class.int CurrencyModel::rowCount(const QModelIndex & /* parent */) const{ return currencyMap.count();}int CurrencyModel::columnCount(const QModelIndex & /* parent */) const{ return currencyMap.count();}For this table model, the row and column counts are the number of currenciesin the currency map. Theparentparameter has no meaning for a table model;it is there becauserowCount()andcolumnCount()are inherited from the moregenericQAbstractItemModelbase class, which supports hierarchies.QVariant CurrencyModel::data(const QModelIndex &index, int role) const{ if (!index.isValid()) return QVariant(); if (role == Qt::TextAlignmentRole) { return int(Qt::AlignRight | Qt::AlignVCenter); } else if (role == Qt::DisplayRole) { QString rowCurrency = currencyAt(index.row()); QString columnCurrency = currencyAt(index.column()); if (currencyMap.value(rowCurrency) == 0.0) return \"####\"; double amount = currencyMap.value(columnCurrency) / currencyMap.value(rowCurrency); return QString(\"%1\").arg(amount, 0, ’f’, 4); } return QVariant();}Thedata()function returns the value of any of an item’s roles. The itemis specified as aQModelIndex. For a table model, the interesting componentsof aQModelIndexare its row and column number, available usingrow()andcolumn().If the role isQt::TextAlignmentRole, we return an alignment suitable fornumbers. If the display role isQt::DisplayRole, we look up the value for eachcurrency and calculate the exchange rate.We could return the calculated value as adouble, but then we would have nocontrol over how many decimal places were shown (unless we use a customdelegate). Instead, we return the value as a string, formatted as we want."},{"pageNumber":252,"pageContent":"23410. Item View ClassesQVariant CurrencyModel::headerData(int section,  Qt::Orientation /* orientation */,  int role) const{ if (role != Qt::DisplayRole) return QVariant(); return currencyAt(section);}TheheaderData()function is called by the view to populate its horizontal andvertical headers. Thesectionparameter is the row or column number (depend-ing on the orientation). Since the rows and columns have the same currencycodes, we do not care about the orientation and simply return the code of thecurrency for the given section number.void CurrencyModel::setCurrencyMap(const QMap<QString, double> &map){ currencyMap = map; reset();}The caller can change the currency map usingsetCurrencyMap(). TheQAbstract-ItemModel::reset()call tells any views that are using the model that all theirdata is invalid; this forces them to request fresh data for the items that arevisible.QString CurrencyModel::currencyAt(int offset) const{ return (currencyMap.begin() + offset).key();}ThecurrencyAt()function returns the key (the currency code) at the givenoffset in the currency map. We use an STL-style iterator to find the item andcallkey()on it.As we have just seen, it is not difficult to create read-only models, and depend-ing on the nature of the underlying data, there are potential savings in mem-ory and speed with a well-designed model. The next example, the Cities appli-cation, is also table-based, but this time all the data is entered by the user.This application is used to store values indicating the distance between anytwo cities. Like the previous example, we could simply use aQTableWidgetandstore one item for every city pair. However, a custom model could be moreefficient, because the distance from any cityAto any different cityBis thesame whether traveling fromAtoBor fromBtoA, so the items are mirroredalong the main diagonal.To see how a custom model compares with a simple table, let us assume thatwe have three cities,A,B, andC. If we store a value for every combination,we would need to store nine values. A carefully designed model would requireonly the three items (A,B), (A,C), and (B,C)."},{"pageNumber":253,"pageContent":"Implementing Custom Models235Figure 10.12.The Cities applicationHere’s how we set up and use the model: QStringList cities; cities << \"Arvika\" << \"Boden\" << \"Eskilstuna\" << \"Falun\" << \"Filipstad\" << \"Halmstad\" << \"Helsingborg\" << \"Karlstad\" << \"Kiruna\" << \"Kramfors\" << \"Motala\" << \"Sandviken\" << \"Skara\" << \"Stockholm\" << \"Sundsvall\" << \"Trelleborg\"; CityModel cityModel; cityModel.setCities(cities); QTableView tableView; tableView.setModel(&cityModel); tableView.setAlternatingRowColors(true);We must reimplement the same functions as we did for the previous example.In addition, we must also reimplementsetData()andflags()to make themodel editable. Here is the class definition:class CityModel : public QAbstractTableModel{ Q_OBJECTpublic: CityModel(QObject *parent = 0); void setCities(const QStringList &cityNames); int rowCount(const QModelIndex &parent) const; int columnCount(const QModelIndex &parent) const; QVariant data(const QModelIndex &index, int role) const; bool setData(const QModelIndex &index, const QVariant &value, int role); QVariant headerData(int section, Qt::Orientation orientation, int role) const; Qt::ItemFlags flags(const QModelIndex &index) const;private: int offsetOf(int row, int column) const; QStringList cities; QVector<int> distances;};"},{"pageNumber":254,"pageContent":"23610. Item View ClassesFor this model, we are using two data structures:citiesof typeQStringListto hold the city names, anddistancesof typeQVector<int>to hold the distancebetween each unique pair of cities.CityModel::CityModel(QObject *parent) : QAbstractTableModel(parent){}The constructor does nothing beyond pass on theparentparameter to thebase class.int CityModel::rowCount(const QModelIndex & /* parent */) const{ return cities.count();}int CityModel::columnCount(const QModelIndex & /* parent */) const{ return cities.count();}Since we have a square grid of cities, the number of rows and columns is thenumber of cities in our list.QVariant CityModel::data(const QModelIndex &index, int role) const{ if (!index.isValid()) return QVariant(); if (role == Qt::TextAlignmentRole) { return int(Qt::AlignRight | Qt::AlignVCenter); } else if (role == Qt::DisplayRole) { if (index.row() == index.column()) return 0; int offset = offsetOf(index.row(), index.column()); return distances[offset]; } return QVariant();}Thedata()function is similar to what we did inCurrencyModel. It returns 0 ifthe row and column are the same, because that corresponds to the case wherethe two cities are the same; otherwise, it finds the entry for the given row andcolumn in thedistancesvector and returns the distance for that particular pairof cities.QVariant CityModel::headerData(int section,  Qt::Orientation /* orientation */,  int role) const{ if (role == Qt::DisplayRole) return cities[section]; return QVariant();}"},{"pageNumber":255,"pageContent":"Implementing Custom Models237TheheaderData()function is simple because we have a square table with everyrow having an identical column header. We simply return the name of the cityat the given offset in thecitiesstring list.bool CityModel::setData(const QModelIndex &index, const QVariant &value, int role){ if (index.isValid() && index.row() != index.column() && role == Qt::EditRole) { int offset = offsetOf(index.row(), index.column()); distances[offset] = value.toInt(); QModelIndex transposedIndex = createIndex(index.column(),   index.row()); emit dataChanged(index, index); emit dataChanged(transposedIndex, transposedIndex); return true; } return false;}ThesetData()function is called when the user edits an item. Providing themodel index is valid, the two cities are different, and the data element tomodify is theQt::EditRole, the function stores the value the user entered in thedistancesvector.ThecreateIndex()function is used to generate a model index. We need it toget the model index of the item on the other side of the main diagonal thatcorresponds with the item being set, since both items must show the samedata. ThecreateIndex()function takes the row before the column; here weinvert the parameters to get the model index of the diagonally opposite itemto the one specified byindex.We emit thedataChanged()signal with the model index of the item that waschanged. The reason this signal takes two model indexes is that it is possiblefor a change to affect a rectangular region of more than one row and column, sothe indexes passed are the index of the top left and bottom right items of thosethat have changed. We also emit thedataChanged()signal for the transposedindex to ensure that the view will refresh the item. Finally, we returntrueorfalseto indicate whether or not the edit succeeded.Qt::ItemFlags CityModel::flags(const QModelIndex &index) const{ Qt::ItemFlags flags = QAbstractItemModel::flags(index); if (index.row() != index.column()) flags |= Qt::ItemIsEditable; return flags;}Theflags()function is used by the model to communicate what can be donewith an item (for example, whether it is editable). The default implementationfromQAbstractTableModelreturnsQt::ItemIsSelectable | Qt::ItemIsEnabled. We"},{"pageNumber":256,"pageContent":"23810. Item View Classesadd theQt::ItemIsEditableflag for all items except those lying on the diagonals(which are always 0).void CityModel::setCities(const QStringList &cityNames){ cities = cityNames; distances.resize(cities.count() * (cities.count() - 1) / 2); distances.fill(0); reset();}If a new list of cities is given, we set the privateQStringListto the new list,resize and clear the distances vector, and callQAbstractItemModel::reset()tonotify any views that their visible items must be refetched.int CityModel::offsetOf(int row, int column) const{ if (row < column) qSwap(row, column); return (row * (row - 1) / 2) + column;}TheoffsetOf()private function computes the index of a given city pair in thedistancesvector. For example, if we had citiesA,B,C, andD, and the userupdated row 3, column 1,BtoD, the offset would be 3 × (3+--1)/2 + 1 = 4. Ifthe user had instead updated row 1, column 3,DtoB, thanks to theqSwap(),exactly the same calculation would be performed and an identical offset wouldbe returned.Table ModelABCDA0AÖBAÖCAÖDBAÖB0BÖCBÖDCAÖCBÖC0CÖDDAÖDBÖDCÖD0CitiesABCDDistancesAÖBAÖCAÖDBÖCBÖDCÖDFigure 10.13.Thecitiesanddistancesdata structures and the table modelThe last example in this section is a model that shows the parse tree for a givenregular expression. A regular expression consists of one or more terms, sep-arated by ‘|’ characters. Thus, the regular expression “alpha|bravo|charlie”contains three terms. Each term is a sequence of one or more factors; for exam-ple, the term “bravo” consists of five factors (each letter is a factor). The factorscan be further decomposed into an atom and an optional quantifier, such as ‘∗’,‘+’, and ‘?’. Since regular expressions can have parenthesized subexpressions,they can have recursive parse trees.The regular expression shown in Figure 10.14, “ab|(cd)?e”, matches an ‘a’followed by a ‘b’, or alternatively either a ‘c’ followed by a ‘d’ followed by an ‘e’,or just an ‘e’ on its own. So it will match “ab” and “cde”, but not “bc” or “cd”."},{"pageNumber":257,"pageContent":"Implementing Custom Models239Figure 10.14.The Regexp Parser applicationThe Regexp Parser application consists of four classes:•RegExpWindowis a window that lets the user enter a regular expression andshows the corresponding parse tree.•RegExpParsergenerates a parse tree from a regular expression.•RegExpModelis a tree model that encapsulates a parse tree.•Noderepresents an item in a parse tree.Let’s start with theNodeclass:class Node{public: enum Type { RegExp, Expression, Term, Factor, Atom, Terminal }; Node(Type type, const QString &str = \"\"); ~Node(); Type type; QString str; Node *parent; QList<Node *> children;};Every node has a type, a string (which may be empty), a parent (which may be0), and a list of child nodes (which may be empty).Node::Node(Type type, const QString &str){ this->type = type; this->str = str; parent = 0;}"},{"pageNumber":258,"pageContent":"24010. Item View ClassesThe constructor simply initializes the node’s type and string. Because all thedata is public, code that usesNodecan manipulate the type, string, parent, andchildren directly.Node::~Node(){ qDeleteAll(children);}TheqDeleteAll()function iterates over a container of pointers and callsdeleteon each one. It does not set the pointers to 0, so if it is used outside of adestructor it is common to follow it with a call toclear()on the container thatholds the pointers.Now that we have defined our data items (each represented by aNode), we areready to create a model:class RegExpModel : public QAbstractItemModel{public: RegExpModel(QObject *parent = 0); ~RegExpModel(); void setRootNode(Node *node); QModelIndex index(int row, int column, const QModelIndex &parent) const; QModelIndex parent(const QModelIndex &child) const; int rowCount(const QModelIndex &parent) const; int columnCount(const QModelIndex &parent) const; QVariant data(const QModelIndex &index, int role) const; QVariant headerData(int section, Qt::Orientation orientation, int role) const;private: Node *nodeFromIndex(const QModelIndex &index) const; Node *rootNode;};This time we have inherited fromQAbstractItemModelrather than from its con-venience subclassQAbstractTableModel, because we want to create a hierarchicalmodel. The essential functions that we must reimplement remain the same,except that we must also implementindex()andparent(). To set the model’sdata, we have asetRootNode()function that must be called with a parse tree’sroot node.RegExpModel::RegExpModel(QObject *parent) : QAbstractItemModel(parent){ rootNode = 0;}"},{"pageNumber":259,"pageContent":"Implementing Custom Models241In the model’s constructor, we just need to set the root node to a safe null valueand pass on theparentto the base class.RegExpModel::~RegExpModel(){ delete rootNode;}In the destructor we delete the root node. If the root node has children, eachof these is deleted, and so on recursively, by theNodedestructor.void RegExpModel::setRootNode(Node *node){ delete rootNode; rootNode = node; reset();}When a new root node is set, we begin by deleting any previous root node (andall of its children). Then we set the new root node and callreset()to notify anyviews that they must refetch the data for any visible items.QModelIndex RegExpModel::index(int row, int column,  const QModelIndex &parent) const{ if (!rootNode) return QModelIndex(); Node *parentNode = nodeFromIndex(parent); return createIndex(row, column, parentNode->children[row]);}Theindex()function is reimplemented fromQAbstractItemModel. It is calledwhenever the model or the view needs to create aQModelIndexfor a particularchild item (or a top-level item ifparentis an invalidQModelIndex). For table andlist models, we don’t need to reimplement this function, becauseQAbstractList-Model’s andQAbstractTableModel’s default implementations normally suffice.In ourindex()implementation, if no parse tree is set, we return an invalidQModelIndex. Otherwise, we create aQModelIndexwith the given row and columnand with aNode *for the requested child. For hierarchical models, knowingthe row and column of an item relative to its parent is not enough to uniquelyidentify it; we must also knowwhothe parent is. To solve this, we can store apointer to the internal node in theQModelIndex.QModelIndexgives us the optionof storing avoid *or anintin addition to the row and column numbers.TheNode *for the child is obtained through the parent node’schildrenlist. Theparent node is extracted from theparentmodel index using thenodeFromIndex()private function:Node *RegExpModel::nodeFromIndex(const QModelIndex &index) const{ if (index.isValid()) { return static_cast<Node *>(index.internalPointer()); } else {"},{"pageNumber":260,"pageContent":"24210. Item View Classes return rootNode; }}ThenodeFromIndex()function casts the given index’svoid *to aNode *, or returnsthe root node if the index is invalid, since an invalid model index is used torepresent the root in a model.int RegExpModel::rowCount(const QModelIndex &parent) const{ Node *parentNode = nodeFromIndex(parent); if (!parentNode) return 0; return parentNode->children.count();}The number of rows for a given item is simply how many children it has.int RegExpModel::columnCount(const QModelIndex & /* parent */) const{ return 2;}The number of columns is fixed at 2. The first column holds the node types; thesecond column holds the node values.QModelIndex RegExpModel::parent(const QModelIndex &child) const{ Node *node = nodeFromIndex(child); if (!node) return QModelIndex(); Node *parentNode = node->parent; if (!parentNode) return QModelIndex(); Node *grandparentNode = parentNode->parent; if (!grandparentNode) return QModelIndex(); int row = grandparentNode->children.indexOf(parentNode); return createIndex(row, child.column(), parentNode);}Retrieving the parentQModelIndexfrom a child is a bit more work than findinga parent’s child. We can easily retrieve the parent node usingnodeFromIndex()and going up using theNode’s parent pointer, but to obtain the row number(the position of the parent among its siblings), we need to go back to thegrandparent and find the parent’s index position in its parent’s (that is, thechild’s grandparent’s) list of children.QVariant RegExpModel::data(const QModelIndex &index, int role) const{ if (role != Qt::DisplayRole) return QVariant(); Node *node = nodeFromIndex(index); if (!node)"},{"pageNumber":261,"pageContent":"Implementing Custom Models243 return QVariant(); if (index.column() == 0) { switch (node->type) { case Node::RegExp: return tr(\"RegExp\"); case Node::Expression: return tr(\"Expression\"); case Node::Term: return tr(\"Term\"); case Node::Factor: return tr(\"Factor\"); case Node::Atom: return tr(\"Atom\"); case Node::Terminal: return tr(\"Terminal\"); default: return tr(\"Unknown\"); } } else if (index.column() == 1) { return node->str; } return QVariant();}Indata(), we retrieve theNode *for the requested item and we use it to accessthe underlying data. If the caller wants a value for any role exceptQt::DisplayRoleor if we cannot retrieve aNodefor the given model index, we returnan invalidQVariant. If the column is 0, we return the name of the node’s type;if the column is 1, we return the node’s value (its string).QVariant RegExpModel::headerData(int section,  Qt::Orientation orientation,  int role) const{ if (orientation == Qt::Horizontal && role == Qt::DisplayRole) { if (section == 0) { return tr(\"Node\"); } else if (section == 1) { return tr(\"Value\"); } } return QVariant();}In ourheaderData()reimplementation, we return appropriate horizontal head-er labels. TheQTreeViewclass, which is used to visualize hierarchical models,has no vertical header, so we ignore that possibility.Now that we have covered theNodeandRegExpModelclasses, let’s see how theroot node is created when the user changes the text in the line edit:void RegExpWindow::regExpChanged(const QString &regExp){ RegExpParser parser;"},{"pageNumber":262,"pageContent":"24410. Item View Classes Node *rootNode = parser.parse(regExp); regExpModel->setRootNode(rootNode);}When the user changes the text in the application’s line edit, the main win-dow’sregExpChanged()slot is called. In this slot, the user’s text is parsed andthe parser returns a pointer to the root node of the parse tree.We have not shown theRegExpParserclass because it is not relevant for GUI ormodel/view programming. The full source for this example is on the CD.In this section, we have seen how to create three different custom models.Many models are much simpler than those shown here, with one-to-one corre-spondences between items and model indexes. Further model/view examplesare provided with Qt itself, along with extensive documentation.Implementing Custom DelegatesIndividual items in views are rendered and edited using delegates. In most cas-es, the default delegate supplied by a view is sufficient. If we want to have finercontrol over the rendering of items, we can often achieve what we want simplyby using a custom model: In ourdata()reimplementation we can handle theQt::FontRole,Qt::TextAlignmentRole,Qt::TextColorRole, andQt::BackgroundCol-orRole, and these are used by the default delegate. For example, in the Citiesand Currencies examples shown earlier, we handled theQt::TextAlignmentRoleto get right-aligned numbers.If we want even greater control, we can create our own delegate class and setit on the views that we want to make use of it. The Track Editor dialog shownbelow makes use of a custom delegate. It shows the titles of music tracks andtheir durations. The data held by the model will be simplyQStrings (titles) andints (seconds), but the durations will be separated into minutes and secondsand will be editable using aQTimeEdit.Figure 10.15.The Track Editor dialog"},{"pageNumber":263,"pageContent":"Implementing Custom Delegates245The Track Editor dialog uses aQTableWidget, a convenience item view subclassthat operates onQTableWidgetItems. The data is provided as a list ofTracks:class Track{public: Track(const QString &title = \"\", int duration = 0); QString title; int duration;};Here is an extract from the constructor that shows the creation and populationof the table widget:TrackEditor::TrackEditor(QList<Track> *tracks, QWidget *parent) : QDialog(parent){ this->tracks = tracks; tableWidget = new QTableWidget(tracks->count(), 2); tableWidget->setItemDelegate(new TrackDelegate(1)); tableWidget->setHorizontalHeaderLabels( QStringList() << tr(\"Track\") << tr(\"Duration\")); for (int row = 0; row < tracks->count(); ++row) { Track track = tracks->at(row); QTableWidgetItem *item0 = new QTableWidgetItem(track.title); tableWidget->setItem(row, 0, item0); QTableWidgetItem *item1 = new QTableWidgetItem(QString::number(track.duration)); item1->setTextAlignment(Qt::AlignRight); tableWidget->setItem(row, 1, item1); }•••}The constructor creates a table widget, and instead of simply using the defaultdelegate, we set our customTrackDelegate, passing it the column that holdstime data. We begin by setting the column headings, and then iterate throughthe data, populating the rows with the name and duration of each track.The rest of the constructor and the rest of theTrackEditordialog holds nosurprises, so we will now look at theTrackDelegatethat handles the renderingand editing of track data.class TrackDelegate : public QItemDelegate{ Q_OBJECTpublic: TrackDelegate(int durationColumn, QObject *parent = 0);"},{"pageNumber":264,"pageContent":"24610. Item View Classes void paint(QPainter *painter, const QStyleOptionViewItem &option, const QModelIndex &index) const; QWidget *createEditor(QWidget *parent,  const QStyleOptionViewItem &option,  const QModelIndex &index) const; void setEditorData(QWidget *editor, const QModelIndex &index) const; void setModelData(QWidget *editor, QAbstractItemModel *model, const QModelIndex &index) const;private slots: void commitAndCloseEditor();private: int durationColumn;};We useQItemDelegateas our base class, so that we benefit from the defaultdelegate implementation. We could also have usedQAbstractItemDelegateif wehad wanted to start from scratch. To provide a delegate that can edit data, wemust implementcreateEditor(),setEditorData(), andsetModelData(). We alsoimplementpaint()to change the rendering of the duration column.TrackDelegate::TrackDelegate(int durationColumn, QObject *parent) : QItemDelegate(parent){ this->durationColumn = durationColumn;}ThedurationColumnparameter to the constructor tells the delegate whichcolumn holds the track duration.void TrackDelegate::paint(QPainter *painter,  const QStyleOptionViewItem &option,  const QModelIndex &index) const{ if (index.column() == durationColumn) { int secs = index.model()->data(index, Qt::DisplayRole).toInt(); QString text = QString(\"%1:%2\")  .arg(secs / 60, 2, 10, QChar(’0’))  .arg(secs % 60, 2, 10, QChar(’0’)); QStyleOptionViewItem myOption = option; myOption.displayAlignment = Qt::AlignRight | Qt::AlignVCenter; drawDisplay(painter, myOption, myOption.rect, text); drawFocus(painter, myOption, myOption.rect); } else{ QItemDelegate::paint(painter, option, index); }}Since we want to render the duration in the form “minutes:seconds”, we havereimplemented thepaint()function. Thearg()calls take an integer to renderas a string, how many characters the string should have, the base of theinteger (10 for decimal), and the padding character."},{"pageNumber":265,"pageContent":"Implementing Custom Delegates247To right-align the text, we copy the current style options and overwrite thedefault alignment. We then callQItemDelegate::drawDisplay()to draw the text,followed byQItemDelegate::drawFocus(), which will draw a focus rectangle ifthe item has focus and will do nothing otherwise. UsingdrawDisplay()is veryconvenient, especially when used with our own style options. We could alsodraw using the painter directly.QWidget *TrackDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &option, const QModelIndex &index) const{ if (index.column() == durationColumn) { QTimeEdit *timeEdit = new QTimeEdit(parent); timeEdit->setDisplayFormat(\"mm:ss\"); connect(timeEdit, SIGNAL(editingFinished()), this, SLOT(commitAndCloseEditor())); return timeEdit; } else { return QItemDelegate::createEditor(parent, option, index); }}We only want to control the editing of track durations, leaving the editing oftrack names to the default delegate. We achieve this by checking which col-umn the delegate has been asked to provide an editor for. If it’s the durationcolumn, we create aQTimeEdit, set the display format appropriately, and connectitseditingFinished()signal to ourcommitAndCloseEditor()slot. For any othercolumn, we pass on the edit handling to the default delegate.void TrackDelegate::commitAndCloseEditor(){ QTimeEdit *editor = qobject_cast<QTimeEdit *>(sender()); emit commitData(editor); emit closeEditor(editor);}If the user pressesEnteror moves the focus out of theQTimeEdit(but not if theypressEsc), theeditingFinished()signal is emitted and thecommitAndCloseEdi-tor()slot is called. This slot emits thecommitData()signal to inform the viewthat there is edited data to replace existing data. It also emits thecloseEdi-tor()signal to notify the view that this editor is no longer required, at whichpoint the model will delete it. The editor is retrieved usingQObject::sender(),which returns the object that emitted the signal that triggered the slot. If theuser cancels (by pressingEsc), the view will simply delete the editor.void TrackDelegate::setEditorData(QWidget *editor,  const QModelIndex &index) const{ if (index.column() == durationColumn) { int secs = index.model()->data(index, Qt::DisplayRole).toInt(); QTimeEdit *timeEdit = qobject_cast<QTimeEdit *>(editor); timeEdit->setTime(QTime(0, secs / 60, secs % 60)); } else {"},{"pageNumber":266,"pageContent":"24810. Item View Classes QItemDelegate::setEditorData(editor, index); }}When the user initiates editing, the view callscreateEditor()to create aneditor, and thensetEditorData()to initialize the editor with the item’s currentdata. If the editor is for the duration column, we extract the track’s durationin seconds and set theQTimeEdit’s time to the corresponding number of minutesand seconds; otherwise, we let the default delegate handle the initialization.void TrackDelegate::setModelData(QWidget *editor,  QAbstractItemModel *model,  const QModelIndex &index) const{ if (index.column() == durationColumn) { QTimeEdit *timeEdit = qobject_cast<QTimeEdit *>(editor); QTime time = timeEdit->time(); int secs = (time.minute() * 60) + time.second(); model->setData(index, secs); } else { QItemDelegate::setModelData(editor, model, index); }}If the user completes the edit (for example, by left-clicking outside the editorwidget, or by pressingEnterorTab) rather than canceling it, the model mustbe updated with the editor’s data. If the duration was edited, we extract theminutes and seconds from theQTimeEdit, and set the data to the correspondingnumber of seconds.Although not necessary in this case, it is entirely possible to create a customdelegate that finely controls the editing and rendering of any item in a model.We have chosen to take control of a particular column, but since theQModelIndexis passed to all theQItemDelegatefunctions that we reimplement, we can takecontrol by column, row, rectangular region, parent, or any combination of these,right down to individual items if required.In this chapter, we have presented a broad overview of Qt’s model/viewarchitecture. We have shown how to use the view convenience subclasses, howto use Qt’s predefined models, and how to create custom models and customdelegates. But the model/view architecture is so rich that we have not had thespace to cover all the things it makes possible. For example, we could create acustom view that does not render its items as a list, table, or tree. This is doneby the Chart example located in Qt’sexamples/itemviews/chartdirectory, whichshows a custom view that renders model data in the form of a pie chart.It is also possible to use multiple views to view the same model without any for-mality. Any edits made through one view will be automatically and immediate-ly reflected in the other views. This kind of functionality is particularly usefulfor viewing large data sets where the user may wish to see sections of data thatare logically far apart. The architecture also supports selections: Where two"},{"pageNumber":267,"pageContent":"Implementing Custom Delegates249or more views are using the same model, each view can be set to have its ownindependent selections, or the selections can be shared across the views.Qt’s online documentation provides comprehensive coverage of item viewprogramming and the classes that implement it. Seehttp://doc.trolltech.com/4.1/model-view.htmlfor a list of all the relevant classes, andhttp://doc.trolltech.com/4.1/model-view-programming.htmlfor additional information andlinks to the relevant examples included with Qt."},{"pageNumber":269,"pageContent":"11. Container ClassesuSequential ContainersuAssociative ContainersuGeneric AlgorithmsuStrings, Byte Arrays, and VariantsContainer classes are general-purpose template classes that store items of agiven type in memory. C++already offers many containers as part of the Stan-dard Template Library (STL), which is included in the Standard C++library.Qt provides its own container classes, so for Qt programs we can use both theQt and the STL containers. The main advantages of the Qt containers are thatthey behave the same on all platforms and that they are implicitly shared.Implicit sharing, or “copy on write”, is an optimization that makes it possible topass entire containers as values without any significant performance cost. TheQt containers also feature easy-to-use iterator classes inspired by Java, theycan be streamed usingQDataStream, and they usually result in less code in theexecutable than the corresponding STL containers. Finally, on some hardwareplatforms supported by Qtopia Core (the Qt version for mobile devices), the Qtcontainers are the only ones available.Qt offers both sequential containers such asQVector<T>,QLinkedList<T>, andQList<T>, and associative containers such asQMap<K,T>andQHash<K,T>. Concep-tually, the sequential containers store items one after another, whereas theassociative containers store key–value pairs.Qt also provides generic algorithms that perform operations on arbitrarycontainers. For example, theqSort()algorithm sorts a sequential container,andqBinaryFind()performs a binary search on a sorted sequential container.These algorithms are similar to those offered by the STL.If you are already familiar with the STL containers and have STL available onyour target platforms, you might want to use them instead of, or in addition to,the Qt containers. For more information about the STL classes and functions,a good place to start is SGI’s STL web site:http://www.sgi.com/tech/stl/.In this chapter, we will also look atQString,QByteArray, andQVariant, since theyhave a lot in common with containers.QStringis a 16-bit Unicode string usedthroughout Qt’s API.QByteArrayis an array of 8-bitchars useful for storing rawbinary data.QVariantis a type that can store most C++and Qt value types.251"},{"pageNumber":270,"pageContent":"25211. Container ClassesSequential ContainersAQVector<T>is an array-like data structure that stores its items at adjacentpositions in memory. What distinguishes a vector from a plain C++array isthat a vector knows its own size and can be resized. Appending extra items tothe end of a vector is fairly efficient, while inserting items at the front or in themiddle of a vector can be expensive.01234937.8125.984308.74310.9240.9Figure 11.1.A vector ofdoublesIf we know in advance how many items we are going to need, we can give thevector an initial size when we define it and use the[]operator to assign a valueto the items; otherwise, we must either resize the vector later on or appenditems. Here’s an example where we specify the initial size:QVector<double> vect(3);vect[0] = 1.0;vect[1] = 0.540302;vect[2] = -0.416147;Here’s the same example, this time starting with an empty vector and usingtheappend()function to append items at the end:QVector<double> vect;vect.append(1.0);vect.append(0.540302);vect.append(-0.416147);We can also use the<<operator instead ofappend():vect << 1.0 << 0.540302 << -0.416147;One way to iterate over the vector’s items is to use[]andcount():double sum = 0.0;for (int i = 0; i < vect.count(); ++i) sum += vect[i];Vector entries that are created without being assigned an explicit value areinitialized using the item class’s default constructor. Basic types and pointertypes are initialized to zero.Inserting items at the beginning or in the middle of aQVector<T>, or remov-ing items from these positions, can be inefficient for large vectors. For thisreason, Qt also offersQLinkedList<T>, a data structure that stores its items atnon-adjacent locations in memory. Unlike vectors, linked lists don’t supportrandom access, but they provide “constant time” insertions and removals."},{"pageNumber":271,"pageContent":"Sequential Containers253937.8125.984308.74310.9240.9Figure 11.2.A linked list ofdoublesLinked lists do not provide the[]operator, so iterators must be used to traversetheir items. Iterators are also used to specify the position of items. Forexample, the following code inserts the string “Tote Hosen” between “Clash”and “Ramones”:QLinkedList<QString> list;list.append(\"Clash\"); list.append(\"Ramones\");QLinkedList<QString>::iterator i = list.find(\"Ramones\");list.insert(i, \"Tote Hosen\");We will take a more detailed look at iterators later in this section.TheQList<T>sequential container is an “array-list” that combines the mostimportant benefits ofQVector<T>andQLinkedList<T>in a single class. It sup-ports random access, and its interface is index-based likeQVector’s. Inserting orremoving an item at either end of aQList<T>is very fast, and inserting in themiddle is fast for lists with up to about one thousand items. Unless we wantto perform insertions in the middle of huge lists or need the list’s items to occu-py consecutive addresses in memory,QList<T>is usually the most appropriategeneral-purpose container class to use.TheQStringListclass is a subclass ofQList<QString>that is widely used inQt’s API. In addition to the functions it inherits from its base class, it providessome extra functions that make the class more versatile for string handling.QStringListis discussed in the last section of this chapter (p. 268).QStack<T>andQQueue<T>are two more examples of convenience subclasses.QStack<T>is a vector that providespush(),pop(), andtop().QQueue<T>is a listthat providesenqueue(),dequeue(), andhead().For all the container classes seen so far, the value typeTcan be a basic typelikeintordouble, a pointer type, or a class that has a default constructor (aconstructor that takes no arguments), a copy constructor, and an assignmentoperator. Classes that qualify includeQByteArray,QDateTime,QRegExp,QString,andQVariant. Qt classes that inherit fromQObjectdo not qualify, because theylack a copy constructor and an assignment operator. This is no problem inpractice, since we can simply store pointers toQObjecttypes rather than theobjects themselves.The value typeTcan also be a container, in which case we must remember toseparate consecutive angle brackets with spaces; otherwise, the compiler willchoke on what it thinks is a>>operator. For example:QList<QVector<double> > list;"},{"pageNumber":272,"pageContent":"25411. Container ClassesIn addition to the types just mentioned, a container’s value type can be anycustom class that meets the criteria described earlier. Here is an example ofsuch a class:class Movie{public: Movie(const QString &title = \"\", int duration = 0); void setTitle(const QString &title) { myTitle = title; } QString title() const { return myTitle; } void setDuration(int duration) { myDuration = duration; } QString duration() const { return myDuration; }private: QString myTitle; int myDuration;};The class has a constructor that requires no arguments (although it can takeup to two). It also has a copy constructor and an assignment operator, both im-plicitly provided by C++. For this class, member-by-member copy is sufficient,so there’s no need to implement our own copy constructor and assignment op-erator.Qt provides two categories of iterators for traversing the items stored in a con-tainer: Java-style iterators and STL-style iterators. The Java-style iteratorsare easier to use, whereas the STL-style iterators can be combined with Qt’sand STL’s generic algorithms and are more powerful.For each container class, there are two Java-style iterator types: a read-only iterator and a read-write iterator. The read-only iterator classes areQVectorIterator<T>,QLinkedListIterator<T>, andQListIterator<T>. The cor-responding read-write iterators haveMutablein their name (for example,QMutableVectorIterator<T>). In this discussion, we will concentrate onQList’siterators; the iterators for linked lists and vectors have the same API.ABCDEFigure 11.3.Valid positions for Java-style iteratorsThe first thing to keep in mind when using Java-style iterators is that theydon’t point directly at items. Instead, they can be located before the firstitem, after the last item, or between two items. A typical iteration loop lookslike this:QList<double> list;...QListIterator<double> i(list);while (i.hasNext()) {"},{"pageNumber":273,"pageContent":"Sequential Containers255 do_something(i.next());}The iterator is initialized with the container to traverse. At this point, theiterator is located just before the first item. The call tohasNext()returnstrueif there is an item to the right of the iterator. Thenext()function returnsthe item to the right of the iterator and advances the iterator to the nextvalid position.Iterating backward is similar, except that we must first calltoBack()to positionthe iterator after the last item:QListIterator<double> i(list);i.toBack();while (i.hasPrevious()) { do_something(i.previous());}ThehasPrevious()function returnstrueif there is an item to the left of theiterator;previous()returns the item to the left of the iterator and moves theiterator back by one position. Another way of thinking about thenext()andprevious()iterators is that they return the item that the iterator has justjumped over.ABCDEprevious()previous()next()next()Figure 11.4.Effect ofprevious()andnext()on a Java-style iteratorMutable iterators provide functions to insert, modify, and remove items whileiterating. The following loop removes all the negative numbers from a list:QMutableListIterator<double> i(list);while (i.hasNext()) { if (i.next() < 0.0) i.remove();}Theremove()function always operates on the last item that was jumped over.It also works when iterating backward:QMutableListIterator<double> i(list);i.toBack();while (i.hasPrevious()) { if (i.previous() < 0.0) i.remove();}Similarly, the mutable Java-style iterators provide asetValue()function thatmodifies the last item that was jumped over. Here’s how we would replacenegative numbers with their absolute value:"},{"pageNumber":274,"pageContent":"25611. Container ClassesQMutableListIterator<double> i(list);while (i.hasNext()) { int val = i.next(); if (val < 0.0) i.setValue(-val);}It is also possible to insert an item at the current iterator position by callinginsert(). The iterator is then advanced to point between the new item and thefollowing item.In addition to the Java-style iterators, every sequential container classC<T>has two STL-style iterator types:C<T>::iteratorandC<T>::const_iterator.The difference between the two is thatconst_iteratordoesn’t let us modifythe data.A container’sbegin()function returns an STL-style iterator that refers tothe first item in the container (for example,list[0]), whereasend()returnsan iterator to the “one past the last” item (for example,list[5]for a list ofsize 5). If a container is empty,begin()equalsend(). This can be used to seeif the container has any items, although it is usually more convenient to callisEmpty()for this purpose.ABCDEFbegin()end()Figure 11.5.Valid positions for STL-style iteratorsThe STL-style iterator syntax is modeled after that of C++pointers into anarray. We can use the++and--operators to move to the next or previous item,and the unary*operator to retrieve the current item. ForQVector<T>, theiter-atorandconst_iteratortypes are merely typedefs forT *andconst T *. (This ispossible becauseQVector<T>stores its items in consecutive memory locations.)The following example replaces each value in aQList<double>with its absolutevalue:QList<double>::iterator i = list.begin();while (i != list.end()) { *i = qAbs(*i); ++i;}A few Qt functions return a container. If we want to iterate over the returnvalue of a function using an STL-style iterator, we must take a copy of thecontainer and iterate over the copy. For example, the following code is thecorrect way to iterate over theQList<int>returned byQSplitter::sizes():QList<int> list = splitter->sizes();"},{"pageNumber":275,"pageContent":"Sequential Containers257QList<int>::const_iterator i = list.begin();while (i != list.end()) { do_something(*i); ++i;}The following code is wrong:// WRONGQList<int>::const_iterator i = splitter->sizes().begin();while (i != splitter->sizes().end()) { do_something(*i); ++i;}This is becauseQSplitter::sizes()returns a newQList<int>by value everytime it is called. If we don’t store the return value, C++automatically destroysit before we have even started iterating, leaving us with a dangling iterator.To make matters worse, each time the loop is run,QSplitter::sizes()mustgenerate a new copy of the list because of thesplitter->sizes().end()call.In summary: When using STL-style iterators, always iterate on a copy of acontainer returned by value.With read-only Java-style iterators, we don’t need to take a copy. The iteratortakes a copy for us behind the scenes, ensuring that we always iterate over thedata that the function first returned. For example:QListIterator<int> i(splitter->sizes());while (i.hasNext()) { do_something(i.next());}Copying a container like this sounds expensive, but it isn’t, thanks to anoptimization calledimplicit sharing. This means that copying a Qt container isabout as fast as copying a single pointer. Only if one of the copies is changed isdata actually copied—and this is all handled automatically behind the scenes.For this reason, implicit sharing is sometimes called “copy on write”.The beauty of implicit sharing is that it is an optimization that we don’t needto think about; it simply works, without requiring any programmer interven-tion. At the same time, implicit sharing encourages a clean programming stylewhere objects are returned by value. Consider the following function:QVector<double> sineTable(){ QVector<double> vect(360); for (int i = 0; i < 360; ++i) vect[i] = sin(i / (2 * M_PI)); return vect;}The call to the function looks like this:QVector<double> table = sineTable();"},{"pageNumber":276,"pageContent":"25811. Container ClassesSTL, in comparison, encourages us to pass the vector as a non-const referenceto avoid the copy that takes place when the function’s return value is stored ina variable:using namespace std;void sineTable(vector<double> &vect){ vect.resize(360); for (int i = 0; i < 360; ++i) vect[i] = sin(i / (2 * M_PI));}The call then becomes more tedious to write and less clear to read:vector<double> table;sineTable(table);Qt uses implicit sharing for all of its containers and for many other classes,includingQByteArray,QBrush,QFont,QImage,QPixmap, andQString. This makesthese classes very efficient to pass by value, both as function parameters andas return values.Implicit sharing is a guarantee from Qt that the data won’t be copied if wedon’t modify it. To get the best out of implicit sharing, we can adopt a coupleof new programming habits. One habit is to use theat()function rather thanthe[]operator for read-only access on a (non-const) vector or list. Since Qt’scontainers cannot tell whether[]appears on the left side of an assignment ornot, it assumes the worst and forces a deep copy to occur—whereasat()isn’tallowed on the left side of an assignment.A similar issue arises when we iterate over a container with STL-style itera-tors. Whenever we callbegin()orend()on a non-const container, Qt forces adeep copy to occur if the data is shared. To prevent this inefficiency, the solu-tion is to useconst_iterator,constBegin(), andconstEnd()whenever possible.Qt provides one last method for iterating over items in a sequential contain-er: theforeachloop. It looks like this:QLinkedList<Movie> list;...foreach (Movie movie, list) { if (movie.title() == \"Citizen Kane\") { cout << \"Found Citizen Kane\" << endl; break; }}Theforeachpseudo-keyword is implemented in terms of the standardforloop. At each iteration of the loop, the iteration variable (movie) is set to anew item, starting at the first item in the container and progressing forward.Theforeachloop automatically takes a copy of the container when the loop isentered, and for this reason the loop is not affected if the container is modifiedduring iteration."},{"pageNumber":277,"pageContent":"Sequential Containers259How Implicit Sharing WorksImplicit sharing works automatically behind the scenes, so we don’t haveto do anything in our code to make this optimization happen. But sinceit’s nice to know how things work, we will study an example and see whathappens under the hood. The example usesQString, one of Qt’s manyimplicitly shared classes.QString str1 = \"Humpty\";QString str2 = str1;We setstr1to “Humpty” andstr2to be equal tostr1. At this point, bothQStringobjects point to the same internal data structure in memory. Alongwith the character data, the data structure holds a reference count thatindicates how manyQStrings point to the same data structure. Since bothstr1andstr2point to the same data, the reference count is 2.str2[0] = ’D’;When we modifystr2, it first makes a deep copy of the data, to ensurethatstr1andstr2point to different data structures, and it then appliesthe change to its own copy of the data. The reference count ofstr1’s data(“Humpty”) becomes 1, and the reference count ofstr2’s data (“Dumpty”) isset to 1. A reference count of 1 means that the data isn’t shared.str2.truncate(4);If we modifystr2again, no copying takes place because the reference countofstr2’s data is 1. Thetruncate()function operates directly onstr2’s data,resulting in the string “Dump”. The reference count stays at 1.str1 = str2;When we assignstr2tostr1, the reference count forstr1’s data goes downto 0, which means that noQStringis using the “Humpty” data anymore. Thedata is then freed from memory. BothQStrings point to “Dump”, which nowhas a reference count of 2.Data sharing is often disregarded as an option in multithreaded programs,because of race conditions in the reference counting. With Qt, this is not anissue. Internally, the container classes use assembly language instructionsto perform atomic reference counting. This technology is available to Qtusers through theQSharedDataandQSharedDataPointerclasses.Thebreakandcontinueloop statements are supported. If the body consists ofa single statement, the braces are unnecessary. Just like aforstatement, theiteration variable can be defined outside the loop, like this:QLinkedList<Movie> list;Movie movie;...foreach (movie, list) {"},{"pageNumber":278,"pageContent":"26011. Container Classes if (movie.title() == \"Citizen Kane\") { cout << \"Found Citizen Kane\" << endl; break; }}Defining the iteration variable outside the loop is the only option for containersthat hold data types that contain a comma (for example,QPair<QString,int>).Associative ContainersAn associative container holds an arbitrary number of items of the same type,indexed by a key. Qt provides two main associative container classes:QMap<K,T>andQHash<K,T>.AQMap<K,T>is a data structure that stores key–value pairs in ascending keyorder. This arrangement makes it possible to provide good lookup and insertionperformance, and in-order iteration. Internally,QMap<K,T>is implemented as askip-list.Mexico City22 350 000Seoul22 050 000Tokyo34 000 000Figure 11.6.A map ofQStringtointOne simple way to insert items into a map is to callinsert():QMap<QString, int> map;map.insert(\"eins\", 1);map.insert(\"sieben\", 7);map.insert(\"dreiundzwanzig\", 23);Alternatively, we can simply assign a value to a given key as follows:map[\"eins\"] = 1;map[\"sieben\"] = 7;map[\"dreiundzwanzig\"] = 23;The[]operator can be used for both insertion and retrieval. If[]is used toretrieve a value for a non-existent key in a non-const map, a new item will becreated with the given key and an empty value. To avoid accidentally creatingempty values, we can use thevalue()function to retrieve items instead of[]:int val = map.value(\"dreiundzwanzig\");If the key doesn’t exist, a default value is returned using the value type’sdefault constructor, and no new item is created. For basic and pointer types,"},{"pageNumber":279,"pageContent":"Associative Containers261zero is returned. We can specify another default value as second argument tovalue(), for example:int seconds = map.value(\"delay\", 30);This is equivalent toint seconds = 30;if (map.contains(\"delay\")) seconds = map.value(\"delay\");TheKandTdata types of aQMap<K,T>can be basic data types likeintanddouble,pointer types, or classes that have a default constructor, a copy constructor, andan assignment operator. In addition, theKtype must provide anoperator<()sinceQMap<K,T>uses this operator to store the items in ascending key order.QMap<K,T>has a couple of convenience functions,keys()andvalues(), that areespecially useful when dealing with small data sets. They returnQLists of amap’s keys and values.Maps are normally single-valued: If a new value is assigned to an existing key,the old value is replaced by the new value, ensuring that no two items share thesame key. It is possible to have multiple key–value pairs with the same key byusing theinsertMulti()function or theQMultiMap<K,T>convenience subclass.QMap<K,T>has avalues(const K &)overload that returns aQListof all the valuesfor a given key. For example:QMultiMap<int, QString> multiMap;multiMap.insert(1, \"one\");multiMap.insert(1, \"eins\");multiMap.insert(1, \"uno\");QList<QString> vals = multiMap.values(1);AQHash<K,T>is a data structure that stores key–value pairs in a hash table. Itsinterface is almost identical to that ofQMap<K,T>, but it has different require-ments for theKtemplate type and usually provides much faster lookups thanQMap<K,T>can achieve. Another difference is thatQHash<K,T>is unordered.In addition to the standard requirements on any value type stored in a contain-er, theKtype of aQHash<K,T>needs to provide anoperator==()and be support-ed by a globalqHash()function that returns a hash value for a key. Qt alreadyprovidesqHash()functions for integer types, pointer types,QChar,QString, andQByteArray.QHash<K,T>automatically allocates a prime number of buckets for its internalhash table and resizes this as items are inserted or removed. It is also possibleto fine-tune performance by callingreserve()to specify the number of itemsexpected to be stored in the hash andsqueeze()to shrink the hash table basedon the current number of items. A common idiom is to callreserve()with themaximum number of items we expect, then insert the data, and finally callsqueeze()to minimize memory usage if there were fewer items than expected."},{"pageNumber":280,"pageContent":"26211. Container ClassesHashes are normally single-valued, but multiple values can be assigned to thesame key using theinsertMulti()function or theQMultiHash<K,T>conveniencesubclass.BesidesQHash<K,T>, Qt also provides aQCache<K,T>class that can be used tocache objects associated with a key, and aQSet<K>container that only storeskeys. Internally, both rely onQHash<K,T>and both have the same requirementsfor theKtype asQHash<K,T>.The easiest way to iterate through all the key–value pairs stored in an associa-tive container is to use a Java-style iterator. Because the iterators must giveaccess to both a key and a value, the Java-style iterators for associative con-tainers work slightly differently from their sequential counterparts. The maindifference is that thenext()andprevious()functions return an object that rep-resents a key–value pair, rather than simply a value. The key and value com-ponents are accessible from this object askey()andvalue(). For example:QMap<QString, int> map;...int sum = 0;QMapIterator<QString, int> i(map);while (i.hasNext()) sum += i.next().value();If we need to access both the key and the value, we can simply ignore thereturn value ofnext()orprevious()and use the iterator’skey()andvalue()functions, which operate on the last item that was jumped over:QMapIterator<QString, int> i(map);while (i.hasNext()) { i.next(); if (i.value() > largestValue) { largestKey = i.key(); largestValue = i.value(); }}Mutable iterators have asetValue()function that modifies the value associatedwith the current item:QMutableMapIterator<QString, int> i(map);while (i.hasNext()) { i.next(); if (i.value() < 0.0) i.setValue(-i.value());}STL-style iterators also providekey()andvalue()functions. With the non-const iterator types,value()returns a non-const reference, allowing us tochange the value as we iterate. Note that although these iterators are called“STL-style”, they deviate significantly from the STL’smap<K,T>iterators, whichare based onpair<K,T>."},{"pageNumber":281,"pageContent":"Associative Containers263Theforeachloop also works on associative containers, but only on the valuecomponent of the key–value pairs. If we need both the key and the valuecomponents of the items, we can call thekeys()andvalues(const K &)functionsin nestedforeachloops as follows:QMultiMap<QString, int> map;...foreach (QString key, map.keys()) { foreach (int value, map.values(key)) { do_something(key, value); }}Generic AlgorithmsThe<QtAlgorithms>header declares a set of global template functions thatimplement basic algorithms on containers. Most of these functions operate onSTL-style iterators.The STL<algorithm>header provides a more complete set of generic algo-rithms. These algorithms can be used on Qt containers as well as STL contain-ers. If STL implementations are available on all your platforms, there is prob-ably no reason to avoid using the STL algorithms when Qt lacks an equivalentalgorithm. Here, we will introduce the most important Qt algorithms.TheqFind()algorithm searches for a particular value in a container. It takes a“begin” and an “end” iterator and returns an iterator pointing to the first itemthat matches, or “end” if there is no match. In the following example,iis settolist.begin()+ 1, whereasjis set tolist.end().QStringList list;list << \"Emma\" << \"Karl\" << \"James\" << \"Mariette\";QStringList::iterator i = qFind(list.begin(), list.end(), \"Karl\");QStringList::iterator j = qFind(list.begin(), list.end(), \"Petra\");TheqBinaryFind()algorithm performs a search just likeqFind(), except thatit assumes that the items are sorted in ascending order and uses fast binarysearching rather thanqFind()’s linear searching.TheqFill()algorithm populates a container with a particular value:QLinkedList<int> list(10);qFill(list.begin(), list.end(), 1009);Like the other iterator-based algorithms, we can also useqFill()on a portionof the container by varying the arguments. The following code snippet initial-izes the first five items of a vector to 1009 and the last five items to 2013:QVector<int> vect(10);qFill(vect.begin(), vect.begin() + 5, 1009);qFill(vect.end() - 5, vect.end(), 2013);"},{"pageNumber":282,"pageContent":"26411. Container ClassesTheqCopy()algorithm copies values from one container to another:QVector<int> vect(list.count());qCopy(list.begin(), list.end(), vect.begin());qCopy()can also be used to copy values within the same container, as long asthe source range and the target range don’t overlap. In the next code snippet,we use it to overwrite the last two items of a list with the first two items:qCopy(list.begin(), list.begin() + 2, list.end() - 2);TheqSort()algorithm sorts the container’s items into ascending order:qSort(list.begin(), list.end());By default,qSort()uses the<operator to compare the items. To sort itemsin descending order, passqGreater<T>()as the third argument (whereTis thecontainer’s value type), as follows:qSort(list.begin(), list.end(), qGreater<int>());We can use the third parameter to define custom sort criteria. For example,here’s a “less than” comparison function that comparesQStrings in a case-insensitive way:bool insensitiveLessThan(const QString &str1, const QString &str2){ return str1.toLower() < str2.toLower();}The call toqSort()then becomesQStringList list;...qSort(list.begin(), list.end(), insensitiveLessThan);TheqStableSort()algorithm is similar toqSort(), except it guarantees thatitems that compare equal appear in the same order after the sort as before.This is useful if the sort criterion only takes into account parts of the valueand the results are visible to the user. We usedqStableSort()in Chapter 4 toimplement sorting in the Spreadsheet application (p. 88).TheqDeleteAll()algorithm callsdeleteon every pointer stored in a container.It only makes sense on containers whose value type is a pointer type. After thecall, the items are still presentclear()on the container. For example:qDeleteAll(list);list.clear();TheqSwap()algorithm exchanges the value of two variables. For example:int x1 = line.x1();int x2 = line.x2();if (x1 > x2) qSwap(x1, x2);"},{"pageNumber":283,"pageContent":"Generic Algorithms265Finally, the<QtGlobal>header, which is included by every other Qt header,provides several useful definitions, including theqAbs()function, that returnsthe absolute value of its argument, and theqMin()andqMax()functions, thatreturn the minimum or maximum of two values.Strings, Byte Arrays, and VariantsQString,QByteArray, andQVariantare three classes that have many things incommon with containers and that can be used as alternatives to containers insome contexts. Also, like the containers, these classes use implicit sharing asa memory and speed optimization.We will start withQString. Strings are used by every GUI program, not only forthe user interface but often also as data structures. C++natively provides twokinds of strings: traditional C-style ‘/0’-terminated character arrays and thestd::stringclass. Unlike these,QStringholds 16-bit Unicode values. Unicodecontains ASCII and Latin-1 as a subset, with their usual numeric values.But sinceQStringis 16-bit, it can represent thousands of other characters forwriting most of the world’s languages. See Chapter 17 for more informationabout Unicode.When usingQString, we don’t need to worry about such arcane details as allo-cating enough memory or ensuring that the data is ‘/0’-terminated. Conceptu-ally,QStrings can be thought of as a vector ofQChars. AQStringcan embed ‘/0’characters. Thelength()function returns the size of the entire string, includ-ing embedded ‘/0’ characters.QStringprovides a binary+operator to concatenate two strings and a+=oper-ator to append one string to another. BecauseQStringautomatically preallo-cates memory at the end of the string data, building up a string by repeatedlyappending characters is very fast. Here’s an example that combines+and+=:QString str = \"User: \";str += userName + \"\\n\";There is also aQString::append()function that does the same thing as the+=operator:str = \"User: \";str.append(userName);str.append(\"\\n\");A completely different way of combining strings is to useQString’ssprintf()function:str.sprintf(\"%s %.1f%%\", \"perfect competition\", 100.0);This function supports the same format specifiers as the C++library’ssprintf()function. In the example above,stris assigned “perfect competition 100.0%”.Yet another way of building a string from other strings or from numbers is tousearg():"},{"pageNumber":284,"pageContent":"26611. Container Classesstr = QString(\"%1 %2 (%3s-%4s)\") .arg(\"permissive\").arg(\"society\").arg(1950).arg(1970);In this example, “%1” is replaced by “permissive”, “%2” is replaced by “society”,“%3” is replaced by “1950”, and “%4” is replaced by “1970”. The result is“permissive society (1950s-1970s)”. There arearg()overloads to handle vari-ous data types. Some overloads have extra parameters for controlling the fieldwidth, the numerical base, or the floating-point precision. In general,arg()isa much better solution thansprintf(), because it is type-safe, fully supportsUnicode, and allows translators to reorder the “%n” parameters.QStringcan convert numbers into strings using theQString::number()staticfunction:str = QString::number(59.6);Or using thesetNum()function:str.setNum(59.6);The reverse conversion, from a string to a number, is achieved usingtoInt(),toLongLong(),toDouble(), and so on. For example:bool ok;double d = str.toDouble(&ok);These functions accept an optional pointer to aboolvariable and set thevariable totrueorfalsedepending on the success of the conversion. If theconversion fails, these functions return zero.Once we have a string, we often want to extract parts of it. Themid()functionreturns the substring starting at a given position (the first argument) and ofup to a given length (the second argument). For example, the following codeprints “pays” to the console:HQString str = \"polluter pays principle\";qDebug() << str.mid(9, 4);If we omit the second argument,mid()returns the substring starting at thegiven position and ending at the end of the string. For example, the followingcode prints “pays principle” to the console:QString str = \"polluter pays principle\";qDebug() << str.mid(9);There are alsoleft()andright()functions that perform a similar job. Bothaccept a number of characters,n, and return the first or lastncharactersof the string. For example, the following code prints “polluter principle” tothe console:QString str = \"polluter pays principle\";HThe convenientqDebug() << argsyntax used here requires the inclusion of the<QtDebug>header file,while theqDebug(\"...\", arg)syntax is available in any file that includes at least one Qt header."},{"pageNumber":285,"pageContent":"Strings, Byte Arrays, and Variants267qDebug() << str.left(8) << \" \" << str.right(9);If we want to find out if a string contains a particular character, substring, orregular expression, we can use one ofQString’sindexOf()functions:QString str = \"the middle bit\";int i = str.indexOf(\"middle\");This will setito 4. TheindexOf()function returns+--1 on failure, and accepts anoptional start position and case-sensitivity flag.If we just want to check whether a string starts or ends with something, wecan use thestartsWith()andendsWith()functions:if (url.startsWith(\"http:\") && url.endsWith(\".png\")) ...This is both simpler and faster than this:if (url.left(5) == \"http:\" && url.right(4) == \".png\") ...String comparison with the==operator is case sensitive. If we are comparinguser-visible strings,localeAwareCompare()is usually the right choice, and ifwe want to make the comparisons case-insensitive, we can usetoUpper()ortoLower(). For example:if (fileName.toLower() == \"readme.txt\") ...If we want to replace a certain part of a string by another string, we can usereplace():QString str = \"a cloudy day\";str.replace(2, 6, \"sunny\");The result is “a sunny day”. The code can be rewritten to useremove()andinsert():str.remove(2, 6);str.insert(2, \"sunny\");First, we remove six characters starting at position 2, resulting in the string“a day” (with two spaces), then we insert “sunny” at position 2.There are overloaded versions ofreplace()that replace all occurrences of theirfirst argument with their second argument. For example, here’s how to replaceall occurrences of “&” with “&amp;” in a string:str.replace(\"&\", \"&amp;\");One very frequent need is to strip the whitespace (such as spaces, tabs, andnewlines) from a string.QStringhas a function that eliminates whitespacefrom both ends of a string:QString str = \" BOB \\t THE \\nDOG \\n\";"},{"pageNumber":286,"pageContent":"26811. Container ClassesqDebug() << str.trimmed();Stringstrcan be depicted asBOB\\tTHE\\nDOG\\nThe string returned bytrimmed()isBOB\\tTHE\\nDOGWhen handling user input, we often also want to replace every sequence of oneor more internal whitespace characters with single spaces, in addition to strip-ping whitespace from both ends. This is what thesimplified()function does:QString str = \" BOB \\t THE \\nDOG \\n\";qDebug() << str.simplified();The string returned bysimplified()isBOBTHEDOGA string can be split into aQStringListof substrings usingQString::split():QString str = \"polluter pays principle\";QStringList words = str.split(\" \");In the example above, we split the string “polluter pays principle” into threesubstrings: “polluter”, “pays”, and “principle”. Thesplit()function has anoptional third argument that specifies whether empty substrings should bekept (the default) or discarded.The items in aQStringListcan be joined to form a single string usingjoin().The argument tojoin()is inserted between each pair of joined strings. Forexample, here’s how to create a single string that is composed of all thestrings contained in aQStringListsorted into alphabetical order and separatedby newlines:words.sort();str = words.join(\"\\n\");When dealing with strings, we often need to determine whether a string isempty or not. This is done by callingisEmpty()or by checking whetherlength()is 0.The conversion fromconst char *strings toQStringis automatic in most cases,for example:str += \" (1870)\";Here we add aconst char *to aQStringwithout formality. To explicitly convertaconst char *to aQString, simply use aQStringcast, or callfromAscii()orfromLatin1(). (See Chapter 17 for an explanation of handling literal strings inother encodings.)"},{"pageNumber":287,"pageContent":"Strings, Byte Arrays, and Variants269To convert aQStringto aconst char *, usetoAscii()ortoLatin1(). Thesefunctions return aQByteArray, which can be converted into aconst char *usingQByteArray::data()orQByteArray::constData(). For example:printf(\"User: %s\\n\", str.toAscii().data());For convenience, Qt provides theqPrintable()macro that performs the sameas the sequencetoAscii().constData():printf(\"User: %s\\n\", qPrintable(str));When we calldata()orconstData()on aQByteArray, the returned string isowned by theQByteArrayobject. This means that we don’t need to worry aboutmemory leaks; Qt will reclaim the memory for us. On the other hand, we mustbe careful not to use the pointer for too long. If theQByteArrayis not stored ina variable, it will be automatically deleted at the end of the statement.TheQByteArrayclass has a very similar API toQString. Functions likeleft(),right(),mid(),toLower(),toUpper(),trimmed(), andsimplified()exist inQByteAr-raywith the same semantics as theirQStringcounterparts.QByteArrayis usefulfor storing raw binary data and 8-bit encoded text strings. In general, we rec-ommend usingQStringfor storing text rather thanQByteArraybecauseQStringsupports Unicode.For convenience,QByteArrayautomatically ensures that the “one past the last”byte is always ‘/0’, making it easy to pass aQByteArrayto a function taking aconst char *.QByteArrayalso supports embedded ‘/0’ characters, allowing us touse it to store arbitrary binary data.In some situations, we need to store data of different types in the same vari-able. One approach is to encode the data as aQByteArrayor aQString. For exam-ple, a string could hold a textual value or a numeric value in string form. Theseapproaches give complete flexibility, but do away with some of C++’s benefits,in particular type safety and efficiency. Qt provides a much cleaner way ofhandling variables that can hold different types:QVariant.TheQVariantclass can hold values of many Qt types, includingQBrush,QColor,QCursor,QDateTime,QFont,QKeySequence,QPalette,QPen,QPixmap,QPoint,QRect,QRegion,QSize, andQString, as well as basic C++numeric types likedoubleandint. TheQVariantclass can also hold containers:QMap<QString,QVariant>,QStringList, andQList<QVariant>.Variants are used extensively by the item view classes, the database module,andQSettings, allowing us to read and write item data, database data, anduser preferences for anyQVariant-compatible type. We have already seen anexample of this in Chapter 3, where we passed aQRect, aQStringList, and acouple ofbools as variants toQSettings::setValue(), and retrieved them lateras variants.It is possible to create arbitrarily complex data structures usingQVariantbynesting values of container types:"},{"pageNumber":288,"pageContent":"27011. Container ClassesQMap<QString, QVariant> pearMap;pearMap[\"Standard\"] = 1.95;pearMap[\"Organic\"] = 2.25;QMap<QString, QVariant> fruitMap;fruitMap[\"Orange\"] = 2.10;fruitMap[\"Pineapple\"] = 3.85;fruitMap[\"Pear\"] = pearMap;Here we have created a map with string keys (product names) and values thatare either floating-point numbers (prices) or maps. The top-level map containsthree keys: “Orange”, “Pear”, and “Pineapple”. The value associated with the“Pear” key is a map that contains two keys (“Standard” and “Organic”). Wheniterating over a map that holds variant values, we need to usetype()to checkthe type that a variant holds so that we can respond appropriately.Creating data structures like this can be very seductive since we can organizethe data in any way we like. But the convenience ofQVariantcomes at theexpense of efficiency and readability. As a rule, it is usually worth defining aproper C++class to store our data whenever possible.QVariantis used by Qt’s meta-object system and is therefore part of theQtCoremodule. Nonetheless, when we link against theQtGuimodule,QVariantcanstore GUI-related types such asQColor,QFont,QIcon,QImage, andQPixmap:QIcon icon(\"open.png\");QVariant variant = icon;To retrieve the value of a GUI-related type from aQVariant, we can use theQVariant::value<T>()template member function as follows:QIcon icon = variant.value<QIcon>();Thevalue<T>()function also works for converting between non-GUI data typesandQVariant, but in practice we normally use theto...()conversion functions(for example,toString()) for non-GUI types.QVariantcan also be used to store custom data types, assuming they providea default constructor and a copy constructor. For this to work, we must firstregister the type using theQ_DECLARE_METATYPE()macro, typically in a headerfile below the class definition:qQ_DECLARE_METATYPE(BusinessCard)This enables us to write code like this:BusinessCard businessCard;QVariant variant = QVariant::fromValue(businessCard);...if (variant.canConvert<BusinessCard>()) { BusinessCard card = variant.value<BusinessCard>(); ...}"},{"pageNumber":289,"pageContent":"Strings, Byte Arrays, and Variants271Because of a compiler limitation, these template member functions are notavailable for MSVC 6. If you need to use this compiler, use theqVariantFromVal-ue(),qVariantValue<T>(), andqVariantCanConvert<T>()global functions instead.If the custom data type has<<and>>operators for writing to and readingfrom aQDataStream, we can register them usingqRegisterMetaTypeStreamOpera-tors<T>(). This makes it possible to store preferences of custom data types us-ingQSettings, among other things. For example:qRegisterMetaTypeStreamOperators<BusinessCard>(\"BusinessCard\");This chapter has focused on the Qt containers, as well as onQString,QByteAr-ray, andQVariant. In addition to these classes, Qt also provides a few other con-tainers. One isQPair<T1,T2>, which simply stores two values and is similar tostd::pair<T1,T2>. Another isQBitArray, which we will use in the first sectionof Chapter 19. Finally, there isQVarLengthArray<T,Prealloc>, a low-level alter-native toQVector<T>. Because it preallocates memory on the stack and isn’timplicitly shared, its overhead is less than that ofQVector<T>, making it moreappropriate for tight loops.Qt’s algorithms, including a few not covered here such asqCopyBackward()andqEqual(), are described in Qt’s documentation athttp://doc.trolltech.com/4.1/algorithms.html. And for more details of Qt’s containers, including informationon their time complexity and growth strategies, seehttp://doc.trolltech.com/4.1/containers.html."},{"pageNumber":291,"pageContent":"12. Input/OutputuReading and Writing Binary DatauReading and Writing TextuTraversing DirectoriesuEmbedding ResourcesuInter-Process CommunicationThe need to read from or write to files or other devices is common to almostevery application. Qt provides excellent support for I/O throughQIODevice,a powerful abstraction that encapsulates “devices” capable of reading andwriting blocks of bytes. Qt includes the followingQIODevicesubclasses:QFileAccesses files in the local file system and in embedded resourcesQTemporaryFileCreates and accesses temporary files in the local file systemQBufferReads data from or writes data to aQByteArrayQProcessRuns external programs and handles inter-process communicationQTcpSocketTransfers a stream of data over the network using TCPQUdpSocketSends or receives UDP datagrams over the networkQProcess,QTcpSocket, andQUdpSocketare sequential devices, meaning that thedata can only be accessed once, starting from the first byte and progressingserially to the last byte.QFile,QTemporaryFile, andQBufferare random-accessdevices, so bytes can be read any number of times from any position; theyprovide theQIODevice::seek()function for repositioning the file pointer.In addition to the device classes, Qt also provides two higher-level streamclasses that we can use to read from and write to any I/O device:QDataStreamfor binary data andQTextStreamfor text. These classes take care of issues suchas byte ordering and text encodings, ensuring that Qt applications runningon different platforms or in different countries can read and write each oth-er’s files. This makes Qt’s I/O classes much more convenient than the corre-sponding Standard C++classes, which leave these issues to the application pro-grammer.QFilemakes it easy to access individual files, whether they are in the file sys-tem or embedded in the application’s executable as resources. For applicationsthat need to identify whole sets of files to work on, Qt provides theQDirand273"},{"pageNumber":292,"pageContent":"27412. Input/OutputQFileInfoclasses, which handle directories and provide information about thefiles inside them.TheQProcessclass allows us to launch external programs and to communicatewith them through their standard input, standard output, and standard errorchannels (cin,cout, andcerr). We can set the environment variables and work-ing directory that the external application will use. By default, communicationwith the process is asynchronous (non-blocking), but it is also possible to blockon certain operations.Networking and reading and writing XML are such substantial topics thatthey are covered separately in their own dedicated chapters (Chapter 14 andChapter 15).Reading and Writing Binary DataThe simplest way to load and save binary data with Qt is to instantiate aQFile, to open the file, and to access it through aQDataStreamobject.QDataStreamprovides a platform-independent storage format that supports basic C++typeslikeintanddouble, and many Qt data types, includingQByteArray,QFont,QImage,QPixmap,QString, andQVariant, as well as Qt container classes such asQList<T>andQMap<K,T>.Here’s how we would store an integer, aQImage, and aQMap<QString, QColor>ina file calledfacts.dat:QImage image(\"philip.png\");QMap<QString, QColor> map;map.insert(\"red\", Qt::red);map.insert(\"green\", Qt::green);map.insert(\"blue\", Qt::blue);QFile file(\"facts.dat\");if (!file.open(QIODevice::WriteOnly)) { cerr << \"Cannot open file for writing: \" << qPrintable(file.errorString()) << endl; return;}QDataStream out(&file);out.setVersion(QDataStream::Qt_4_1);out << quint32(0x12345678) << image << map;If we cannot open the file, we inform the user and return. TheqPrintable()macro returns aconst char *for aQString. (Another approach would have beento useQString::toStdString(), which returns astd::string, for which<iostream>has a<<overload.)If the file is opened successfully, we create aQDataStreamand set its versionnumber. The version number is an integer that influences the way Qt data"},{"pageNumber":293,"pageContent":"Reading and Writing Binary Data275types are represented (basic C++data types are always represented the sameway). In Qt 4.1, the most comprehensive format is version 7. We can eitherhard-code the constant 7 or use theQDataStream::Qt_4_1symbolic name.To ensure that the number0x12345678is written as an unsigned 32-bit integeron all platforms, we cast it toquint32, a data type that is guaranteed to be exact-ly 32 bits. To ensure interoperability,QDataStreamstandardizes on big-endianby default; this can be changed by callingsetByteOrder().We don’t need to explicitly close the file since this is done automatically whentheQFilevariable goes out of scope. If we want to verify that the data hasactually been written, we can callflush()and check its return value (trueon success).The code to read back the data mirrors the code we used to write it:quint32 n;QImage image;QMap<QString, QColor> map;QFile file(\"facts.dat\");if (!file.open(QIODevice::ReadOnly)) { cerr << \"Cannot open file for reading: \" << qPrintable(file.errorString()) << endl; return;}QDataStream in(&file);in.setVersion(QDataStream::Qt_4_1);in >> n >> image >> map;TheQDataStreamversion we use for reading is the same as the one we used forwriting. This must always be the case. By hard-coding the version number, weguarantee that the application can always read and write the data (assumingit is compiled with Qt 4.1 or any later Qt version).QDataStreamstores data in such a way that we can read it back seamlessly. Forexample, aQByteArrayis represented as a 32-bit byte count followed by thebytes themselves.QDataStreamcan also be used to read and write raw bytes,without any byte count header, usingreadRawBytes()andwriteRawBytes().Error handling when reading from aQDataStreamis fairly easy. The streamhas astatus()value that can beQDataStream::Ok,QDataStream::ReadPastEnd,orQDataStream::ReadCorruptData. Once an error has occurred, the>>operatoralways reads zero or empty values. This means that we can often simply readan entire file without worrying about potential errors and check thestatus()value at the end to see if what we read was valid.QDataStreamhandles a variety of C++and Qt data types; the complete list isavailable athttp://doc.trolltech.com/4.1/datastreamformat.html. We can alsoadd support for our own custom types by overloading the<<and>>operators.Here’s the definition of a custom data type that can be used withQDataStream:"},{"pageNumber":294,"pageContent":"27612. Input/Outputclass Painting{public: Painting() { myYear = 0; } Painting(const QString &title, const QString &artist, int year) { myTitle = title; myArtist = artist; myYear = year; } void setTitle(const QString &title) { myTitle = title; } QString title() const { return myTitle; } ...private: QString myTitle; QString myArtist; int myYear;};QDataStream &operator<<(QDataStream &out, const Painting &painting);QDataStream &operator>>(QDataStream &in, Painting &painting);Here’s how we would implement the<<operator:QDataStream &operator<<(QDataStream &out, const Painting &painting){ out << painting.title() << painting.artist() << quint32(painting.year()); return out;}To output aPainting, we simply output twoQStrings and aquint32. At the endof the function, we return the stream. This is a common C++idiom that allowsus to use a chain of<<operators with an output stream. For example:out << painting1 << painting2 << painting3;The implementation ofoperator>>()is similar to that ofoperator<<():QDataStream &operator>>(QDataStream &in, Painting &painting){ QString title; QString artist; quint32 year; in >> title >> artist >> year; painting = Painting(title, artist, year); return in;}There are several benefits to providing streaming operators for custom datatypes. One of them is that it allows us to stream containers that use the customtype. For example:QList<Painting> paintings = ...;"},{"pageNumber":295,"pageContent":"Reading and Writing Binary Data277out << paintings;We can read in containers just as easily:QList<Painting> paintings;in >> paintings;This would result in a compiler error ifPaintingdidn’t support<<or>>. An-other benefit of providing streaming operators for custom types is that we canstore values of these types asQVariants, which makes them more widely usable,for example byQSettings. This works provided that we register the type usingqRegisterMetaTypeStreamOperators<T>()beforehand, as explained in Chapter 11(p. 270).When we useQDataStream, Qt takes care of reading and writing each type,including containers with an arbitrary number of items. This relieves us fromthe need to structure what we write and from performing any kind of parsingon what we read. Our only obligation is to ensure that we read all the types inexactly the same order as we wrote them, leaving Qt to handle all the details.QDataStreamis useful both for our own custom application file formats and forstandard binary formats. We can read and write standard binary formatsusing the streaming operators on basic types (likequint16orfloat) or usingreadRawBytes()andwriteRawBytes(). If theQDataStreamis being used purely toread and write basic C++data types, we don’t even need to callsetVersion().So far, we loaded and saved data with the stream’s version hard-coded asQDataStream::Qt_4_1. This approach is simple and safe, but it does have onesmall drawback: We cannot take advantage of new or updated formats. Forexample, if a later version of Qt added a new attribute toQFont(in additionto its point size, family, etc.) and we hard-coded the version number toQt_4_1,that attribute wouldn’t be saved or loaded. There are two solutions. The firstapproach is to embed theQDataStreamversion number in the file:QDataStream out(&file);out << quint32(MagicNumber) << quint16(out.version());(MagicNumberis a constant that uniquely identifies the file type.) This approachensures that we always write the data using the most recent version ofQDataStream, whatever that happens to be. When we come to read the file, weread the stream version:quint32 magic;quint16 streamVersion;QDataStream in(&file);in >> magic >> streamVersion;if (magic != MagicNumber) { cerr << \"File is not recognized by this application\" << endl;} else if (streamVersion > in.version()) { cerr << \"File is from a more recent version of the application\" << endl;"},{"pageNumber":296,"pageContent":"27812. Input/Output return false;}in.setVersion(streamVersion);We can read the data as long as the stream version is less than or equal to theversion used by the application; otherwise, we report an error.If the file format contains a version number of its own, we can use it to deducethe stream version number instead of storing it explicitly. For example, let’ssuppose that the file format is for version 1.3 of our application. We might thenwrite the data as follows:QDataStream out(&file);out.setVersion(QDataStream::Qt_4_1);out << quint32(MagicNumber) << quint16(0x0103);When we read it back, we determine whichQDataStreamversion to use based onthe application’s version number:QDataStream in(&file);in >> magic >> appVersion;if (magic != MagicNumber) { cerr << \"File is not recognized by this application\" << endl; return false;} else if (appVersion > 0x0103) { cerr << \"File is from a more recent version of the application\" << endl; return false;}if (appVersion < 0x0103) { in.setVersion(QDataStream::Qt_3_0);} else { in.setVersion(QDataStream::Qt_4_1);}In this example, we specify that any file saved with versions prior to 1.3 ofthe application uses data stream version 4 (Qt_3_0), and that files saved withversion 1.3 of the application use data stream version 7 (Qt_4_1).In summary, there are three policies for handlingQDataStreamversions: hard-coding the version number, explicitly writing and reading the version number,and using different hard-coded version numbers depending on the applica-tion’s version. Any of these policies can be used to ensure that data written byan old version of an application can be read by a new version, even if the newversion links against a more recent version of Qt. Once we have chosen a policyfor handlingQDataStreamversions, reading and writing binary data using Qt isboth simple and reliable.If we want to read or write a file in one go, we can avoid usingQDataStreamaltogether and instead useQIODevice’swrite()andreadAll()functions. Forexample:"},{"pageNumber":297,"pageContent":"Reading and Writing Binary Data279bool copyFile(const QString &source, const QString &dest){ QFile sourceFile(source); if (!sourceFile.open(QIODevice::ReadOnly)) return false; QFile destFile(dest); if (!destFile.open(QIODevice::WriteOnly)) return false; destFile.write(sourceFile.readAll()); return sourceFile.error() == QFile::NoError && destFile.error() == QFile::NoError;}In the line wherereadAll()is called, the entire contents of the input file is readinto aQByteArray, which is then passed to thewrite()function to be written tothe output file. Having all the data in aQByteArrayrequires more memory thanreading item by item, but it offers some advantages. For example, we can thenuseqCompress()andqUncompress()to compress and uncompress the data.There are other scenarios where accessingQIODevicedirectly is more appropri-ate than usingQDataStream.QIODeviceprovides apeek()function that returnsthe next data bytes without moving the device position as well as anunget-Char()function that “unreads” a byte. This works both for random-access de-vices (such as files) and for sequential devices (such as network sockets). Thereis also aseek()function that sets the device position, for devices that supportrandom access.Binary file formats provide the most versatile and most compact means ofstoring data, andQDataStreammakes accessing binary data easy. In additionto the examples in this section, we have already seen the use ofQDataStreamin Chapter 4 to read and write Spreadsheet files, and we will see it again inChapter 19, where we use it to read and write Windows cursor files.Reading and Writing TextWhile binary file formats are typically more compact than text-based formats,they are not human-readable or human-editable. In cases where this is anissue, we can use text formats instead. Qt provides theQTextStreamclass forreading and writing plain text files and for files using other text formats, suchas HTML, XML, and source code. Handling XML files is covered separately inChapter 15.QTextStreamtakes care of converting between Unicode and the system’s localencoding or any other encoding, and transparently handles the different line-ending conventions used by different operating systems (“/r/n” on Windows,“/n” on Unix and Mac OS X).QTextStreamuses the 16-bitQChartype as its funda-mental unit of data. In addition to characters and strings,QTextStreamsupports"},{"pageNumber":298,"pageContent":"28012. Input/OutputC++’s basic numeric types, which it converts to and from strings. For example,the following code writes “Thomas M. Disch: 334/n” to the filesf-book.txt:QFile file(\"sf-book.txt\");if (!file.open(QIODevice::WriteOnly)) { cerr << \"Cannot open file for writing: \" << qPrintable(file.errorString()) << endl; return;}QTextStream out(&file);out << \"Thomas M. Disch: \" << 334 << endl;Writing text is very easy, but reading text can be challenging, because textualdata (unlike binary data written usingQDataStream) is fundamentally ambigu-ous. Let’s consider the following example:out << \"Norway\" << \"Sweden\";Ifoutis aQTextStream, the data that actually gets written is the string“NorwaySweden”. We can’t really expect the following code to read back thedata correctly:in >> str1 >> str2;In fact, what happens is thatstr1gets the whole word “NorwaySweden”, andstr2gets nothing. This problem doesn’t occur withQDataStreambecause itstores the length of each string in front of the character data.For complex file formats, a full-blown parser might be required. Such a parsermight work by reading the data character-by-character using>>on aQChar, orline by line usingQTextStream::readLine(). At the end of this section, we presenttwo small examples, one that reads an input file line by line, and another thatreads it character by character. For parsers that work on an entire text, wecould read the complete file in one go usingQTextStream::readAll()if we are notconcerned about memory usage, or if we know the file will be small.By default,QTextStreamuses the system’s local encoding (for example,ISO 8859-1 or ISO 8859-15 in America and much of Europe) for reading andwriting. This can be changed usingsetCodec()as follows:stream.setCodec(\"UTF-8\");The UTF-8 encoding used in the example is a popular ASCII-compatible encod-ing that can represent the entire Unicode character set. For more informationabout Unicode andQTextStream’s support for encodings, see Chapter 17 (Inter-nationalization).QTextStreamhas various options modeled after those offered by<iostream>.These can be set by passing special objects, calledstream manipulators, onthe stream to alter its state. The following example sets theshowbase,upper-casedigits, andhexoptions before it outputs the integer 12345678, producingthe text “0xBC614E”:"},{"pageNumber":299,"pageContent":"Reading and Writing Text281out << showbase << uppercasedigits << hex << 12345678;Options can also be set using member functions:out.setNumberFlags(QTextStream::ShowBase | QTextStream::UppercaseDigits);out.setIntegerBase(16);out << 12345678;setIntegerBase(int) 0Auto-detect based on prefix (when reading) 2Binary 8Octal10Decimal16HexadecimalsetNumberFlags(NumberFlags)ShowBaseShow a prefix if the base is 2 (“0b”), 8 (“0”), or 16 (“0x”)ForceSignAlways show the sign in real numbersForcePointAlways put the decimal separator in numbersUppercaseBaseUse uppercase versions of base prefixes (“0X”, “0B”)UppercaseDigitsUse uppercase letters in hexadecimal numberssetRealNumberNotation(RealNumberNotation)FixedNotationFixed-point notation (e.g., “0.000123”)ScientificNotationScientific notation (e.g., “1.234568e-04”)SmartNotationFixed-point or scientific notation, whichever is most compactsetRealNumberPrecision(int)Sets the maximum number of digits that should be generated (6 by default)setFieldWidth(int)Sets the minimum size of a field (0 by default)setFieldAlignment(FieldAlignment)AlignLeftPad on the right side of the fieldAlignRightPad on the left side of the fieldAlignCenterPad on both sides of the fieldAlignAccountingStylePad between the sign and the numbersetPadChar(QChar)Sets the character used for padding fields (space by default)Figure 12.1.Functions to setQTextStream’s options"},{"pageNumber":300,"pageContent":"28212. Input/OutputLikeQDataStream,QTextStreamoperates on aQIODevicesubclass, which can beaQFile, aQTemporaryFile, aQBuffer, aQProcess, aQTcpSocket, or aQUdpSocket. Inaddition, it can be used directly on aQString. For example:QString str;QTextStream(&str) << oct << 31 << \" \" << dec << 25 << endl;This makes the contents ofstr“37 25/n”, since the decimal number 31 isexpressed as 37 in octal. In this case, we don’t need to set an encoding on thestream, sinceQStringis always Unicode.Let’s look at a simple example of a text-based file format. In the Spreadsheetapplication described in Part I, we used a binary format for storing Spread-sheet data. The data consisted of a sequence of (row,column,formula) triples,one for every non-empty cell. Writing the data as text is straightforward; hereis an extract from a revised version ofSpreadsheet::writeFile():QTextStream out(&file);for (int row = 0; row < RowCount; ++row) { for (int column = 0; column < ColumnCount; ++column) { QString str = formula(row, column); if (!str.isEmpty()) out << row << \" \" << column << \" \" << str << endl; }}We have used a simple format, with each line representing one cell and withspaces between the row and the column and between the column and theformula. The formula can contain spaces, but we can assume that it containsno ‘/n’ (which we use to terminate lines). Now let’s look at the correspondingreading code:QTextStream in(&file);while (!in.atEnd()) { QString line = in.readLine(); QStringList fields = line.split(’ ’); if (fields.size() >= 3) { int row = fields.takeFirst().toInt(); int column = fields.takeFirst().toInt(); setFormula(row, column, fields.join(’ ’)); }}We read in the Spreadsheet data one line at a time. ThereadLine()functionremoves the trailing ‘/n’.QString::split()returns a string list, having split itsstring wherever the separator it is given appears. For example, the line “5 19Total value” results in the four-item list [“5”, “19”, “Total”, “value”].If we have at least three fields, we are ready to extract the data. TheQString-List::takeFirst()function removes the first item in a list and returns theremoved item. We use it to extract the row and column numbers. We don’tperform any error checking; if we read a non-integer row or column value,"},{"pageNumber":301,"pageContent":"Reading and Writing Text283QString::toInt()will return 0. When we callsetFormula(), we must concatenatethe remaining fields back into a single string.In our secondQTextStreamexample, we will use a character by characterapproach to implement a program that reads in a text file and outputs thesame text but with trailing spaces removed from lines and all tabs replaced byspaces. The program’s work is done by thetidyFile()function:void tidyFile(QIODevice *inDevice, QIODevice *outDevice){ QTextStream in(inDevice); QTextStream out(outDevice); const int TabSize = 8; int endlCount = 0; int spaceCount = 0; int column = 0; QChar ch; while (!in.atEnd()) { in >> ch; if (ch == ’\\n’) { ++endlCount; spaceCount = 0; column = 0; } else if (ch == ’\\t’) { int size = TabSize - (column % TabSize); spaceCount += size; column += size; } else if (ch == ’ ’) { ++spaceCount; ++column; } else { while (endlCount > 0) { out << endl; --endlCount; column = 0; } while (spaceCount > 0) { out << ’ ’; --spaceCount; ++column; } out << ch; ++column; } } out << endl;}We create an input and an outputQTextStreambased on theQIODevices thatare passed to the function. We maintain three elements of state: one countingnewlines, one counting spaces, and one marking the current column positionin the current line (for converting the tabs to the correct number of spaces)."},{"pageNumber":302,"pageContent":"28412. Input/OutputThe parsing is done in awhileloop that iterates over every character in the in-put file, one at a time. The code is a bit subtle in places. For example, althoughwe setTabSizeto 8, we replace tabs with precisely enough spaces to pad to thenext tab boundary, rather than crudely replacing each tab with eight spaces.If we get a newline, tab, or space, we simply update the state data. Only whenwe get another kind of character do we produce any output, and before writingthe character we write any pending newlines and spaces (to respect blank linesand to preserve indentation) and update the state.int main(){ QFile inFile; QFile outFile; inFile.open(stdin, QFile::ReadOnly); outFile.open(stdout, QFile::WriteOnly); tidyFile(&inFile, &outFile); return 0;}For this example, we don’t need aQApplicationobject, because we are onlyusing Qt’s tool classes. Seehttp://doc.trolltech.com/4.1/tools.htmlfor thelist of all tool classes. We have assumed that the program is used as a filter,for example:tidy < cool.cpp > cooler.cppIt would be easy to extend it to be able to handle file names given on thecommand line if they are given, and to filtercintocoutotherwise.Since this is a console application, it has a slightly different.profile from thosewe have seen for GUI applications:TEMPLATE = appQT = coreCONFIG += consoleCONFIG -= app_bundleSOURCES = tidy.cppWe only link againstQtCoresince we don’t use any GUI functionality. Then wespecify that we want to enable console output on Windows and that we don’twant the application to live in a bundle on Mac OS X.For reading and writing plain ASCII files or ISO 8859-1 (Latin-1) files, it ispossible to useQIODevice’s API directly instead of using aQTextStream. It israrely wise to do this since most applications need support for other encodingsat some point or other, and onlyQTextStreamprovides seamless support forthese. If you still want to write text directly to aQIODevice, you must explicitlyspecify theQIODevice::Textflag to theopen()function, for example:file.open(QIODevice::WriteOnly | QIODevice::Text);"},{"pageNumber":303,"pageContent":"Reading and Writing Text285When writing, this flag tellsQIODeviceto convert ‘/n’ characters into “/r/n”sequences on Windows. When reading, this flag tells the device to ignore ‘/r’characters on all platforms. We can then assume that the end of each line issignified with a ‘/n’ newline character regardless of the line-ending conventionused by the operating system.Traversing DirectoriesTheQDirclass provides a platform-independent means of traversing directoriesand retrieving information about files. To see howQDiris used, we will write asmall console application that calculates the space consumed by all the imagesin a particular directory and all its subdirectories to any depth.The heart of the application is theimageSpace()function, which recursivelycomputes the cumulative size of a given directory’s images:qlonglong imageSpace(const QString &path){ QDir dir(path); qlonglong size = 0; QStringList filters; foreach (QByteArray format, QImageReader::supportedImageFormats()) filters += \"*.\" + format; foreach (QString file, dir.entryList(filters, QDir::Files)) size += QFileInfo(dir, file).size(); foreach (QString subDir, dir.entryList(QDir::Dirs  | QDir::NoDotAndDotDot)) size += imageSpace(path + QDir::separator() + subDir); return size;}We begin by creating aQDirobject using the given path, which may be relativeto the current directory or absolute. We pass theentryList()function twoarguments. The first is a list of file name filters. These can contain ‘∗’ and‘?’ wildcard characters. In this example, we are filtering to include only fileformats thatQImagecan read. The second argument specifies what kind ofentries we want (normal files, directories, drives, etc.).We iterate over the list of files, accumulating their sizes. TheQFileInfoclassallows us to access a file’s attributes, such as the file’s size, permissions, owner,and timestamps.The secondentryList()call retrieves all the subdirectories in this directory.We iterate over them (excluding.and..) and recursively callimageSpace()toascertain their accumulated image sizes.To create each subdirectory’s path, we combine the current directory’s pathwith the subdirectory name, separating them with a slash.QDirtreats ‘/’ as a"},{"pageNumber":304,"pageContent":"28612. Input/Outputdirectory separator on all platforms, in addition to recognizing ‘/’ on Windows.When presenting paths to the user, we can call the static functionQDir::con-vertSeparators()to convert slashes to the correct platform-specific separator.Let’s add amain()function to our small program:int main(int argc, char *argv[]){ QCoreApplication app(argc, argv); QStringList args = app.arguments(); QString path = QDir::currentPath(); if (args.count() > 1) path = args[1]; cout << \"Space used by images in \" << qPrintable(path) << \" and its subdirectories is \" << (imageSpace(path) / 1024) << \" KB\" << endl; return 0;}We useQDir::currentPath()to initialize the path to the current directory.Alternatively, we could have usedQDir::homePath()to initialize it to the user’shome directory. If the user has specified a path on the command line, we usethat instead. Finally, we call ourimageSpace()function to calculate how muchspace is consumed by images.TheQDirclass provides other file- and directory-related functions, includingentryInfoList()(which returns a list ofQFileInfoobjects),rename(),exists(),mkdir(), andrmdir(). TheQFileclass provides some static convenience func-tions, includingremove()andexists().Embedding ResourcesSo far in this chapter we have talked about accessing data in external devices,but with Qt it is also possible to embed binary data or text inside the applica-tion’s executable. This is achieved using Qt’s resource system. In other chap-ters, we used resource files to embed images in the executable, but it is possibleto embed any kind of file. Embedded files can be read usingQFilejust like nor-mal files in the file system.Resources are converted into C++code byrcc, Qt’s resource compiler. We cantellqmaketo include special rules to runrccby adding this line to the.profile:RESOURCES = myresourcefile.qrcThemyresourcefile.qrcfile is an XML file that lists the files to embed inthe executable.Let’s imagine that we are writing an application that keeps contact details. Forthe convenience of our users, we want to embed the international dialing codes"},{"pageNumber":305,"pageContent":"Embedding Resources287in the executable. If the file is in thedatafilesdirectory in the application’sbuild directory, the resource file might look like this:<!DOCTYPE RCC><RCC version=\"1.0\"><qresource> <file>datafiles/phone-codes.dat</file></qresource></RCC>From the application, resources are identified by the:/path prefix. In thisexample, the dialing codes file has the path:/datafiles/phone-codes.datandcan be read just like any other file usingQFile.Embedding data in the executable has the advantage that it cannot get lostand makes it possible to create truly stand-alone executables (if static linkingis also used). Two disadvantages are that if the embedded data needs changingthe whole executable must be replaced, and the size of the executable will belarger because it must accommodate the embedded data.Qt’s resource system provides more features than we presented in this example,including support for file name aliases and for localization. These facilities aredocumented athttp://doc.trolltech.com/4.1/resources.html.Inter-Process CommunicationTheQProcessclass allows us to run external programs and to interact withthem. The class works asynchronously, doing its work in the background sothat the user interface remains responsive.QProcessemits signals to notify uswhen the external process has data or has finished.We will review the code of a small application that provides a user interface foran external image conversion program. For this example, we rely on the Im-ageMagickconvertprogram, which is freely available for all major platforms.Figure 12.2.The Image Converter application"},{"pageNumber":306,"pageContent":"28812. Input/OutputThe user interface was created inQt Designer. The.uifile is on the CD thataccompanies this book. Here, we will focus on the subclass that inherits fromtheuic-generatedUi::ConvertDialogclass, starting with the header:#ifndef CONVERTDIALOG_H#define CONVERTDIALOG_H#include <QDialog>#include <QProcess>#include \"ui_convertdialog.h\"class ConvertDialog : public QDialog, public Ui::ConvertDialog{ Q_OBJECTpublic: ConvertDialog(QWidget *parent = 0);private slots: void on_browseButton_clicked(); void on_convertButton_clicked(); void updateOutputTextEdit(); void processFinished(int exitCode, QProcess::ExitStatus exitStatus); void processError(QProcess::ProcessError error);private: QProcess process; QString targetFile;};#endifThe header follows the familiar pattern for subclasses ofQt Designerforms.Thanks toQt Designer’s automatic connection mechanism (p. 28), theon_browseButton_clicked()andon_convertButton_clicked()slots are automaticallyconnected to theBrowseandConvertbuttons’clicked()signals.ConvertDialog::ConvertDialog(QWidget *parent) : QDialog(parent){ setupUi(this); connect(&process, SIGNAL(readyReadStandardError()), this, SLOT(updateOutputTextEdit())); connect(&process, SIGNAL(finished(int, QProcess::ExitStatus)), this, SLOT(processFinished(int, QProcess::ExitStatus))); connect(&process, SIGNAL(error(QProcess::ProcessError)), this, SLOT(processError(QProcess::ProcessError)));}ThesetupUi()call creates and lays out all the form’s widgets, establishes thesignal–slot connections for theon_objectName_signalName()slots, and connectstheQuitbutton toQDialog::accept(). After that, we manually connect threesignals from theQProcessobject to three private slots. Whenever the externalprocess has data on itscerr, we will handle it inupdateOutputTextEdit()."},{"pageNumber":307,"pageContent":"Inter-Process Communication289void ConvertDialog::on_browseButton_clicked(){ QString initialName = sourceFileEdit->text(); if (initialName.isEmpty()) initialName = QDir::homePath(); QString fileName = QFileDialog::getOpenFileName(this, tr(\"Choose File\"),  initialName); fileName = QDir::convertSeparators(fileName); if (!fileName.isEmpty()) { sourceFileEdit->setText(fileName); convertButton->setEnabled(true); }}TheBrowsebutton’sclicked()signal is automatically connected to theon_browseButton_clicked()slot bysetupUi(). If the user has previously selecteda file, we initialize the file dialog with that file’s name; otherwise, we use theuser’s home directory.void ConvertDialog::on_convertButton_clicked(){ QString sourceFile = sourceFileEdit->text(); targetFile = QFileInfo(sourceFile).path() + QDir::separator() + QFileInfo(sourceFile).baseName() + \".\" + targetFormatComboBox->currentText().toLower(); convertButton->setEnabled(false); outputTextEdit->clear(); QStringList args; if (enhanceCheckBox->isChecked()) args << \"-enhance\"; if (monochromeCheckBox->isChecked()) args << \"-monochrome\"; args << sourceFile << targetFile; process.start(\"convert\", args);}When the user clicks theConvertbutton, we copy the source file’s name andchange the extension to match the target file format. We use the platform-specific directory separator (‘/’ or ‘/’, available asQDir::separator()) instead ofhard-coding slashes because the file name will be visible to the user.We then disable theConvertbutton to avoid the user accidentally launchingmultiple conversions, and we clear the text edit that we use to show status in-formation.To initiate the external process, we callQProcess::start()with the name of theprogram we want to run (convert) and any arguments it requires. In this casewe pass the-enhanceand-monochromeflags if the user checked the appropriateoptions, followed by the source and target file names. Theconvertprograminfers the required conversion from the file extensions."},{"pageNumber":308,"pageContent":"29012. Input/Outputvoid ConvertDialog::updateOutputTextEdit(){ QByteArray newData = process.readAllStandardError(); QString text = outputTextEdit->toPlainText() + QString::fromLocal8Bit(newData); outputTextEdit->setPlainText(text);}Whenever the external process writes tocerr, theupdateOutputTextEdit()slotis called. We read the error text and add it to theQTextEdit’s existing text.void ConvertDialog::processFinished(int exitCode,  QProcess::ExitStatus exitStatus){ if (exitStatus == QProcess::CrashExit) { outputTextEdit->append(tr(\"Conversion program crashed\")); } else if (exitCode != 0) { outputTextEdit->append(tr(\"Conversion failed\")); } else { outputTextEdit->append(tr(\"File %1 created\").arg(targetFile)); } convertButton->setEnabled(true);}When the process has finished, we let the user know the outcome and enabletheConvertbutton.void ConvertDialog::processError(QProcess::ProcessError error){ if (error == QProcess::FailedToStart) { outputTextEdit->append(tr(\"Conversion program not found\")); convertButton->setEnabled(true); }}If the process cannot be started,QProcessemitserror()instead offinished().We report any error and enable theClickbutton.In this example, we have performed the file conversions asynchronously—thatis, we have toldQProcessto run theconvertprogram and to return control tothe application immediately. This keeps the user interface responsive whilethe processing occurs in the background. But in some situations we need theexternal process to complete before we can go any further in our application,and in such cases we needQProcessto operate synchronously.One common example where synchronous behavior is desirable is for applica-tions that support plain text editing using the user’s preferred text editor. Thisis straightforward to implement usingQProcess. For example, let’s assume thatwe have the plain text in aQTextEdit, and provide anEditbutton that the usercan click, connected to anedit()slot.void ExternalEditor::edit(){ QTemporaryFile outFile;"},{"pageNumber":309,"pageContent":"Inter-Process Communication291 if (!outFile.open()) return; QString fileName = outFile.fileName(); QTextStream out(&outFile); out << textEdit->toPlainText(); outFile.close(); QProcess::execute(editor, QStringList() << options << fileName); QFile inFile(fileName); if (!inFile.open(QIODevice::ReadOnly)) return; QTextStream in(&inFile); textEdit->setPlainText(in.readAll());}We useQTemporaryFileto create an empty file with a unique name. We don’tspecify any arguments toQTemporaryFile::open()since it conveniently defaultsto opening in read/write mode. We write the contents of the text edit to thetemporary file, and then we close the file because some text editors cannotwork on already open files.TheQProcess::execute()static function runs an external process and blocksuntil the process has finished. Theeditorargument is aQStringholding thename of an editor executable (for example, “gvim”). Theoptionsargument is aQStringList(containing one item, “-f ”, if we are usinggvim).After the user has closed the text editor, the process finishes and theexecute()call returns. We then open the temporary file and read its contents into theQTextEdit.QTemporaryFileautomatically deletes the temporary file when theobject goes out of scope.Signal–slot connections are not needed whenQProcessis used synchronously.If finer control is required than provided by the staticexecute()function, wecan use an alternative approach. This involves creating aQProcessobject andcallingstart()on it, and then forcing it to block by callingQProcess::waitFor-Started(), and if that is successful, callingQProcess::waitForFinished(). See theQProcessreference documentation for an example that uses this approach.In this section, we usedQProcessto give us access to preexisting functionality.Using applications that already exist can save development time and caninsulate us from the details of issues that are of marginal interest to our mainapplication’s purpose. Another way to access preexisting functionality is tolink against a library that provides it. But where no suitable library exists,wrapping a console application usingQProcesscan work well.Another use ofQProcessis to launch other GUI applications, such as a webbrowser or an email client. However, if our aim is communication betweenapplications rather than simply running one from another, we might be betteroff having them communicate directly, using Qt’s networking classes or theActiveQt extension on Windows."},{"pageNumber":311,"pageContent":"13. DatabasesuConnecting and QueryinguPresenting Data in Tabular FormuImplementing Master–Detail FormsTheQtSqlmodule provides a platform- and database-independent interfacefor accessing SQL databases. This interface is supported by a set of classesthat use Qt’s model/view architecture to provide database integration with theuser interface. This chapter assumes familiarity with Qt’s model/view classes,covered in Chapter 10.A database connection is represented by aQSqlDatabaseobject. Qt uses driversto communicate with the various database APIs. The Qt Desktop Editionincludes the following drivers:DriverDatabaseQDB2IBM DB2 version 7.1and laterQIBASEBorland InterBaseQMYSQLMySQLQOCIOracle (Oracle Call Interface)QODBCODBC (includes Microsoft SQL Server)QPSQLPostgreSQL versions 6.x and 7.xQSQLITESQLite version 3 and laterQSQLITE2SQLite version 2QTDSSybase Adaptive ServerDue to license restrictions, not all of the drivers are provided with the Qt OpenSource Edition. When configuring Qt, we can choose between including theSQL drivers inside Qt itself and building them as plugins. Qt is supplied withthe SQLite database, a public domain in-process database.For users who are comfortable with SQL syntax, theQSqlQueryclass providesa means of directly executing arbitrary SQL statements and handling theirresults. For users who prefer a higher-level database interface that avoidsSQL syntax,QSqlTableModelandQSqlRelationalTableModelprovide suitableabstractions. These classes represent an SQL table in the same way as Qt’sother model classes (covered in Chapter 10). They can be used stand-alone to293"},{"pageNumber":312,"pageContent":"29413. Databasestraverse and edit data in code, or they can be attached to views through whichend-users can view and edit the data themselves.Qt also makes it straightforward to program the common database idioms,such as master–detail and drill-down, as some of the examples in this chapterwill demonstrate.Connecting and QueryingTo execute SQL queries, we must first establish a connection with a database.Typically, database connections are set up in a separate function that we callat application startup. For example:bool createConnection(){ QSqlDatabase db = QSqlDatabase::addDatabase(\"QMYSQL\"); db.setHostName(\"mozart.konkordia.edu\"); db.setDatabaseName(\"musicdb\"); db.setUserName(\"gbatstone\"); db.setPassword(\"T17aV44\"); if (!db.open()) { QMessageBox::critical(0, QObject::tr(\"Database Error\"),  db.lastError().text()); return false; } return true;}First, we callQSqlDatabase::addDatabase()to create aQSqlDatabaseobject. Thefirst argument toaddDatabase()specifies which database driver Qt must use toaccess the database. In this case, we use MySQL.Next, we set the database host name, the database name, the user name,and the password, and we open the connection. Ifopen()fails, we show anerror message.Typically, we would callcreateConnection()inmain():int main(int argc, char *argv[]){ QApplication app(argc, argv); if (!createConnection()) return 1;••• return app.exec();}Once a connection is established, we can useQSqlQueryto execute any SQLstatement that the underlying database supports. For example, here’s how toexecute aSELECTstatement:QSqlQuery query;query.exec(\"SELECT title, year FROM cd WHERE year >= 1998\");"},{"pageNumber":313,"pageContent":"Connecting and Querying295After theexec()call, we can navigate through the query’s result set:while (query.next()) { QString title = query.value(0).toString(); int year = query.value(1).toInt(); cerr << qPrintable(title) << \": \" << year << endl;}We callnext()once to position theQSqlQueryon thefirstrecord of the result set.Subsequent calls tonext()advance the record pointer by one record each time,until the end is reached, at which pointnext()returnsfalse. If the result set isempty (or if the query failed), the first call tonext()will returnfalse.Thevalue()function returns the value of a field as aQVariant. The fields arenumbered from 0 in the order given in theSELECTstatement. TheQVariantclasscan hold many C++and Qt types, includingintandQString. The different typesof data that can be stored in a database are mapped into the correspondingC++and Qt types and stored inQVariants. For example, aVARCHARis representedas aQStringand aDATETIMEas aQDateTime.QSqlQueryprovides some other functions to navigate through the result set:first(),last(),previous(), andseek(). These functions are convenient, but forsome databases they can be slower and more memory-hungry thannext(). Foran easy optimization when operating on large data sets, we can callQSqlQuery::setForwardOnly(true)before callingexec(), and then only usenext()for navigat-ing the result set.Earlier we specified the SQL query as an argument toQSqlQuery::exec(), butwe can also pass it directly to the constructor, which executes it immediately:QSqlQuery query(\"SELECT title, year FROM cd WHERE year >= 1998\");We can check for an error by callingisActive()on the query:if (!query.isActive()) QMessageBox::warning(this, tr(\"Database Error\"),  query.lastError().text());If no error occurs, the query will become “active” and we can usenext()tonavigate through the result set.Doing anINSERTis almost as easy as performing aSELECT:QSqlQuery query(\"INSERT INTO cd (id, artistid, title, year) \" \"VALUES (203, 102, ’Living in America’, 2002)\");After this,numRowsAffected()returns the number of rows that were affected bythe SQL statement (or+--1 on error).If we need to insert a lot of records, or if we want to avoid converting values tostrings (and escaping them correctly), we can useprepare()to specify a querythat contains placeholders and then bind the values we want to insert. Qt sup-ports both the Oracle-style and the ODBC-style syntax for placeholders for alldatabases, using native support where it is available and simulating it other-"},{"pageNumber":314,"pageContent":"29613. Databaseswise. Here’s an example that uses the Oracle-style syntax with named place-holders:QSqlQuery query;query.prepare(\"INSERT INTO cd (id, artistid, title, year) \" \"VALUES (:id, :artistid, :title, :year)\");query.bindValue(\":id\", 203);query.bindValue(\":artistid\", 102);query.bindValue(\":title\", \"Living in America\");query.bindValue(\":year\", 2002);query.exec();Here’s the same example using ODBC-style positional placeholders:QSqlQuery query;query.prepare(\"INSERT INTO cd (id, artistid, title, year) \" \"VALUES (?, ?, ?, ?)\");query.addBindValue(203);query.addBindValue(102);query.addBindValue(\"Living in America\");query.addBindValue(2002);query.exec();After the call toexec(), we can callbindValue()oraddBindValue()to bind newvalues, then callexec()again to execute the query with the new values.Placeholders are often used to specify binary data or strings that contain non-ASCII or non-Latin-1 characters. Behind the scenes, Qt uses Unicode withthose databases that support Unicode, and for those that don’t, Qt transparent-ly converts strings to the appropriate encoding.Qt supports SQL transactions on databases where they are available. To starta transaction, we calltransaction()on theQSqlDatabaseobject that representsthe database connection. To finish the transaction, we call eithercommit()orrollback(). For example, here’s how we would look up a foreign key and executeanINSERTstatement inside a transaction:QSqlDatabase::database().transaction();QSqlQuery query;query.exec(\"SELECT id FROM artist WHERE name = ’Gluecifer’\");if (query.next()) { int artistId = query.value(0).toInt(); query.exec(\"INSERT INTO cd (id, artistid, title, year) \" \"VALUES (201, \" + QString::number(artistId) + \", ’Riding the Tiger’, 1997)\");}QSqlDatabase::database().commit();TheQSqlDatabase::database()function returns aQSqlDatabaseobject represent-ing the connection we created increateConnection(). If a transaction cannot bestarted,QSqlDatabase::transaction()returnsfalse. Some databases don’t sup-port transactions. For those, thetransaction(),commit(), androllback()func-tions do nothing. We can test whether a database supports transactions usinghasFeature()on theQSqlDriverassociated with the database:"},{"pageNumber":315,"pageContent":"Connecting and Querying297QSqlDriver *driver = QSqlDatabase::database().driver();if (driver->hasFeature(QSqlDriver::Transactions))•••Several other database features can be tested for, including whether thedatabase supports BLOBs (Binary Large Objects), Unicode, and preparedqueries.In the examples so far, we have assumed that the application is using a singledatabase connection. If we want to create multiple connections, we can pass aname as second argument toaddDatabase(). For example:QSqlDatabase db = QSqlDatabase::addDatabase(\"QPSQL\", \"OTHER\");db.setHostName(\"saturn.mcmanamy.edu\");db.setDatabaseName(\"starsdb\");db.setUserName(\"hilbert\");db.setPassword(\"ixtapa7\");We can then retrieve a pointer to theQSqlDatabaseobject by passing the nametoQSqlDatabase::database():QSqlDatabase db = QSqlDatabase::database(\"OTHER\");To execute queries using the other connection, we pass theQSqlDatabaseobjectto theQSqlQueryconstructor:QSqlQuery query(db);query.exec(\"SELECT id FROM artist WHERE name = ’Mando Diao’\");Multiple connections are useful if we want to perform more than onetransaction at a time, since each connection can only handle a single activetransaction. When we use multiple database connections, we can still haveone unnamed connection, andQSqlQuerywill use that connection if none is spec-ified.In addition toQSqlQuery, Qt provides theQSqlTableModelclass as a higher-levelinterface, allowing us to avoid using raw SQL for performing the most commonSQL operations (SELECT,INSERT,UPDATE, andDELETE). The class can be usedstand-alone to manipulate a database without any GUI involvement, or it canbe used as a data source forQListVieworQTableView.Here’s an example that usesQSqlTableModelto perform aSELECT:QSqlTableModel model;model.setTable(\"cd\");model.setFilter(\"year >= 1998\");model.select();This is equivalent to the querySELECT * FROM cd WHERE year >= 1998Navigating through the result set is done by retrieving a given record usingQSqlTableModel::record()and by accessing individual fields usingvalue():"},{"pageNumber":316,"pageContent":"29813. Databasesfor (int i = 0; i < model.rowCount(); ++i) { QSqlRecord record = model.record(i); QString title = record.value(\"title\").toString(); int year = record.value(\"year\").toInt(); cerr << qPrintable(title) << \": \" << year << endl;}TheQSqlRecord::value()function takes either a field name or a field index.When operating on large data sets, it is recommended that fields are specifiedby their indexes. For example:int titleIndex = model.record().indexOf(\"title\");int yearIndex = model.record().indexOf(\"year\");for (int i = 0; i < model.rowCount(); ++i) { QSqlRecord record = model.record(i); QString title = record.value(titleIndex).toString(); int year = record.value(yearIndex).toInt(); cerr << qPrintable(title) << \": \" << year << endl;}To insert a record into a database table, we use the same approach as we wouldinserting into any two-dimensional model: First, we callinsertRow()to createa new empty row (record), and then we usesetData()to set the values of eachcolumn (field).QSqlTableModel model;model.setTable(\"cd\");int row = 0;model.insertRows(row, 1);model.setData(model.index(row, 0), 113);model.setData(model.index(row, 1), \"Shanghai My Heart\");model.setData(model.index(row, 2), 224);model.setData(model.index(row, 3), 2003);model.submitAll();After the call tosubmitAll(), the record might be moved to a different rowposition, depending on how the table is ordered. ThesubmitAll()call willreturnfalseif the insertion failed.An important difference between an SQL model and a standard model is thatfor an SQL model we must callsubmitAll()to have any changes written tothe database.To update a record, we must first position theQSqlTableModelon the recordwe want to modify (for example, usingselect()). We then extract therecord, update the fields we want to change, and write our changes back tothe database:QSqlTableModel model;model.setTable(\"cd\");model.setFilter(\"id = 125\");model.select();if (model.rowCount() == 1) { QSqlRecord record = model.record(0); record.setValue(\"title\", \"Melody A.M.\");"},{"pageNumber":317,"pageContent":"Connecting and Querying299 record.setValue(\"year\", record.value(\"year\").toInt() + 1); model.setRecord(0, record); model.submitAll();}If there is a record that matches the specified filter, we retrieve it usingQSqlTableModel::record(). We apply our changes and overwrite the originalrecord with our modified record.It is also possible to perform an update usingsetData(), just as we would dofor a non-SQL model. The model indexes that we retrieve are for a given rowand column:model.select();if (model.rowCount() == 1) { model.setData(model.index(0, 1), \"Melody A.M.\"); model.setData(model.index(0, 3), model.data(model.index(0, 3)).toInt() + 1); model.submitAll();}Deleting a record is similar to updating:model.setTable(\"cd\");model.setFilter(\"id = 125\");model.select();if (model.rowCount() == 1) { model.removeRows(0, 1); model.submitAll();}TheremoveRows()call takes the row number of the first record to delete andthe number of records to delete. The next example deletes all the records thatmatch the filter:model.setTable(\"cd\");model.setFilter(\"year < 1990\");model.select();if (model.rowCount() > 0) { model.removeRows(0, model.rowCount()); model.submitAll();}TheQSqlQueryandQSqlTableModelclasses provide an interface between Qt andan SQL database. Using these classes, we can create forms that present datato users and that let them insert, update, and delete records.Presenting Data in Tabular FormIn many cases, it is simplest to present users with a tabular view of a data set.In this section and the following section, we present a simple CD Collectionapplication that usesQSqlTableModeland its subclassQSqlRelationalTableModelto let users view and interact with data stored in a database."},{"pageNumber":318,"pageContent":"30013. DatabasesThe main form shows a master–detail view of CDs and the tracks on thecurrently selected CD, as shown in Figure 13.1.Figure 13.1.The CD Collection applicationThe application uses three tables, defined as follows:CREATE TABLE artist ( id INTEGER PRIMARY KEY, name VARCHAR(40) NOT NULL, country VARCHAR(40));CREATE TABLE cd ( id INTEGER PRIMARY KEY, title VARCHAR(40) NOT NULL, artistid INTEGER NOT NULL, year INTEGER NOT NULL, FOREIGN KEY (artistid) REFERENCES artist);CREATE TABLE track ( id INTEGER PRIMARY KEY, title VARCHAR(40) NOT NULL, duration INTEGER NOT NULL, cdid INTEGER NOT NULL, FOREIGN KEY (cdid) REFERENCES cd);Some databases don’t support foreign keys. For those, we must remove theFOREIGN KEYclauses. The example will still work, but the database will notenforce referential integrity."},{"pageNumber":319,"pageContent":"Presenting Data in Tabular Form301cdidtitleartistidyearartistidnamecountrytrackidtitledurationcdid1:N1:N1:N1:NFigure 13.2.The CD Collection application’s tablesIn this section, we will write a dialog that allows the user to edit a list of artistsusing a simple tabular form. The user can insert or delete artists using theform’s buttons. Updates can be applied directly, simply by editing cell text.Changes are applied to the database when the user pressesEnteror navigatesto another record.Figure 13.3.TheArtistFormdialogHere’s the class definition for theArtistFormdialog:class ArtistForm : public QDialog{ Q_OBJECTpublic: ArtistForm(const QString &name, QWidget *parent = 0);private slots: void addArtist(); void deleteArtist(); void beforeInsertArtist(QSqlRecord &record);private: enum { Artist_Id = 0, Artist_Name = 1, Artist_Country = 2 }; QSqlTableModel *model;"},{"pageNumber":320,"pageContent":"30213. Databases QTableView *tableView; QPushButton *addButton; QPushButton *deleteButton; QPushButton *closeButton;};The constructor is very similar to one that would be used to create a form basedon a non-SQL model:ArtistForm::ArtistForm(const QString &name, QWidget *parent) : QDialog(parent){ model = new QSqlTableModel(this); model->setTable(\"artist\"); model->setSort(Artist_Name, Qt::AscendingOrder); model->setHeaderData(Artist_Name, Qt::Horizontal, tr(\"Name\")); model->setHeaderData(Artist_Country, Qt::Horizontal, tr(\"Country\")); model->select(); connect(model, SIGNAL(beforeInsert(QSqlRecord &)), this, SLOT(beforeInsertArtist(QSqlRecord &))); tableView = new QTableView; tableView->setModel(model); tableView->setColumnHidden(Artist_Id, true); tableView->setSelectionBehavior(QAbstractItemView::SelectRows); tableView->resizeColumnsToContents(); for (int row = 0; row < model->rowCount(); ++row) { QSqlRecord record = model->record(row); if (record.value(Artist_Name).toString() == name) { tableView->selectRow(row); break; } }•••}We begin the constructor by creating aQSqlTableModel. We passthisas parentto give ownership to the form. We have chosen to sort by column 1 (specifiedby the constantArtist_Name), which corresponds to thenamefield. If we didnot specify column headers, the field names would be used. We prefer to namethem ourselves to ensure that they are properly capitalized and internation-alized.Next, we create aQTableViewto visualize the model. We hide theidfield andset the column widths to accommodate their text without needing to showellipses.TheArtistFormconstructor takes the name of the artist that should be selectedwhen the dialog pops up. We iterate through theartisttable’s records andselect the specified artist. The rest of the constructor’s code is used to createand connect the buttons and to lay out the child widgets.void ArtistForm::addArtist(){"},{"pageNumber":321,"pageContent":"Presenting Data in Tabular Form303 int row = model->rowCount(); model->insertRow(row); QModelIndex index = model->index(row, Artist_Name); tableView->setCurrentIndex(index); tableView->edit(index);}To add a new artist, we insert a single blank row at the bottom of theQTable-View. Now the user can enter a new artist’s name and country. If the user con-firms the insertion by pressingEnter, thebeforeInsert()signal is emitted andthen the new record is inserted into the database.void ArtistForm::beforeInsertArtist(QSqlRecord &record){ record.setValue(\"id\", generateId(\"artist\"));}In the constructor, we connected the model’sbeforeInsert()signal to this slot.We are passed a non-const reference to the record just before it is inserted intothe database. At this point, we populate itsidfield.Since we will needgenerateId()a few times, we define it inline in a headerfile and include it each time we need it. Here’s a quick (and inefficient) way ofimplementing it:inline int generateId(const QString &table){ QSqlQuery query; query.exec(\"SELECT MAX(id) FROM \" + table); int id = 0; if (query.next()) id = query.value(0).toInt() + 1; return id;}ThegenerateId()function can only be guaranteed to work correctly if it isexecuted within the context of the same transaction as the correspondingINSERTstatement. Some databases support auto-generated fields, and it isusually far better to use the database-specific support for this operation.The last possibility theArtistFormdialog offers is deletion. Rather than per-forming cascading deletions (covered shortly), we have chosen to only permitdeletions of artists who have no CDs in the collection.void ArtistForm::deleteArtist(){ tableView->setFocus(); QModelIndex index = tableView->currentIndex(); if (!index.isValid()) return; QSqlRecord record = model->record(index.row()); QSqlTableModel cdModel; cdModel.setTable(\"cd\"); cdModel.setFilter(\"artistid = \" + record.value(\"id\").toString());"},{"pageNumber":322,"pageContent":"30413. Databases cdModel.select(); if (cdModel.rowCount() == 0) { model->removeRow(tableView->currentIndex().row()); } else { QMessageBox::information(this, tr(\"Delete Artist\"), tr(\"Cannot delete %1 because there are CDs associated \" \"with this artist in the collection.\") .arg(record.value(\"name\").toString())); }}If there is a record selected, we check to see if the artist has any CDs, and ifthey don’t, we delete them immediately. Otherwise, we pop up a message boxexplaining why the deletion was not performed. Strictly speaking, we shouldhave used a transaction, because as the code stands, it is possible for a CD tohave its artist set to the one we are deleting in-between thecdModel.select()andmodel->removeRow()calls. We will show a transaction in the next section.Implementing Master–Detail FormsWe will now review the main form which takes a master–detail approach. Themaster view is a list of CDs. The detail view is a list of tracks for the currentCD. This form is the main window of the CD Collection application as shownin Figure 13.1 (p. 300).class MainForm : public QWidget{ Q_OBJECTpublic: MainForm();private slots: void addCd(); void deleteCd(); void addTrack(); void deleteTrack(); void editArtists(); void currentCdChanged(const QModelIndex &index); void beforeInsertCd(QSqlRecord &record); void beforeInsertTrack(QSqlRecord &record); void refreshTrackViewHeader();private: enum { Cd_Id = 0, Cd_Title = 1, Cd_ArtistId = 2, Cd_Year = 3 }; enum { Track_Id = 0,"},{"pageNumber":323,"pageContent":"Implementing Master–Detail Forms305 Track_Title = 1, Track_Duration = 2, Track_CdId = 3 }; QSqlRelationalTableModel *cdModel; QSqlTableModel *trackModel; QTableView *cdTableView; QTableView *trackTableView; QPushButton *addCdButton; QPushButton *deleteCdButton; QPushButton *addTrackButton; QPushButton *deleteTrackButton; QPushButton *editArtistsButton; QPushButton *quitButton;};We use aQSqlRelationalTableModelfor thecdtable rather than a plainQSqlTa-bleModelbecause we need to handle foreign keys. We will now review each func-tion in turn, beginning with the constructor, which we will look at in sectionsbecause it is quite long.MainForm::MainForm(){ cdModel = new QSqlRelationalTableModel(this); cdModel->setTable(\"cd\"); cdModel->setRelation(Cd_ArtistId,  QSqlRelation(\"artist\", \"id\", \"name\")); cdModel->setSort(Cd_Title, Qt::AscendingOrder); cdModel->setHeaderData(Cd_Title, Qt::Horizontal, tr(\"Title\")); cdModel->setHeaderData(Cd_ArtistId, Qt::Horizontal, tr(\"Artist\")); cdModel->setHeaderData(Cd_Year, Qt::Horizontal, tr(\"Year\")); cdModel->select();The constructor begins by setting up theQSqlRelationalTableModelthat handlesthecdtable. ThesetRelation()call tells the model that itsartistidfield (whosefield index is held byCd_ArtistId) holds theidforeign key from theartisttable,and that it should display the correspondingnamefield’s contents instead ofIDs. If the user chooses to edit this field (for example, by pressingF2), themodel will automatically present a combobox with the names of all the artists,and if the user chooses a different artist, will update thecdtable. cdTableView = new QTableView; cdTableView->setModel(cdModel); cdTableView->setItemDelegate(new QSqlRelationalDelegate(this)); cdTableView->setSelectionMode(QAbstractItemView::SingleSelection); cdTableView->setSelectionBehavior(QAbstractItemView::SelectRows); cdTableView->setColumnHidden(Cd_Id, true); cdTableView->resizeColumnsToContents();Setting up the view for thecdtable is again similar to what we have alreadyseen. The only significant difference is that instead of using the view’s defaultdelegate we useQSqlRelationalDelegate. It is this delegate that does the foreignkey handling."},{"pageNumber":324,"pageContent":"30613. Databases trackModel = new QSqlTableModel(this); trackModel->setTable(\"track\"); trackModel->setHeaderData(Track_Title, Qt::Horizontal, tr(\"Title\")); trackModel->setHeaderData(Track_Duration, Qt::Horizontal,  tr(\"Duration\")); trackTableView = new QTableView; trackTableView->setModel(trackModel); trackTableView->setItemDelegate( new TrackDelegate(Track_Duration, this)); trackTableView->setSelectionMode( QAbstractItemView::SingleSelection); trackTableView->setSelectionBehavior(QAbstractItemView::SelectRows);For tracks, we are only going to show their names and durations, so aQSql-TableModelis sufficient. (Theidandcdidfield’s are hidden in thecurrentCd-Changed()slot shown later.) The only notable aspect of this part of the code isthat we use theTrackDelegatedeveloped in Chapter 10 to show track times as“minutes:seconds” and to allow them to be edited using a suitableQTimeEdit.The creation, connecting, and laying out of the views and buttons holds nosurprises, so the only other part of the constructor that we will show are a fewnon-obvious connections.••• connect(cdTableView->selectionModel(), SIGNAL(currentRowChanged(const QModelIndex &,  const QModelIndex &)), this, SLOT(currentCdChanged(const QModelIndex &))); connect(cdModel, SIGNAL(beforeInsert(QSqlRecord &)), this, SLOT(beforeInsertCd(QSqlRecord &))); connect(trackModel, SIGNAL(beforeInsert(QSqlRecord &)), this, SLOT(beforeInsertTrack(QSqlRecord &))); connect(trackModel, SIGNAL(rowsInserted(const QModelIndex &, int,  int)), this, SLOT(refreshTrackViewHeader()));•••}The first connection is unusual since instead of connecting a widget, weconnect to a selection model. TheQItemSelectionModelclass is used to keeptrack of selections in views. By being connected to the table view’s selectionmodel, ourcurrentCdChanged()slot will be called whenever the user navigatesfrom one record to another.void MainForm::currentCdChanged(const QModelIndex &index){ if (index.isValid()) { QSqlRecord record = cdModel->record(index.row()); int id = record.value(\"id\").toInt(); trackModel->setFilter(QString(\"cdid = %1\").arg(id)); } else { trackModel->setFilter(\"cdid = -1\"); }"},{"pageNumber":325,"pageContent":"Implementing Master–Detail Forms307 trackModel->select(); refreshTrackViewHeader();}This slot is called whenever the current CD changes. This occurs when theuser navigates to another CD (by clicking or by using theUpandDownkeys).If the CD is invalid (for example, if there are no CDs or a new one is beinginserted, or the current one has just been deleted), we set thetracktable’scdidto+--1 (an invalid ID that we know will match no records).Then, having set the filter, we select the matching track records. Therefresh-TrackViewHeader()function will be explained in a moment.void MainForm::addCd(){ int row = 0; if (cdTableView->currentIndex().isValid()) row = cdTableView->currentIndex().row(); cdModel->insertRow(row); cdModel->setData(cdModel->index(row, Cd_Year), QDate::currentDate().year()); QModelIndex index = cdModel->index(row, Cd_Title); cdTableView->setCurrentIndex(index); cdTableView->edit(index);}When the user clicks theAdd CDbutton, a new blank row is inserted in thecdTableViewand we enter edit mode. We also set a default value for theyearfield. At this point, the user can edit the record, filling in the blank fields andselecting an artist from the artist combobox that is automatically providedby theQSqlRelationalTableModelbecause of thesetRelation()call, and edit theyear if the default was not appropriate. If the user confirms the insertion bypressingEnter, the record is inserted. The user can cancel by pressingEsc.void MainForm::beforeInsertCd(QSqlRecord &record){ record.setValue(\"id\", generateId(\"cd\"));}This slot is called when thecdModelemits itsbeforeInsert()signal. We use itto populate theidfield just as we did for inserting new artists, and the samecaveat applies: It should be done within the scope of a transaction, and ideallythe database-specific means of creating IDs (for example, auto-generated IDs)should be used instead.void MainForm::deleteCd(){ QModelIndex index = cdTableView->currentIndex(); if (!index.isValid()) return; QSqlDatabase db = QSqlDatabase::database(); db.transaction();"},{"pageNumber":326,"pageContent":"30813. Databases QSqlRecord record = cdModel->record(index.row()); int id = record.value(Cd_Id).toInt(); int tracks = 0; QSqlQuery query; query.exec(QString(\"SELECT COUNT(*) FROM track WHERE cdid = %1\") .arg(id)); if (query.next()) tracks = query.value(0).toInt(); if (tracks > 0) { int r = QMessageBox::question(this, tr(\"Delete CD\"), tr(\"Delete \\\"%1\\\" and all its tracks?\") .arg(record.value(Cd_ArtistId).toString()), QMessageBox::Yes | QMessageBox::Default, QMessageBox::No | QMessageBox::Escape); if (r == QMessageBox::No) { db.rollback(); return; } query.exec(QString(\"DELETE FROM track WHERE cdid = %1\") .arg(id)); } cdModel->removeRow(index.row()); cdModel->submitAll(); db.commit(); currentCdChanged(QModelIndex());}If the user clicks theDelete CDbutton, this slot is called. If there is a currentCD we find out how many tracks it has. If there are no tracks we simply deletethe CD’s record. If there is at least one track we ask the user to confirm thedeletion, and if they clickYes, we delete all the track records, and then theCD’s record. All this is done within the scope of a transaction, so the cascadedeletion will either fail as a whole or succeed as a whole—assuming that theunderlying database supports transactions.Handling the track data is very similar to handling CD data. Updates can beperformed simply by the user editing cells. In the case of track durations, ourTrackDelegateensures that times are shown in a nice format and are easilyedited using aQTimeEdit.void MainForm::addTrack(){ if (!cdTableView->currentIndex().isValid()) return; int row = 0; if (trackTableView->currentIndex().isValid()) row = trackTableView->currentIndex().row(); trackModel->insertRow(row); QModelIndex index = trackModel->index(row, Track_Title); trackTableView->setCurrentIndex(index); trackTableView->edit(index);}"},{"pageNumber":327,"pageContent":"Implementing Master–Detail Forms309This works in the same way asaddCd(), with a new blank row being insertedinto the view.void MainForm::beforeInsertTrack(QSqlRecord &record){ QSqlRecord cdRecord = cdModel->record(cdTableView->currentIndex()  .row()); record.setValue(\"id\", generateId(\"track\")); record.setValue(\"cdid\", cdRecord.value(Cd_Id).toInt());}If the user confirms the insertion initiated byaddTrack(), this function is calledto populate theidandcdidfields. The caveats mentioned earlier still applyof course.void MainForm::deleteTrack(){ trackModel->removeRow(trackTableView->currentIndex().row()); if (trackModel->rowCount() == 0) trackTableView->horizontalHeader()->setVisible(false);}If the user clicks theDelete Trackbutton, we delete the track without formality.It would be easy to use aYes/Nomessage box if we preferred deletions tobe confirmed.void MainForm::refreshTrackViewHeader(){ trackTableView->horizontalHeader()->setVisible( trackModel->rowCount() > 0); trackTableView->setColumnHidden(Track_Id, true); trackTableView->setColumnHidden(Track_CdId, true); trackTableView->resizeColumnsToContents();}TherefreshTrackViewHeader()slot is invoked from various places to ensure thatthe horizontal header of the track view is shown if and only if there are tracksto show. It also hides theidandcdidfields and resizes the visible table columnsbased on the current contents of the table.void MainForm::editArtists(){ QSqlRecord record = cdModel->record(cdTableView->currentIndex()  .row()); ArtistForm artistForm(record.value(Cd_ArtistId).toString(), this); artistForm.exec(); cdModel->select();}This slot is called if the user clicks theEdit Artistsbutton. It provides drill-downon the current CD’s artist, invoking theArtistFormcovered in the previous sec-tion and selecting the appropriate artist. If there is no current record, a safeempty record is returned byrecord(), and this will harmlessly not match (andtherefore not select) any artist in the artists form. What actually happens isthat when we callrecord.value(Cd_ArtistId), because we are using aQSqlRe-"},{"pageNumber":328,"pageContent":"31013. DatabaseslationalTableModelthat maps artist IDs to artist names, the value that is re-turned is the artist’s name (which will be an empty string if the record is emp-ty). At the end, we get thecdModelto re-select its data, which causes thecdTa-bleViewto refresh its visible cells. This is done to ensure that the artist namesare shown correctly since some could have been changed by the user in theArtistFormdialog.For projects that use the SQL classes, we must add the lineQT += sqlto the.profiles; this will ensure that the application is linked against theQtSqllibrary.This chapter has shown that Qt’s model/view classes make viewing and editingdata in SQL databases as easy as possible. In cases where foreign keys refer totables with lots of records (say, thousands or more), it is probably best to createour own delegate and use it to present a “list of values” form with a search ca-pability rather than relying onQSqlRelationalTableModel’s default comboboxes.And in situations where we want to present records using a form view, we musthandle this ourselves: by using aQSqlQueryorQSqlTableModelto handle thedatabase interaction, and mapping the contents of the user interface widgetswe want to use for presenting and editing the data to the underlying databasein our own code."},{"pageNumber":329,"pageContent":"14. NetworkinguWriting FTP ClientsuWriting HTTP ClientsuWriting TCP Client–ServerApplicationsuSending and Receiving UDPDatagramsQt provides theQFtpandQHttpclasses for working with FTP and HTTP. Theseprotocols are easy to use for downloading and uploading files and, in the caseof HTTP, for sending requests to web servers and retrieving the results.Qt also provides the lower-levelQTcpSocketandQUdpSocketclasses, which im-plement the TCP and UDP transport protocols. TCP is a reliable connection-oriented protocol that operates in terms of data streams transmitted betweennetwork nodes, while UDP is an unreliable connectionless protocol based ondiscrete packets sent between network nodes. Both can be used to create net-work client and server applications. For servers, we also need theQTcpServerclass to handle incoming TCP connections.Writing FTP ClientsTheQFtpclass implements the client side of the FTP protocol in Qt. It offersvarious functions to perform the most common FTP operations and lets usexecute arbitrary FTP commands.TheQFtpclass works asynchronously. When we call a function likeget()orput(), it returns immediately and the data transfer occurs when controlpasses back to Qt’s event loop. This ensures that the user interface remainsresponsive while FTP commands are executed.We will start with an example that shows how to retrieve a single file usingget(). The example is a console application calledftpgetthat downloads the re-mote file specified on the command line. Let’s begin with themain()function:int main(int argc, char *argv[]){ QCoreApplication app(argc, argv); QStringList args = app.arguments(); if (args.count() != 2) { cerr << \"Usage: ftpget url\" << endl311"},{"pageNumber":330,"pageContent":"31214. Networking << \"Example:\" << endl << \" ftpget ftp://ftp.trolltech.com/mirrors\" << endl; return 1; } FtpGet getter; if (!getter.getFile(QUrl(args[1]))) return 1; QObject::connect(&getter, SIGNAL(done()), &app, SLOT(quit())); return app.exec();}We create aQCoreApplicationrather than its subclassQApplicationto avoidlinking in theQtGuilibrary. TheQCoreApplication::arguments()function re-turns the command-line arguments as aQStringList, with the first item beingthe name the program was invoked as, and any Qt-specific arguments suchas-styleremoved. The heart of themain()function is the construction of theFtpGetobject and thegetFile()call. If the call succeeds, we let the event looprun until the download finishes.All the work is done by theFtpGetsubclass, which is defined as follows:class FtpGet : public QObject{ Q_OBJECTpublic: FtpGet(QObject *parent = 0); bool getFile(const QUrl &url);signals: void done();private slots: void ftpDone(bool error);private: QFtp ftp; QFile file;};The class has a public function,getFile(), that retrieves the file specified by aURL. TheQUrlclass provides a high-level interface for extracting the differentparts of a URL, such as the file name, path, protocol, and port.FtpGethas a private slot,ftpDone(), that is called when the file transfer is com-pleted, and adone()signal that it emits when the file has been downloaded.The class also has two private variables: Theftpvariable, of typeQFtp, encap-sulates the connection to an FTP server, and thefilevariable that is used forwriting the downloaded file to disk.FtpGet::FtpGet(QObject *parent) : QObject(parent)"},{"pageNumber":331,"pageContent":"Writing FTP Clients313{ connect(&ftp, SIGNAL(done(bool)), this, SLOT(ftpDone(bool)));}In the constructor, we connect theQFtp::done(bool)signal to ourftpDone(bool)private slot.QFtpemitsdone(bool)when it has finished processing all requests.Theboolparameter indicates whether an error occurred or not.bool FtpGet::getFile(const QUrl &url){ if (!url.isValid()) { cerr << \"Error: Invalid URL\" << endl; return false; } if (url.scheme() != \"ftp\") { cerr << \"Error: URL must start with ’ftp:’\" << endl; return false; } if (url.path().isEmpty()) { cerr << \"Error: URL has no path\" << endl; return false; } QString localFileName = QFileInfo(url.path()).fileName(); if (localFileName.isEmpty()) localFileName = \"ftpget.out\"; file.setFileName(localFileName); if (!file.open(QIODevice::WriteOnly)) { cerr << \"Error: Cannot open \" << qPrintable(file.fileName()) << \" for writing: \" << qPrintable(file.errorString()) << endl; return false; } ftp.connectToHost(url.host(), url.port(21)); ftp.login(); ftp.get(url.path(), &file); ftp.close(); return true;}ThegetFile()function begins by checking the URL that was passed in. Ifa problem is encountered, the function prints an error message tocerrandreturnsfalseto indicate that the download failed.Instead of forcing the user to make up a local file name, we try to create asensible name using the URL itself, with a fallback offtpget.out. If we fail toopen the file, we print an error message and returnfalse.Next, we execute a sequence of four FTP commands using ourQFtpobject. Theurl.port(21)call returns the port number specified in the URL, or port 21 ifnone is specified in the URL itself. Since no user name or password are given to"},{"pageNumber":332,"pageContent":"31414. Networkingthelogin()function, an anonymous login is attempted. The second argumenttoget()specifies the output I/O device.The FTP commands are queued and executed in Qt’s event loop. The comple-tion of all the commands is indicated byQFtp’sdone(bool)signal, which we con-nected toftpDone(bool)in the constructor.void FtpGet::ftpDone(bool error){ if (error) { cerr << \"Error: \" << qPrintable(ftp.errorString()) << endl; } else { cerr << \"File downloaded as \" << qPrintable(file.fileName()) << endl; } file.close(); emit done();}Once the FTP commands have all been executed, we close the file and emitour owndone()signal. It may appear strange that we close the file here,rather than after theftp.close()call at the end of thegetFile()function, butremember that the FTP commands are executed asynchronously and may wellbe in progress after thegetFile()function has returned. Only when theQFtpobject’sdone()signal is emitted do we know that the download is finished andthat it is safe to close the file.QFtpprovides several FTP commands, includingconnectToHost(),login(),close(),list(),cd(),get(),put(),remove(),mkdir(),rmdir(), andrename(). Allof these functions schedule an FTP command and return an ID number thatidentifies the command. It is also possible to control the transfer mode (thedefault is passive) and the transfer type (the default is binary).Arbitrary FTP commands can be executed usingrawCommand(). For example,here’s how to execute aSITE CHMODcommand:ftp.rawCommand(\"SITE CHMOD 755 fortune\");QFtpemits thecommandStarted(int)signal when it starts executing a command,and it emits thecommandFinished(int, bool)signal when the command isfinished. Theintparameter is the ID number that identifies the command.If we are interested in the fate of individual commands, we can store the IDnumbers when we schedule the commands. Keeping track of the ID numbersallows us to provide detailed feedback to the user. For example:bool FtpGet::getFile(const QUrl &url){ ... connectId = ftp.connectToHost(url.host(), url.port(21)); loginId = ftp.login(); getId = ftp.get(url.path(), &file); closeId = ftp.close();"},{"pageNumber":333,"pageContent":"Writing FTP Clients315 return true;}void FtpGet::ftpCommandStarted(int id){ if (id == connectId) { cerr << \"Connecting...\" << endl; } else if (id == loginId) { cerr << \"Logging in...\" << endl; ...}Another way of providing feedback is to connect toQFtp’sstateChanged()signal,which is emitted whenever the connection enters a new state (QFtp::Connecting,QFtp::Connected,QFtp::LoggedIn, etc.).In most applications, we are only interested in the fate of the sequence ofcommands as a whole rather than in particular commands. In such cases, wecan simply connect to thedone(bool)signal, which is emitted whenever thecommand queue becomes empty.When an error occurs,QFtpautomatically clears the command queue. Thismeans that if the connection or the login fails, the commands that follow inthe queue are never executed. If we schedule new commands after the errorhas occurred using the sameQFtpobject, these commands will be queuedand executed.In the application’s.profile, we need the following line to link against theQtNetworklibrary:QT += networkWe will now review a more advanced example. Thespidercommand-line pro-gram downloads all the files located in an FTP directory, recursively download-ing from all the directory’s subdirectories. The network logic is located in theSpiderclass:class Spider : public QObject{ Q_OBJECTpublic: Spider(QObject *parent = 0); bool getDirectory(const QUrl &url);signals: void done();private slots: void ftpDone(bool error); void ftpListInfo(const QUrlInfo &urlInfo);private: void processNextDirectory();"},{"pageNumber":334,"pageContent":"31614. Networking QFtp ftp; QList<QFile *> openedFiles; QString currentDir; QString currentLocalDir; QStringList pendingDirs;};The starting directory is specified as aQUrland is set using thegetDirectory()function.Spider::Spider(QObject *parent) : QObject(parent){ connect(&ftp, SIGNAL(done(bool)), this, SLOT(ftpDone(bool))); connect(&ftp, SIGNAL(listInfo(const QUrlInfo &)), this, SLOT(ftpListInfo(const QUrlInfo &)));}In the constructor, we establish two signal–slot connections. ThelistInfo(const QUrlInfo &)signal is emitted byQFtpwhen we request a directory listing(ingetDirectory()) for each file that it retrieves. This signal is connected to aslot calledftpListInfo(), which downloads the file associated with the URL itis given.bool Spider::getDirectory(const QUrl &url){ if (!url.isValid()) { cerr << \"Error: Invalid URL\" << endl; return false; } if (url.scheme() != \"ftp\") { cerr << \"Error: URL must start with ’ftp:’\" << endl; return false; } ftp.connectToHost(url.host(), url.port(21)); ftp.login(); QString path = url.path(); if (path.isEmpty()) path = \"/\"; pendingDirs.append(path); processNextDirectory(); return true;}When thegetDirectory()function is called, it begins by doing some sanitychecks, and if all is well, attempts to establish an FTP connection. It keepstrack of the paths that it must process and callsprocessNextDirectory()to startdownloading the root directory.void Spider::processNextDirectory(){"},{"pageNumber":335,"pageContent":"Writing FTP Clients317 if (!pendingDirs.isEmpty()) { currentDir = pendingDirs.takeFirst(); currentLocalDir = \"downloads/\" + currentDir; QDir(\".\").mkpath(currentLocalDir); ftp.cd(currentDir); ftp.list(); } else { emit done(); }}TheprocessNextDirectory()function takes the first remote directory out of thependingDirslist and creates a corresponding directory in the local file system.It then tells theQFtpobject to change directory into the taken directory and tolist its files. For every file thatlist()processes, it emits alistInfo()signalthat causes theftpListInfo()slot to be called.If there are no more directories to process, the function emits thedone()signalto indicate that the downloading is complete.void Spider::ftpListInfo(const QUrlInfo &urlInfo){ if (urlInfo.isFile()) { if (urlInfo.isReadable()) { QFile *file = new QFile(currentLocalDir + \"/\"  + urlInfo.name()); if (!file->open(QIODevice::WriteOnly)) { cerr << \"Warning: Cannot open file \" << qPrintable(  QDir::convertSeparators(file->fileName())) << endl; return; } ftp.get(urlInfo.name(), file); openedFiles.append(file); } } else if (urlInfo.isDir() && !urlInfo.isSymLink()) { pendingDirs.append(currentDir + \"/\" + urlInfo.name()); }}TheftpListInfo()slot’surlInfoparameter provides detailed information abouta remote file. If the file is a normal file (not a directory) and is readable, we callget()to download it. TheQFileobject used for downloading is allocated usingnewand a pointer to it is stored in theopenedFileslist.If theQUrlInfoholds the details of a remote directory that is not a symboliclink, we add this directory to thependingDirslist. We skip symbolic linksbecause they can easily lead to infinite recursion.void Spider::ftpDone(bool error){"},{"pageNumber":336,"pageContent":"31814. Networking if (error) { cerr << \"Error: \" << qPrintable(ftp.errorString()) << endl; } else { cout << \"Downloaded \" << qPrintable(currentDir) << \" to \" << qPrintable(QDir::convertSeparators(  QDir(currentLocalDir).canonicalPath())); } qDeleteAll(openedFiles); openedFiles.clear(); processNextDirectory();}TheftpDone()slot is called when all the FTP commands have finished or ifan error occurred. We delete theQFileobjects to prevent memory leaks andalso to close each file. Finally, we callprocessNextDirectory(). If there are anydirectories left, the whole process begins again with the next directory in thelist; otherwise, the downloading stops anddone()is emitted.If there are no errors, the sequence of FTP commands and signals is asfollows:connectToHost(host, port)login()cd(directory_1)list() emit listInfo(file_1_1) get(file_1_1) emit listInfo(file_1_2) get(file_1_2) ...emit done()...cd(directory_N)list() emit listInfo(file_N_1) get(file_N_1) emit listInfo(file_N_2) get(file_N_2) ...emit done()If a file is in fact a directory, it is added to thependingDirslist, and when the lastfile of the currentlist()command has been downloaded, a newcd()commandis issued, followed by a newlist()command with the next pending directory,and the whole process begins again with the new directory. This is repeated,with new files being downloaded, and new directories added to thependingDirslist, until every file has been downloaded from every directory, at which pointthependingDirslist will finally be empty."},{"pageNumber":337,"pageContent":"Writing FTP Clients319If a network error occurs while downloading the fifth of, say, twenty filesin a directory, the remaining files will not be downloaded. If we wanted todownload as many files as possible, one solution would be to schedule theGEToperations one at a time and to wait for thedone(bool)signal before schedulinga newGEToperation. InlistInfo(), we would simply append the file name to aQStringList, instead of callingget()right away, and indone(bool)we would callget()on the next file to download in theQStringList. The sequence of executionwould then look like this:connectToHost(host, port)login()cd(directory_1)list()...cd(directory_N)list() emit listInfo(file_1_1) emit listInfo(file_1_2) ... emit listInfo(file_N_1) emit listInfo(file_N_2) ...emit done()get(file_1_1)emit done()get(file_1_2)emit done()...get(file_N_1)emit done()get(file_N_2)emit done()...Another solution would be to use oneQFtpobject per file. This would enable usto download the files in parallel, through separate FTP connections.int main(int argc, char *argv[]){ QCoreApplication app(argc, argv); QStringList args = app.arguments(); if (args.count() != 2) { cerr << \"Usage: spider url\" << endl << \"Example:\" << endl << \" spider ftp://ftp.trolltech.com/freebies/leafnode\" << endl; return 1; }"},{"pageNumber":338,"pageContent":"32014. Networking Spider spider; if (!spider.getDirectory(QUrl(args[1]))) return 1; QObject::connect(&spider, SIGNAL(done()), &app, SLOT(quit())); return app.exec();}Themain()function completes the program. If the user does not specify a URLon the command line, we give an error message and terminate the program.In both FTP examples, the data retrieved usingget()was written to aQFile.This need not be the case. If we wanted the data in memory, we could use aQBuffer, theQIODevicesubclass that wraps aQByteArray. For example:QBuffer *buffer = new QBuffer;buffer->open(QIODevice::WriteOnly);ftp.get(urlInfo.name(), buffer);We could also omit the I/O device argument toget()or pass a null pointer. TheQFtpclass then emits areadyRead()signal every time new data is available, andthe data can be read usingread()orreadAll().Writing HTTP ClientsTheQHttpclass implements the client side of the HTTP protocol in Qt. Itprovides various functions to perform the most common HTTP operations,includingget()andpost(), and provides a means of sending arbitrary HTTPrequests. If you have read the previous section aboutQFtp, you will find thatthere are many similarities betweenQFtpandQHttp.TheQHttpclass works asynchronously. When we call a function likeget()orpost(), the function returns immediately, and the data transfer occurs later,when control returns to Qt’s event loop. This ensures that the application’s userinterface remains responsive while HTTP requests are being processed.We will review a console application example calledhttpgetthat shows howto download a file using the HTTP protocol. It is very similar to theftpgetexample from the previous section, both in functionality and implementation,so we will not show the header file.HttpGet::HttpGet(QObject *parent) : QObject(parent){ connect(&http, SIGNAL(done(bool)), this, SLOT(httpDone(bool)));}In the constructor, we connect theQHttpobject’sdone(bool)signal to the privatehttpDone(bool)slot.bool HttpGet::getFile(const QUrl &url){"},{"pageNumber":339,"pageContent":"Writing HTTP Clients321 if (!url.isValid()) { cerr << \"Error: Invalid URL\" << endl; return false; } if (url.scheme() != \"http\") { cerr << \"Error: URL must start with ’http:’\" << endl; return false; } if (url.path().isEmpty()) { cerr << \"Error: URL has no path\" << endl; return false; } QString localFileName = QFileInfo(url.path()).fileName(); if (localFileName.isEmpty()) localFileName = \"httpget.out\"; file.setFileName(localFileName); if (!file.open(QIODevice::WriteOnly)) { cerr << \"Error: Cannot open \" << qPrintable(file.fileName()) << \" for writing: \" << qPrintable(file.errorString()) << endl; return false; } http.setHost(url.host(), url.port(80)); http.get(url.path(), &file); http.close(); return true;}ThegetFile()function performs the same kind of error checks as theFtpGet::getFile()shown earlier and uses the same approach to giving the file a localname. When retrieving from web sites, no login is necessary, so we simply setthe host and port (using the default HTTP port 80 if none is specified in theURL) and download the data into the file, since the second argument toQHttp::get()specifies the output I/O device.The HTTP requests are queued and executed asynchronously in Qt’s eventloop. The completion of the requests is indicated byQHttp’sdone(bool)signal,which we connected tohttpDone(bool)in the constructor.void HttpGet::httpDone(bool error){ if (error) { cerr << \"Error: \" << qPrintable(http.errorString()) << endl; } else { cerr << \"File downloaded as \" << qPrintable(file.fileName()) << endl; } file.close(); emit done();}"},{"pageNumber":340,"pageContent":"32214. NetworkingOnce the HTTP requests are finished, we close the file, notifying the user if anerror occurred.Themain()function is very similar to the one used byftpget:int main(int argc, char *argv[]){ QCoreApplication app(argc, argv); QStringList args = app.arguments(); if (args.count() != 2) { cerr << \"Usage: httpget url\" << endl << \"Example:\" << endl << \" httpget http://doc.trolltech.com/qq/index.html\" << endl; return 1; } HttpGet getter; if (!getter.getFile(QUrl(args[1]))) return 1; QObject::connect(&getter, SIGNAL(done()), &app, SLOT(quit())); return app.exec();}TheQHttpclass provides many operations, includingsetHost(),get(),post(),andhead(). If a site requires authentication,setUser()can be used to supplya user name and password.QHttpcan use a socket supplied by the program-mer rather than its own internalQTcpSocket. This makes it possible to use asecureQtSslSocket, provided as a Qt Solution from Trolltech, to achieve HTTPover SSL.To send a list of “name=value” pairs to a CGI script, we can usepost():http.setHost(\"www.example.com\");http.post(\"/cgi/somescript.py\", \"x=200&y=320\", &file);We can pass the data either as an 8-bit string or by passing an openQIODevice,such as aQFile. For more control, we can use therequest()function, whichaccepts an arbitrary HTTP header and data. For example:QHttpRequestHeader header(\"POST\", \"/search.html\");header.setValue(\"Host\", \"www.trolltech.com\");header.setContentType(\"application/x-www-form-urlencoded\");http.setHost(\"www.trolltech.com\");http.request(header, \"qt-interest=on&search=opengl\");QHttpemits therequestStarted(int)signal when it starts executing a request,and it emits therequestFinished(int, bool)signal when the request hasfinished. Theintparameter is an ID number that identifies a request. If weare interested in the fate of individual requests, we can store the ID numberswhen we schedule the requests. Keeping track of the ID numbers allows us toprovide detailed feedback to the user."},{"pageNumber":341,"pageContent":"Writing HTTP Clients323In most applications, we only want to know whether the entire sequence ofrequests completed successfully or not. This is easily achieved by connectingto thedone(bool)signal, which is emitted when the request queue becomesempty.When an error occurs, the request queue is automatically cleared. But if weschedule new requests after the error has occurred using the sameQHttpobject,these requests will be queued and sent as usual.LikeQFtp,QHttpprovides areadyRead()signal as well as theread()andreadAll()functions that we can use instead of specifying an I/O device.Writing TCP Client–Server ApplicationsTheQTcpSocketandQTcpServerclasses can be used to implement TCP clientsand servers. TCP is a transport protocol that forms the basis of mostapplication-level Internet protocols, including FTP and HTTP, and that canalso be used for custom protocols.TCP is a stream-oriented protocol. For applications, the data appears to be along stream, rather like a large flat file. The high-level protocols built on topof TCP are typically either line-oriented or block-oriented:• Line-oriented protocols transfer data as lines of text, each terminated bya newline.• Block-oriented protocols transfer data as binary data blocks. Each blockconsists of a size field followed by that much data.QTcpSocketinherits fromQIODevicethroughQAbstractSocket, so it can be readfrom and written to using aQDataStreamor aQTextStream. One notable differencewhen reading data from a network compared with reading from a file is thatwe must make sure that we have received enough data from the peer before weuse the>>operator. Failing to do so may result in undefined behavior.In this section, we will review the code of a client and a server that use acustom block-oriented protocol. The client is called Trip Planner and allowsusers to plan their next train trip. The server is called Trip Server and pro-vides the trip information to the client. We will start by writing the Trip Plan-ner client.The Trip Planner provides aFromfield, aTofield, aDatefield, anApproximateTimefield, and two radio buttons to select whether the approximate time is thatof departure or arrival. When the user clicksSearch, the application sends arequest to the server, which responds with a list of train trips that match theuser’s criteria. The list is shown in aQTableWidgetin the Trip Planner window.The very bottom of the window is occupied by aQLabelthat shows the statusof the last operation and aQProgressBar."},{"pageNumber":342,"pageContent":"32414. NetworkingFigure 14.1.The Trip Planner applicationThe Trip Planner’s user interface was created usingQt Designerin a file calledtripplanner.ui. Here, we will focus on the source code of theQDialogsubclassthat implements the application’s functionality:#include \"ui_tripplanner.h\"class TripPlanner : public QDialog, public Ui::TripPlanner{ Q_OBJECTpublic: TripPlanner(QWidget *parent = 0);private slots: void connectToServer(); void sendRequest(); void updateTableWidget(); void stopSearch(); void connectionClosedByServer(); void error();private: void closeConnection(); QTcpSocket tcpSocket; quint16 nextBlockSize;};TheTripPlannerclass inherits fromUi::TripPlanner(which is generated byuicfromtripplanner.ui) in addition toQDialog. ThetcpSocketmember variableencapsulates the TCP connection. ThenextBlockSizevariable is used whenparsing the blocks received from the server.TripPlanner::TripPlanner(QWidget *parent) : QDialog(parent){ setupUi(this);"},{"pageNumber":343,"pageContent":"Writing TCP Client–Server Applications325 QDateTime dateTime = QDateTime::currentDateTime(); dateEdit->setDate(dateTime.date()); timeEdit->setTime(QTime(dateTime.time().hour(), 0)); progressBar->hide(); progressBar->setSizePolicy(QSizePolicy::Preferred,  QSizePolicy::Ignored); tableWidget->verticalHeader()->hide(); tableWidget->setEditTriggers(QAbstractItemView::NoEditTriggers); connect(searchButton, SIGNAL(clicked()), this, SLOT(connectToServer())); connect(stopButton, SIGNAL(clicked()), this, SLOT(stopSearch())); connect(&tcpSocket, SIGNAL(connected()), this, SLOT(sendRequest())); connect(&tcpSocket, SIGNAL(disconnected()), this, SLOT(connectionClosedByServer())); connect(&tcpSocket, SIGNAL(readyRead()), this, SLOT(updateTableWidget())); connect(&tcpSocket, SIGNAL(error(QAbstractSocket::SocketError)), this, SLOT(error()));}In the constructor, we initialize the date and time editors based on the currentdate and time. We also hide the progress bar, because we only want to showit when a connection is active. InQt Designer, the progress bar’sminimumandmaximumproperties were both set to 0. This tells theQProgressBarto behave as abusy indicator instead of as a standard percentage-based progress bar.Also in the constructor, we connect theQTcpSocket’sconnected(),disconnected(),readyRead(), anderror(QAbstractSocket::SocketError)signals to private slots.void TripPlanner::connectToServer(){ tcpSocket.connectToHost(\"tripserver.zugbahn.de\", 6178); tableWidget->setRowCount(0); searchButton->setEnabled(false); stopButton->setEnabled(true); statusLabel->setText(tr(\"Connecting to server...\")); progressBar->show(); nextBlockSize = 0;}TheconnectToServer()slot is executed when the user clicksSearchto starta search. We callconnectToHost()on theQTcpSocketobject to connect to theserver, which we assume is accessible at port 6178 on the fictitious hosttripserver.zugbahn.de. (If you want to try the example on your own machine,replace the host name withQHostAddress::LocalHost.) TheconnectToHost()callis asynchronous; it always returns immediately. The connection is typicallyestablished later. TheQTcpSocketobject emits theconnected()signal when theconnection is up and running, orerror(QAbstractSocket::SocketError)if theconnection failed."},{"pageNumber":344,"pageContent":"32614. NetworkingNext, we update the user interface, in particular making the progress barvisible.Finally, we set thenextBlockSizevariable to 0. This variable stores the lengthof the next block received from the server. We have chosen to use the value of0 to mean that we don’t yet know the size of the next block.void TripPlanner::sendRequest(){ QByteArray block; QDataStream out(&block, QIODevice::WriteOnly); out.setVersion(QDataStream::Qt_4_1); out << quint16(0) << quint8(’S’) << fromComboBox->currentText() << toComboBox->currentText() << dateEdit->date() << timeEdit->time(); if (departureRadioButton->isChecked()) { out << quint8(’D’); } else { out << quint8(’A’); } out.device()->seek(0); out << quint16(block.size() - sizeof(quint16)); tcpSocket.write(block); statusLabel->setText(tr(\"Sending request...\"));}ThesendRequest()slot is executed when theQTcpSocketobject emits thecon-nected()signal, indicating that a connection has been established. The slot’stask is to generate a request to the server, with all the information entered bythe user.The request is a binary block with the following format:quint16Block size in bytes (excluding this field)quint8Request type (always ‘S’)QStringDeparture cityQStringArrival cityQDateDate of travelQTimeApproximate time of travelquint8Time is for departure (‘D’) or arrival (‘A’)We first write the data to aQByteArraycalledblock. We can’t write the datadirectly to theQTcpSocketbecause we don’t know the size of the block, whichmust be sent first, until after we have put all the data into the block.We initially write 0 as the block size, followed by the rest of the data. Thenwe callseek(0)on the I/O device (aQBuffercreated byQDataStreambehind thescenes) to move back to the beginning of the byte array, and overwrite theinitial 0 with the size of the block’s data. The size is calculated by taking the"},{"pageNumber":345,"pageContent":"Writing TCP Client–Server Applications327block’s size and subtractingsizeof(quint16)(that is, 2) to exclude the size fieldfrom the byte count. After that, we callwrite()on theQTcpSocketto send theblock to the server.void TripPlanner::updateTableWidget(){ QDataStream in(&tcpSocket); in.setVersion(QDataStream::Qt_4_1); forever { int row = tableWidget->rowCount(); if (nextBlockSize == 0) { if (tcpSocket.bytesAvailable() < sizeof(quint16)) break; in >> nextBlockSize; } if (nextBlockSize == 0xFFFF) { closeConnection(); statusLabel->setText(tr(\"Found %1 trip(s)\").arg(row)); break; } if (tcpSocket.bytesAvailable() < nextBlockSize) break; QDate date; QTime departureTime; QTime arrivalTime; quint16 duration; quint8 changes; QString trainType; in >> date >> departureTime >> duration >> changes >> trainType; arrivalTime = departureTime.addSecs(duration * 60); tableWidget->setRowCount(row + 1); QStringList fields; fields << date.toString(Qt::LocalDate) << departureTime.toString(tr(\"hh:mm\")) << arrivalTime.toString(tr(\"hh:mm\")) << tr(\"%1 hr %2 min\").arg(duration / 60)  .arg(duration % 60) << QString::number(changes) << trainType; for (int i = 0; i < fields.count(); ++i) tableWidget->setItem(row, i,  new QTableWidgetItem(fields[i])); nextBlockSize = 0; }}TheupdateTableWidget()slot is connected to theQTcpSocket’sreadyRead()signal,which is emitted whenever theQTcpSockethas received new data from the"},{"pageNumber":346,"pageContent":"32814. Networkingserver. The server sends us a list of possible train trips that match the user’scriteria. Each matching trip is sent as a single block, and each block startswith a size. Theforeverloop is necessary because we don’t necessarily getone block of data from the server at a time.HWe might have received an entireblock, or just part of a block, or one and a half blocks, or even all of the blocksat once.51data48data· · ·53data0xFFFFbytes51 bytesb48 bytesb53 bytesFigure 14.2.The Trip Server’s blocksSo how does theforeverloop work? If thenextBlockSizevariable is 0, thismeans that we have not read the size of the next block. We try to read it(assuming there are at least 2 bytes available for reading). The server uses asize value of0xFFFFto signify that there is no more data to receive, so if we readthis value, we know that we have reached the end.If the block size is not0xFFFF, we try to read in the next block. First, we checkto see if there are block size bytes available to read. If there are not, we stopthere for now. ThereadyRead()signal will be emitted again when more data isavailable, and we will try again then.Once we are sure that an entire block has arrived, we can safely use the>>operator on theQDataStreamto extract the information related to a trip, andwe createQTableWidgetItems with that information. A block received from theserver has the following format:quint16Block size in bytes (excluding this field)QDateDeparture dateQTimeDeparture timequint16Duration (in minutes)quint8Number of changesQStringTrain typeAt the end, we reset thenextBlockSizevariable to 0 to indicate that the nextblock’s size is unknown and needs to be read.void TripPlanner::closeConnection(){ tcpSocket.close(); searchButton->setEnabled(true); stopButton->setEnabled(false); progressBar->hide();}HTheforeverkeyword is provided by Qt. It simply expands tofor (;;)."},{"pageNumber":347,"pageContent":"Writing TCP Client–Server Applications329ThecloseConnection()private function closes the connection to the TCP serverand updates the user interface. It is called fromupdateTableWidget()when the0xFFFFis read and from several other slots that we will cover shortly.void TripPlanner::stopSearch(){ statusLabel->setText(tr(\"Search stopped\")); closeConnection();}ThestopSearch()slot is connected to theStopbutton’sclicked()signal. Essen-tially it just callscloseConnection().void TripPlanner::connectionClosedByServer(){ if (nextBlockSize != 0xFFFF) statusLabel->setText(tr(\"Error: Connection closed by server\")); closeConnection();}TheconnectionClosedByServer()slot is connected toQTcpSocket’sdisconnected()signal. If the server closes the connection and we have not yet received the0xFFFFend-of-data marker, we tell the user that an error occurred. We callcloseConnection()as usual to update the user interface.void TripPlanner::error(){ statusLabel->setText(tcpSocket.errorString()); closeConnection();}Theerror()slot is connected toQTcpSocket’serror(QAbstractSocket::SocketEr-ror)signal. We ignore the error code and useQTcpSocket::errorString(), whichreturns a human-readable error message for the last error that occurred.This is all for theTripPlannerclass. Themain()function for the Trip Plannerapplication looks just as we would expect:int main(int argc, char *argv[]){ QApplication app(argc, argv); TripPlanner tripPlanner; tripPlanner.show(); return app.exec();}Now let’s implement the server. The server consists of two classes:TripServerandClientSocket. TheTripServerclass inheritsQTcpServer, a class that allowsus to accept incoming TCP connections.ClientSocketreimplementsQTcpSocketand handles a single connection. At any one time, there are as manyClient-Socketobjects in memory as there are clients being served.class TripServer : public QTcpServer{"},{"pageNumber":348,"pageContent":"33014. Networking Q_OBJECTpublic: TripServer(QObject *parent = 0);private: void incomingConnection(int socketId);};TheTripServerclass reimplements theincomingConnection()function fromQTcpServer. This function is called whenever a client attempts to connect to theport the server is listening to.TripServer::TripServer(QObject *parent) : QTcpServer(parent){}TheTripServerconstructor is trivial.void TripServer::incomingConnection(int socketId){ ClientSocket *socket = new ClientSocket(this); socket->setSocketDescriptor(socketId);}InincomingConnection(), we create aClientSocketobject as a child of theTripServerobject, and we set its socket descriptor to the number provided to us.TheClientSocketobject will delete itself automatically when the connectionis terminated.class ClientSocket : public QTcpSocket{ Q_OBJECTpublic: ClientSocket(QObject *parent = 0);private slots: void readClient();private: void generateRandomTrip(const QString &from, const QString &to,  const QDate &date, const QTime &time); quint16 nextBlockSize;};TheClientSocketclass inherits fromQTcpSocketand encapsulates the state ofa single client.ClientSocket::ClientSocket(QObject *parent) : QTcpSocket(parent){ connect(this, SIGNAL(readyRead()), this, SLOT(readClient())); connect(this, SIGNAL(disconnected()), this, SLOT(deleteLater()));"},{"pageNumber":349,"pageContent":"Writing TCP Client–Server Applications331 nextBlockSize = 0;}In the constructor, we establish the necessary signal–slot connections, and weset thenextBlockSizevariable to 0, indicating that we do not yet know the sizeof the block sent by the client.Thedisconnected()signal is connected todeleteLater(), aQObject-inheritedfunction that deletes the object when control returns to Qt’s event loop. Thisensures that theClientSocketobject is deleted when the socket connectionis closed.void ClientSocket::readClient(){ QDataStream in(this); in.setVersion(QDataStream::Qt_4_1); if (nextBlockSize == 0) { if (bytesAvailable() < sizeof(quint16)) return; in >> nextBlockSize; } if (bytesAvailable() < nextBlockSize) return; quint8 requestType; QString from; QString to; QDate date; QTime time; quint8 flag; in >> requestType; if (requestType == ’S’) { in >> from >> to >> date >> time >> flag; srand(from.length() * 3600 + to.length() * 60 + time.hour()); int numTrips = rand() % 8; for (int i = 0; i < numTrips; ++i) generateRandomTrip(from, to, date, time); QDataStream out(this); out << quint16(0xFFFF); } close();}ThereadClient()slot is connected toQTcpSocket’sreadyRead()signal. Ifnext-BlockSizeis 0, we start by reading the block size; otherwise, we have alreadyread it, and instead we check to see if a whole block has arrived. Once an entireblock is ready for reading, we read it in one go. We use theQDataStreamdirectlyon theQTcpSocket(thethisobject) and read the fields using the>>operator."},{"pageNumber":350,"pageContent":"33214. NetworkingOnce we have read the client’s request, we are ready to generate a reply. If thiswere a real application, we would look up the information in a train scheduledatabase and try to find matching train trips. But here we will be content witha function calledgenerateRandomTrip()that will generate a random trip. We callthe function a random number of times, and then we send0xFFFFto signify theend of the data. At the end, we close the connection.void ClientSocket::generateRandomTrip(const QString & /* from */, const QString & /* to */, const QDate &date, const QTime &time){ QByteArray block; QDataStream out(&block, QIODevice::WriteOnly); out.setVersion(QDataStream::Qt_4_1); quint16 duration = rand() % 200; out << quint16(0) << date << time << duration << quint8(1) << QString(\"InterCity\"); out.device()->seek(0); out << quint16(block.size() - sizeof(quint16)); write(block);}ThegenerateRandomTrip()function shows how to send a block of data overa TCP connection. This is very similar to what we did in the client in thesendRequest()function (p. 326). Once again, we write the block to aQByteArrayso that we can determine its size before we send it usingwrite().int main(int argc, char *argv[]){ QApplication app(argc, argv); TripServer server; if (!server.listen(QHostAddress::Any, 6178)) { cerr << \"Failed to bind to port\" << endl; return 1; } QPushButton quitButton(QObject::tr(\"&Quit\")); quitButton.setWindowTitle(QObject::tr(\"Trip Server\")); QObject::connect(&quitButton, SIGNAL(clicked()), &app, SLOT(quit())); quitButton.show(); return app.exec();}Inmain(), we create aTripServerobject and aQPushButtonthat enables the userto stop the server. We start the server by callingQTcpSocket::listen(), whichtakes the IP address and port number on which we want to accept connections.The special address 0.0.0.0 (QHostAddress::Any) signifies any IP interfacepresent on the local host.This completes our client–server example. In this case, we used a block-oriented protocol that allows us to useQDataStreamfor reading and writing. Ifwe wanted to use a line-oriented protocol, the simplest approach would be to"},{"pageNumber":351,"pageContent":"Writing TCP Client–Server Applications333useQTcpSocket’scanReadLine()andreadLine()functions in a slot connected tothereadyRead()signal:QStringList lines;while (tcpSocket.canReadLine()) lines.append(tcpSocket.readLine());We would then process each line that has been read. As for sending data, thatcan be done using aQTextStreamon theQTcpSocket.The server implementation that we have used doesn’t scale very well whenthere are lots of connections. The problem is that while we are processing a re-quest, we don’t handle the other connections. A more scalable approach wouldbe to start a new thread for each connection. The Threaded Fortune Serverexample located in Qt’sexamples/network/threadedfortuneserverdirectory illus-trates how to do this.Sending and Receiving UDP DatagramsTheQUdpSocketclass can be used to send and receive UDP datagrams. UDP isan unreliable, datagram-oriented protocol. Some application-level protocolsuse UDP because it is more lightweight than TCP. With UDP, data is sentas packets (datagrams) from one host to another. There is no concept ofconnection, and if a UDP packet doesn’t get delivered successfully, no error isreported to the sender.Figure 14.3.The Weather Station applicationWe will see how to use UDP from a Qt application through the Weather Bal-loon and Weather Station example. The Weather Balloon application mimicsa weather balloon that sends a UDP datagram (presumably using a wirelessconnection) containing the current atmospheric conditions every 2 seconds.The Weather Station application receives these datagrams and displays themon screen. We will start by reviewing the code for the Weather Balloon.class WeatherBalloon : public QPushButton{ Q_OBJECT"},{"pageNumber":352,"pageContent":"33414. Networkingpublic: WeatherBalloon(QWidget *parent = 0); double temperature() const; double humidity() const; double altitude() const;private slots: void sendDatagram();private: QUdpSocket udpSocket; QTimer timer;};TheWeatherBalloonclass inherits fromQPushButton. It uses itsQUdpSocketprivatevariable for communicating with the Weather Station.WeatherBalloon::WeatherBalloon(QWidget *parent) : QPushButton(tr(\"Quit\"), parent){ connect(this, SIGNAL(clicked()), this, SLOT(close())); connect(&timer, SIGNAL(timeout()), this, SLOT(sendDatagram())); timer.start(2 * 1000); setWindowTitle(tr(\"Weather Balloon\"));}In the constructor, we start aQTimerto invokesendDatagram()every 2 seconds.void WeatherBalloon::sendDatagram(){ QByteArray datagram; QDataStream out(&datagram, QIODevice::WriteOnly); out.setVersion(QDataStream::Qt_4_1); out << QDateTime::currentDateTime() << temperature() << humidity() << altitude(); udpSocket.writeDatagram(datagram, QHostAddress::LocalHost, 5824);}InsendDatagram(), we generate and send a datagram containing the currentdate, time, temperature, humidity, and altitude:QDateTimeDate and time of measurementdoubleTemperature (in °C)doubleHumidity (in %)doubleAltitude (in meters)The datagram is sent usingQUdpSocket::writeDatagram(). The second and thirdarguments towriteDatagram()are the IP address and the port number of thepeer (the Weather Station). For this example, we assume that the WeatherStation is running on the same machine as the Weather Balloon, so we use"},{"pageNumber":353,"pageContent":"Sending and Receiving UDP Datagrams335an IP address of 127.0.0.1 (QHostAddress::LocalHost), a special address thatdesignates the local host.Unlike theQAbstractSocketsubclasses,QUdpSocketdoes not accept host names,only host addresses. If we wanted to resolve a host name to its IP address here,we have two choices: If we are prepared to block while the lookup takes place,we can use the staticQHostInfo::fromName()function. Otherwise, we can usethe staticQHostInfo::lookupHost()function, which returns immediately andcalls the slot it is passed with aQHostInfoobject containing the correspondingaddresses when the lookup is complete.int main(int argc, char *argv[]){ QApplication app(argc, argv); WeatherBalloon balloon; balloon.show(); return app.exec();}Themain()function simply creates aWeatherBalloonobject, which serves bothas a UDP peer and as aQPushButtonon screen. By clicking theQPushButton, theuser can quit the application.Now let’s review the source code for the Weather Station client.class WeatherStation : public QDialog{ Q_OBJECTpublic: WeatherStation(QWidget *parent = 0);private slots: void processPendingDatagrams();private: QUdpSocket udpSocket; QLabel *dateLabel; QLabel *timeLabel;••• QLineEdit *altitudeLineEdit;};TheWeatherStationclass inherits fromQDialog. It listens to a particular UDPport, parses any incoming datagrams (from the Weather Balloon), and displaystheir contents in five read-onlyQLineEdits. The only private variable of interesthere isudpSocketof typeQUdpSocket, which we will use to receive datagrams.WeatherStation::WeatherStation(QWidget *parent) : QDialog(parent){ udpSocket.bind(5824); connect(&udpSocket, SIGNAL(readyRead()),"},{"pageNumber":354,"pageContent":"33614. Networking this, SLOT(processPendingDatagrams()));•••}In the constructor, we start by binding theQUdpSocketto the port that theweather balloon is transmitting to. Since we have not specified a host address,the socket will accept datagrams sent to any IP address that belongs to themachine the Weather Station is running on. Then, we connect the socket’sreadyRead()signal to the privateprocessPendingDatagrams()that extracts anddisplays the data.void WeatherStation::processPendingDatagrams(){ QByteArray datagram; do { datagram.resize(udpSocket.pendingDatagramSize()); udpSocket.readDatagram(datagram.data(), datagram.size()); } while (udpSocket.hasPendingDatagrams()); QDateTime dateTime; double temperature; double humidity; double altitude; QDataStream in(&datagram, QIODevice::ReadOnly); in.setVersion(QDataStream::Qt_4_1); in >> dateTime >> temperature >> humidity >> altitude; dateLineEdit->setText(dateTime.date().toString()); timeLineEdit->setText(dateTime.time().toString());temperatureLineEdit->setText(tr(\"%1°C\").arg(temperature)); humidityLineEdit->setText(tr(\"%1%\").arg(humidity)); altitudeLineEdit->setText(tr(\"%1 m\").arg(altitude));}TheprocessPendingDatagrams()slot is called when a datagram has arrived.QUdpSocketqueues the incoming datagrams and lets us access them one ata time. Normally, there should be only one datagram, but we can’t excludethe possibility that the sender would send a few datagrams in a row beforethereadyRead()signal is emitted. In that case, we can ignore all the data-grams except the last one, since the earlier ones contain obsolete atmosphericconditions.ThependingDatagramSize()function returns the size of the first pending data-gram. From the application’s point of view, datagrams are always sent andreceived as a single unit of data. This means that if any bytes are available,an entire datagram can be read. ThereadDatagram()call copies the contents ofthe first pending datagram into the specifiedchar *buffer (truncating data ifthe buffer is too small) and advances to the next pending datagram. Once wehave read all the datagrams, we decompose the last one (the one with the mostrecent atmospheric measurements) into its parts and populate theQLineEditswith the new data."},{"pageNumber":355,"pageContent":"Sending and Receiving UDP Datagrams337int main(int argc, char *argv[]){ QApplication app(argc, argv); WeatherStation station; station.show(); return app.exec();}Finally, inmain(), we create and show theWeatherStation.We have now finished our UDP sender and receiver. The applications areas simple as possible, with the Weather Balloon sending datagrams and theWeather Station receiving them. In most real-world applications, both appli-cations would need to both read and write on their socket. TheQUdpSocket::writeDatagram()functions can be passed a host address and port number, so theQUdpSocketcan read from the host and port it is bound to withbind(), and writeto some other host and port."},{"pageNumber":357,"pageContent":"15. XMLuReading XML with SAXuReading XML with DOMuWriting XMLXML (Extensible Markup Language) is a general-purpose text file format thatis popular for data interchange and data storage. Qt provides two distinctAPIs for reading XML documents as part of theQtXmlmodule:• SAX (Simple API for XML) reports “parsing events” directly to the appli-cation through virtual functions.• DOM (Document Object Model) converts an XML document into a treestructure, which the application can then navigate.There are many factors to take into account when choosing between DOM andSAX for a particular application. SAX is more low level and usually faster,which makes it especially appropriate both for simple tasks (like finding allthe occurrences of a given tag in an XML document) and for reading very largefiles that may not fit in memory. But for many applications, the convenienceoffered by DOM outweighs the potential speed and memory benefits of SAX.For writing XML files, two options are available as well: We can generate theXML by hand, or we can represent the data as a DOM tree in memory and askthe tree to write itself to a file.Reading XML with SAXSAX is a public domain de facto standard API for reading XML documents.Qt’s SAX classes are modeled after the SAX2 Java implementation, with somedifferences in naming to match the Qt conventions. For more informationabout SAX, seehttp://www.saxproject.org/.Qt provides a SAX-based non-validating XML parser calledQXmlSimpleReader.This parser recognizes well-formed XML and supports XML namespaces.When the parser goes through the document, it calls virtual functions inregistered handler classes to indicate parsing events. (These “parsing events”are unrelated to Qt events, such as key and mouse events.) For example, let’sassume the parser is analyzing the following XML document:339"},{"pageNumber":358,"pageContent":"34015. XML<doc> <quote>Ars longa vita brevis</quote></doc>The parser would call the following parsing event handlers:startDocument()startElement(\"doc\")startElement(\"quote\")characters(\"Ars longa vita brevis\")endElement(\"quote\")endElement(\"doc\")endDocument()The above functions are all declared inQXmlContentHandler. For simplicity, weomitted some of the arguments tostartElement()andendElement().QXmlContentHandleris just one of many handler classes that can be used in con-junction withQXmlSimpleReader. The others areQXmlEntityResolver,QXmlDTDHan-dler,QXmlErrorHandler,QXmlDeclHandler, andQXmlLexicalHandler. These classesonly declare pure virtual functions and give information about different kindsof parsing events. For most applications,QXmlContentHandlerandQXmlErrorHan-dlerare the only two that are needed.For convenience, Qt also providesQXmlDefaultHandler, a class that inheritsfrom all the handler classes and that provides trivial implementations forall the functions. This design, with many abstract handler classes and onetrivial subclass, is unusual for Qt; it was adopted to closely follow the modelJava implementation.We will now review an example that shows how to useQXmlSimpleReaderandQXmlDefaultHandlerto parse an ad hoc XML file format and render its contentsin aQTreeWidget. TheQXmlDefaultHandlersubclass is calledSaxHandler, and theformat it handles is that of a book index, with index entries and subentries.QXmlContentHandlerQXmlDTDHandlerQXmlLexicalHandlerQXmlErrorHandlerQXmlEntityResolverQXmlDeclHandlerQXmlDefaultHandlerSaxHandlerFigure 15.1.Inheritance tree forSaxHandlerHere’s the book index file that is displayed in theQTreeWidgetin Figure 15.2:<?xml version=\"1.0\"?><bookindex> <entry term=\"sidebearings\"> <page>10</page> <page>34-35</page>"},{"pageNumber":359,"pageContent":"Reading XML with SAX341 <page>307-308</page> </entry> <entry term=\"subtraction\"> <entry term=\"of pictures\"> <page>115</page> <page>244</page> </entry> <entry term=\"of vectors\"> <page>9</page> </entry> </entry></bookindex>Figure 15.2.A book index file displayed in aQTreeWidgetThe first step to implement the parser is to subclassQXmlDefaultHandler:class SaxHandler : public QXmlDefaultHandler{public: SaxHandler(QTreeWidget *tree); bool startElement(const QString &namespaceURI, const QString &localName, const QString &qName, const QXmlAttributes &attributes); bool endElement(const QString &namespaceURI, const QString &localName, const QString &qName); bool characters(const QString &str); bool fatalError(const QXmlParseException &exception);private: QTreeWidget *treeWidget; QTreeWidgetItem *currentItem; QString currentText;};TheSaxHandlerclass inheritsQXmlDefaultHandlerand reimplements fourfunctions:startElement(),endElement(),characters(), andfatalError(). The firstthree functions are declared inQXmlContentHandler; the last function is declaredinQXmlErrorHandler.SaxHandler::SaxHandler(QTreeWidget *tree){"},{"pageNumber":360,"pageContent":"34215. XML treeWidget = tree; currentItem = 0;}TheSaxHandlerconstructor accepts theQTreeWidgetwe want to populate withthe information stored in the XML file.bool SaxHandler::startElement(const QString & /* namespaceURI */,  const QString & /* localName */,  const QString &qName,  const QXmlAttributes &attributes){ if (qName == \"entry\") { if (currentItem) { currentItem = new QTreeWidgetItem(currentItem); } else { currentItem = new QTreeWidgetItem(treeWidget); } currentItem->setText(0, attributes.value(\"term\")); } else if (qName == \"page\") { currentText.clear(); } return true;}ThestartElement()function is called when the reader encounters a new open-ing tag. The third parameter is the tag’s name (or more precisely, its “qualifiedname”). The fourth parameter is the list of attributes. In this example, we ig-nore the first and second parameters. They are useful for XML files that useXML’s namespace mechanism, a subject that is discussed in detail in the refer-ence documentation.If the tag is<entry>, we create a newQTreeWidgetitem. If the tag is nested with-in another<entry>tag, the new tag defines a subentry in the index, and the newQTreeWidgetItemis created as a child of theQTreeWidgetItemthat represents theencompassing entry. Otherwise, we create theQTreeWidgetItemwithtreeWidgetas its parent, making it a top-level item. We callsetText()to set the text shownin column 0 to the value of the<entry>tag’stermattribute.If the tag is<page>, we set thecurrentTextto be an empty string. Thecur-rentTextserves as an accumulator for the text located between the<page>and</page>tags.At the end, we returntrueto tell SAX to continue parsing the file. If we wantedto report unknown tags as errors, we would returnfalsein those cases. Wewould then also reimplementerrorString()fromQXmlDefaultHandlerto returnan appropriate error message.bool SaxHandler::characters(const QString &str){ currentText += str; return true;}"},{"pageNumber":361,"pageContent":"Reading XML with SAX343Thecharacters()function is called to report character data in the XMLdocument. We simply append the characters to thecurrentTextvariable.bool SaxHandler::endElement(const QString & /* namespaceURI */,  const QString & /* localName */,  const QString &qName){ if (qName == \"entry\") { currentItem = currentItem->parent(); } else if (qName == \"page\") { if (currentItem) { QString allPages = currentItem->text(1); if (!allPages.isEmpty()) allPages += \", \"; allPages += currentText; currentItem->setText(1, allPages); } } return true;}TheendElement()function is called when the reader encounters a closing tag.Just as withstartElement(), the third parameter is the name of the tag.If the tag is</entry>, we update thecurrentItemprivate variable to point to thecurrentQTreeWidgetItem’s parent. This ensures that thecurrentItemvariable isrestored to the value it held before the corresponding<entry>tag was read.If the tag is</page>, we add the specified page number or page range to thecomma-separated list in the current item’s text in column 1.bool SaxHandler::fatalError(const QXmlParseException &exception){ QMessageBox::warning(0, QObject::tr(\"SAX Handler\"),  QObject::tr(\"Parse error at line %1, column \"  \"%2:\\n%3.\")  .arg(exception.lineNumber())  .arg(exception.columnNumber())  .arg(exception.message())); return false;}ThefatalError()function is called when the reader fails to parse the XML file.If this occurs, we simply display a message box, giving the line number, thecolumn number, and the parser’s error text.This completes the implementation of theSaxHandlerclass. Now let’s see howwe can make use of it:bool parseFile(const QString &fileName){ QStringList labels; labels << QObject::tr(\"Terms\") << QObject::tr(\"Pages\"); QTreeWidget *treeWidget = new QTreeWidget;"},{"pageNumber":362,"pageContent":"34415. XML treeWidget->setHeaderLabels(labels); treeWidget->setWindowTitle(QObject::tr(\"SAX Handler\")); treeWidget->show(); QFile file(fileName); QXmlInputSource inputSource(&file); QXmlSimpleReader reader; SaxHandler handler(treeWidget); reader.setContentHandler(&handler); reader.setErrorHandler(&handler); return reader.parse(inputSource);}We set up aQTreeWidgetwith two columns. Then we create aQFileobject forthe file that is to be read and aQXmlSimpleReaderto parse the file. We don’t needto open theQFileourselves;QXmlInputSourcedoes that automatically.Finally, we create aSaxHandlerobject, we install it on the reader both as acontent handler and as an error handler, and we callparse()on the reader toperform the parsing.Instead of passing a simple file object to theparse()function, we pass aQXml-InputSource. This class opens the file it is given, reads it (taking into accountany character encoding specified in the<?xml?>declaration), and provides aninterface through which the parser reads the file.InSaxHandler, we only reimplemented functions from theQXmlContentHandlerandQXmlErrorHandlerclasses. If we had implemented functions from otherhandler classes, we would also have needed to call their corresponding setterfunctions on the reader.To link the application against theQtXmllibrary, we must add this line to the.profile:QT += xmlReading XML with DOMDOM is a standard API for parsing XML developed by the World Wide WebConsortium (W3C). Qt provides a non-validating DOM Level 2 implementationfor reading, manipulating, and writing XML documents.DOM represents an XML file as a tree in memory. We can navigate throughthe DOM tree as much as we want, and we can modify the tree and save it backto disk as an XML file.Let’s consider the following XML document:<doc> <quote>Ars longa vita brevis</quote> <translation>Art is long, life is short</translation></doc>"},{"pageNumber":363,"pageContent":"Reading XML with DOM345It corresponds to the following DOM tree:DocumentElement (doc)Element (quote)Text (“Ars longa vita brevis”)Element (translation)Text (“Art is long, life is short”)The DOM tree contains nodes of different types. For example, anElementnodecorresponds to an opening tag and its matching closing tag. The material thatfalls between the tags appears as child nodes of theElementnode.In Qt, the node types (like all other DOM-related classes) have aQDomprefix.Thus,QDomElementrepresents anElementnode, andQDomTextrepresents aTextnode.Different types of nodes can have different kinds of child nodes. For example,anElementnode can contain otherElementnodes, and alsoEntityReference,Text,CDATASection,ProcessingInstruction, andCommentnodes. Figure 15.3 showswhich nodes can have which kinds of child nodes. The nodes shown in graycannot have any child nodes of their own.DocumentElementDocumentTypeProcessingInstructionCommentAttrEntityReferenceTextDocumentFragmentElementEntityReferenceEntityElementEntityReferenceTextCDATASectionProcessingInstructionCommentFigure 15.3.Parent–child relationships between DOM nodesTo illustrate how to use DOM for reading XML files, we will write a parser forthe book index file format described in the previous section (p. 340).class DomParser{public: DomParser(QIODevice *device, QTreeWidget *tree);private:"},{"pageNumber":364,"pageContent":"34615. XML void parseEntry(const QDomElement &element, QTreeWidgetItem *parent); QTreeWidget *treeWidget;};We define a class calledDomParserthat will parse a book index XML documentand display the result in aQTreeWidget. This class does not inherit from anyother class.DomParser::DomParser(QIODevice *device, QTreeWidget *tree){ treeWidget = tree; QString errorStr; int errorLine; int errorColumn; QDomDocument doc; if (!doc.setContent(device, true, &errorStr, &errorLine, &errorColumn)) { QMessageBox::warning(0, QObject::tr(\"DOM Parser\"),  QObject::tr(\"Parse error at line %1, \"  \"column %2:\\n%3\")  .arg(errorLine)  .arg(errorColumn)  .arg(errorStr)); return; } QDomElement root = doc.documentElement(); if (root.tagName() != \"bookindex\") return; QDomNode node = root.firstChild(); while (!node.isNull()) { if (node.toElement().tagName() == \"entry\") parseEntry(node.toElement(), 0); node = node.nextSibling(); }}In the constructor, we create aQDomDocumentobject and callsetContent()on itto have it read the XML document provided by theQIODevice. ThesetContent()function automatically opens the device if it isn’t already open. Then we calldocumentElement()on theQDomDocumentto obtain its singleQDomElementchild, andwe check that it is a<bookindex>element. We iterate over all the child nodes,and if the node is an<entry>element, we callparseEntry()to parse it.TheQDomNodeclass can store any type of node. If we want to process a nodefurther, we must first convert it to the right data type. In this example, we onlycare aboutElementnodes, so we calltoElement()on theQDomNodeto convert it toaQDomElementand then calltagName()to retrieve the element’s tag name. If thenode isnotof typeElement, thetoElement()function returns a nullQDomElementobject, with an empty tag name."},{"pageNumber":365,"pageContent":"Reading XML with DOM347void DomParser::parseEntry(const QDomElement &element,  QTreeWidgetItem *parent){ QTreeWidgetItem *item; if (parent) { item = new QTreeWidgetItem(parent); } else { item = new QTreeWidgetItem(treeWidget); } item->setText(0, element.attribute(\"term\")); QDomNode node = element.firstChild(); while (!node.isNull()) { if (node.toElement().tagName() == \"entry\") { parseEntry(node.toElement(), item); } else if (node.toElement().tagName() == \"page\") { QDomNode childNode = node.firstChild(); while (!childNode.isNull()) { if (childNode.nodeType() == QDomNode::TextNode) { QString page = childNode.toText().data(); QString allPages = item->text(1); if (!allPages.isEmpty()) allPages += \", \"; allPages += page; item->setText(1, allPages); break; } childNode = childNode.nextSibling(); } } node = node.nextSibling(); }}InparseEntry(), we create aQTreeWidgetitem. If the tag is nested within an-other<entry>tag, the new tag defines a subentry in the index, and we createtheQTreeWidgetItemas a child of theQTreeWidgetItemthat represents the encom-passing entry. Otherwise, we create theQTreeWidgetItemwithtreeWidgetas itsparent, making it a top-level item. We callsetText()to set the text shown incolumn 0 to the value of the<entry>tag’stermattribute.Once we have initialized theQTreeWidgetItem, we iterate over the child nodes oftheQDomElementnode corresponding to the current<entry>tag.If the element is<entry>, we callparseEntry()with the current item as thesecond argument. The new entry’sQTreeWidgetItemwill then be created withthe encompassing entry’sQTreeWidgetItemas its parent.If the element is<page>, we navigate through the element’s child list to find aTextnode. Once we have found it, we calltoText()to convert it to aQDomTextobject anddata()to extract the text as aQString. Then we add the text to thecomma-separated list of page numbers in column 1 of theQTreeWidgetItem.Let’s now see how we can use theDomParserclass to parse a file:"},{"pageNumber":366,"pageContent":"34815. XMLvoid parseFile(const QString &fileName){ QStringList labels; labels << QObject::tr(\"Terms\") << QObject::tr(\"Pages\"); QTreeWidget *treeWidget = new QTreeWidget; treeWidget->setHeaderLabels(labels); treeWidget->setWindowTitle(QObject::tr(\"DOM Parser\")); treeWidget->show(); QFile file(fileName); DomParser(&file, treeWidget);}We start by setting up aQTreeWidget. Then we create aQFileand aDomParser.When theDomParseris constructed, it parses the file and populates the treewidget.Like the previous example, we need the following line in the application’s.profile to link against theQtXmllibrary:QT += xmlAs the example illustrates, navigating through a DOM tree can be cumber-some. Simply extracting the text between<page>and</page>required us toiterate through a list ofQDomNodes usingfirstChild()andnextSibling(). Pro-grammers who use DOM a lot often write their own higher-level wrapper func-tions to simplify commonly needed operations, such as extracting the text be-tween opening and closing tags.Writing XMLThere are basically two approaches for generating XML files from Qtapplications:• We can build a DOM tree and callsave()on it.• We can generate XML by hand.The choice between these approaches is often independent of whether we useSAX or DOM for reading XML documents.Here’s a code snippet that illustrates how we can create a DOM tree and writeit using aQTextStream: const int Indent = 4; QDomDocument doc; QDomElement root = doc.createElement(\"doc\"); QDomElement quote = doc.createElement(\"quote\"); QDomElement translation = doc.createElement(\"translation\"); QDomText latin = doc.createTextNode(\"Ars longa vita brevis\"); QDomText english = doc.createTextNode(\"Art is long, life is short\");"},{"pageNumber":367,"pageContent":"Writing XML349 doc.appendChild(root); root.appendChild(quote); root.appendChild(translation); quote.appendChild(latin); translation.appendChild(english); QTextStream out(&file); doc.save(out, Indent);The second argument tosave()is the indentation size to use. A non-zero valuemakes the file easier for humans to read. Here’s the XML file output:<doc> <quote>Ars longa vita brevis</quote> <translation>Art is long, life is short</translation></doc>Another scenario occurs in applications that use the DOM tree as their primarydata structure. These applications would normally read in XML documentsusing DOM, then modify the DOM tree in memory, and finally callsave()toconvert the tree back to XML.By default,QDomDocument::save()uses UTF-8 as the encoding for the generatedfile. We can use another encoding by prepending an XML declaration such as<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>to the DOM tree. The following code snippet shows how to do this:QTextStream out(&file);QDomNode xmlNode = doc.createProcessingInstruction(\"xml\",  \"version=\\\"1.0\\\" encoding=\\\"ISO-8859-1\\\"\");doc.insertBefore(xmlNode, doc.firstChild());doc.save(out, Indent);Generating XML files by hand isn’t much harder than using DOM. We can useQTextStreamand write the strings as we would do with any other text file. Themost tricky part is to escape special characters in text and attribute values.TheQt::escape()function escapes the characters ‘<’, ‘>’, and ‘&’. Here’s somecode that makes use of it:QTextStream out(&file);out.setCodec(\"UTF-8\");out << \"<doc>\\n\" << \" <quote>\" << Qt::escape(quoteText) << \"</quote>\\n\" << \" <translation>\" << Qt::escape(translationText) << \"</translation>\\n\" << \"</doc>\\n\";TheQt Quarterlyarticle “Generating XML”, available online athttp://doc.trolltech.com/qq/qq05-generating-xml.html, presents a very simple class thatmakes it easy to generate XML files. The class takes care of the details suchas special characters, indentation, and encoding issues, leaving us free toconcentrate on the XML we want to generate. The class was designed to workwith Qt 3 but it is trivial to port to Qt 4."},{"pageNumber":369,"pageContent":"16. Providing Online HelpuTooltips, Status Tips, and“What’s This?” HelpuUsing QTextBrowser as a Simple HelpEngineuUsing Qt Assistant for PowerfulOnline HelpMost applications provide their users with online help. Some help is short,such as tooltips, status tips, and “What’s This?” help. Naturally, Qt supportsall of these. Other help can be much more extensive, involving many pagesof text. For this kind of help, you can useQTextBrowseras a simple online helpbrowser, or you can invokeQt Assistantor an HTML browser from your appli-cation.Tooltips, Status Tips, and “What’s This?” HelpA tooltip is a small piece of text that appears when the mouse hovers over awidget for a certain period of time. Tooltips are presented with black text ona yellow background. Their primary use is to provide textual descriptions oftoolbar buttons.We can add tooltips to arbitrary widgets in code usingQWidget::setToolTip().For example:findButton->setToolTip(tr(\"Find next\"));To set the tooltip of aQActionthat could be added to a menu or a toolbar, wecan simply callsetToolTip()on the action. For example:newAction = new QAction(tr(\"&New\"), this);newAction->setToolTip(tr(\"New document\"));If we don’t explicitly set a tooltip,QActionwill automatically use the ac-tion text.A status tip is also a short piece of descriptive text, usually a little longer thana tooltip. When the mouse hovers over a toolbar button or a menu option, astatus tip appears in the status bar. CallsetStatusTip()to add a status tip toan action or to a widget:newAction->setStatusTip(tr(\"Create a new document\"));351"},{"pageNumber":370,"pageContent":"35216. Providing Online HelpFigure 16.1.An application showing a tooltip and a status tipIn some situations, it is desirable to provide more information about a widgetthan can be given by tooltips or status tips. For example, we might want toprovide a complex dialog with explanatory text about each field without forcingthe user to invoke a separate help window. “What’s This?” mode is an ideal so-lution for this. When a window is in “What’s This?” mode, the cursor changestoand the user can click on any user interface component to obtain its helptext. To enter “What’s This?” mode, the user can either click the?button in thedialog’s title bar (on Windows and KDE) or pressShift+F1.Here is an example of a “What’s This?” text set on a dialog:dialog->setWhatsThis(tr(\"<img src=\\\":/images/icon.png\\\">\" \"&nbsp;The meaning of the Source field depends \" \"on the Type field:\" \"<ul>\" \"<li><b>Books</b> have a Publisher\" \"<li><b>Articles</b> have a Journal name with \" \"volume and issue number\" \"<li><b>Theses</b> have an Institution name \" \"and a Department name\" \"</ul>\"));We can use HTML tags to format the text of a “What’s This?” text. In theexample, we include an image (which is listed in the application’s resource file),a bulleted list, and some text in bold. The tags and attributes that Qt supportsare specified athttp://doc.trolltech.com/4.1/richtext-html-subset.html."},{"pageNumber":371,"pageContent":"Tooltips, Status Tips, and “What’s This?” Help353Figure 16.2.A dialog showing a “What’s This?” help textWhen we set a “What’s This?” text on an action, the text will be shown whenthe user clicks the menu item or toolbar button or presses the shortcut keywhile in “What’s This?” mode. When the user interface components of an ap-plication’s main window provide “What’s This?” text, it is customary to provideaWhat’s This?option in theHelpmenu and a corresponding toolbar button. Thiscan be done by creating aWhat’s This?action with the staticQWhatsThis::cre-ateAction()function and adding the action it returns to aHelpmenu and to atoolbar. TheQWhatsThisclass also provides static functions to programmaticallyenter and leave “What’s This?” mode.Using QTextBrowser as a Simple Help EngineLarge applications may require more online help than tooltips, status tips, and“What’s This?” help can reasonably show. A simple solution to this is to providea help browser. Applications that include a help browser typically have aHelpentry in the main window’sHelpmenu and aHelpbutton in every dialog.In this section, we present the simple help browser shown in Figure 16.3 andexplain how it can be used within an application. The window uses aQText-Browserto display help pages that are marked up with an HTML-based syntax.QTextBrowsercan handle a lot of HTML tags, so it is ideal for this purpose.We begin with the header file:#include <QWidget>class QPushButton;class QTextBrowser;class HelpBrowser : public QWidget{ Q_OBJECT"},{"pageNumber":372,"pageContent":"35416. Providing Online Helppublic: HelpBrowser(const QString &path, const QString &page, QWidget *parent = 0); static void showPage(const QString &page);private slots: void updateWindowTitle();private: QTextBrowser *textBrowser; QPushButton *homeButton; QPushButton *backButton; QPushButton *closeButton;};TheHelpBrowserprovides a static function that can be called from anywherein the application. This function creates aHelpBrowserwindow and shows thegiven page.Figure 16.3.TheHelpBrowserwidgetHere’s the beginning of the implementation:#include <QtGui>#include \"helpbrowser.h\"HelpBrowser::HelpBrowser(const QString &path, const QString &page,  QWidget *parent) : QWidget(parent){ setAttribute(Qt::WA_DeleteOnClose); setAttribute(Qt::WA_GroupLeader); textBrowser = new QTextBrowser; homeButton = new QPushButton(tr(\"&Home\"));"},{"pageNumber":373,"pageContent":"Using QTextBrowser as a Simple Help Engine355 backButton = new QPushButton(tr(\"&Back\")); closeButton = new QPushButton(tr(\"Close\")); closeButton->setShortcut(tr(\"Esc\")); QHBoxLayout *buttonLayout = new QHBoxLayout; buttonLayout->addWidget(homeButton); buttonLayout->addWidget(backButton); buttonLayout->addStretch(); buttonLayout->addWidget(closeButton); QVBoxLayout *mainLayout = new QVBoxLayout; mainLayout->addLayout(buttonLayout); mainLayout->addWidget(textBrowser); setLayout(mainLayout); connect(homeButton, SIGNAL(clicked()), textBrowser, SLOT(home())); connect(backButton, SIGNAL(clicked()), textBrowser, SLOT(backward())); connect(closeButton, SIGNAL(clicked()), this, SLOT(close())); connect(textBrowser, SIGNAL(sourceChanged(const QUrl &)), this, SLOT(updateWindowTitle())); textBrowser->setSearchPaths(QStringList() << path << \":/images\"); textBrowser->setSource(page);}We set theQt::WA_GroupLeaderattribute because we want to pop upHelpBrowserwindows from modal dialogs in addition to the main window. Modal dialogsnormally prevent the user from interacting with any other window in the ap-plication. However, after requesting help, the user must obviously be allowedto interact with both the modal dialog and with the help browser. Setting theQt::WA_GroupLeaderattribute makes this interaction possible.We provide two search paths, the first a path in the file system that containsthe application’s documentation, and the second the location of the imageresources. The HTML can include references to images in the file system in thenormal way and also references to image resources by using a path that beginswith:/(colon slash). Thepageparameter is the name of the documentationfile, with an optional HTML anchor.void HelpBrowser::updateWindowTitle(){ setWindowTitle(tr(\"Help: %1\").arg(textBrowser->documentTitle()));}Whenever the source page changes, theupdateWindowTitle()slot is called. ThedocumentTitle()function returns the text specified in the page’s<title>tag.void HelpBrowser::showPage(const QString &page){ QString path = QApplication::applicationDirPath() + \"/doc\"; HelpBrowser *browser = new HelpBrowser(path, page); browser->resize(500, 400); browser->show();}"},{"pageNumber":374,"pageContent":"35616. Providing Online HelpIn theshowPage()static function, we create theHelpBrowserwindow and thenshow it. The window will be destroyed automatically when the user closes it,since we set theQt::WA_DeleteOnCloseattribute in theHelpBrowserconstructor.For this example, we assume that the documentation is located in thedocsubdirectory of the directory containing the application’s executable. All thepages passed to theshowPage()function will be taken from this subdirectory.Now we are ready to invoke the help browser from the application. In theapplication’s main window, we would create aHelpaction and connect it to ahelp()slot that could look like this:void MainWindow::help(){ HelpBrowser::showPage(\"index.html\");}This assumes that the main help file is calledindex.html. For dialogs, we wouldconnect theHelpbutton to ahelp()slot that might look like this:void EntryDialog::help(){ HelpBrowser::showPage(\"forms.html#editing\");}Here we look in a different help file,forms.html, and scroll theQTextBrowsertotheeditinganchor.Using Qt Assistant for Powerful Online HelpQt Assistantis a redistributable online help application supplied by Trolltech.Its main virtues are that it supports indexing and full text search and that itcan handle documentation sets for multiple applications.To make use ofQt Assistant, we must incorporate the necessary code in ourapplication, and we must makeQt Assistantaware of our documentation.Communication between a Qt application andQt Assistantis handled bytheQAssistantClientclass, which is located in a separate library. To link thislibrary with an application, we must add the following line to the application’s.profile:CONFIG += assistantWe will now review the code of a newHelpBrowserclass that usesQt Assistant.#ifndef HELPBROWSER_H#define HELPBROWSER_Hclass QAssistantClient;class QString;class HelpBrowser{"},{"pageNumber":375,"pageContent":"Using Qt Assistant for Powerful Online Help357public: static void showPage(const QString &page);private: static QAssistantClient *assistant;};#endifHere’s the newhelpbrowser.cppfile:#include <QApplication>#include <QAssistantClient>#include \"helpbrowser.h\"QAssistantClient *HelpBrowser::assistant = 0;void HelpBrowser::showPage(const QString &page){ QString path = QApplication::applicationDirPath() + \"/doc/\" + page; if (!assistant) assistant = new QAssistantClient(\"\"); assistant->showPage(path);}TheQAssistantClientconstructor accepts a path string as its first argument,which it uses to locate theQt Assistantexecutable. By passing an empty path,we signify thatQAssistantClientshould look for the executable in thePATHenvironment variable.QAssistantClienthas ashowPage()function that acceptsa page name with an optional HTML anchor.The next step is to prepare a table of contents and an index for the documenta-tion. This is done by creating aQt Assistantprofile and writing a.dcffile thatprovides information about the documentation. All this is explained inQt As-sistant’s online documentation, so we will not duplicate that information here.An alternative to usingQTextBrowserorQt Assistantis to use platform-specificapproaches to providing online help. For Windows applications, it might bedesirable to create Windows HTML Help files and to provide access to themusing Microsoft Internet Explorer. You could use Qt’sQProcessclass or theActiveQt framework for this. For X11 applications, a suitable approach mightbe to provide HTML files and to launch a web browser usingQProcess. OnMac OS X, Apple Help provides similar functionality toQt Assistant.We have now reached the end of Part II. The chapters that follow in Part IIIcover more advanced and specialized features of Qt. The C++and Qt codingthey present are no more difficult than that seen in Part II, but some of theconcepts and ideas may be more challenging in those areas that are newto you."},{"pageNumber":377,"pageContent":"Part IIIAdvanced Qt"},{"pageNumber":379,"pageContent":"17. InternationalizationuWorking with UnicodeuMaking ApplicationsTranslation-AwareuDynamic Language SwitchinguTranslating ApplicationsIn addition to the Latin alphabet used for English and for many Europeanlanguages, Qt 4 also provides extensive support for the rest of the world’swriting systems:• Qt uses Unicode throughout the API and internally. No matter whatlanguage we use for the user interface, the application can support allusers alike.• Qt’s text engine can handle all the major non-Latin writing systems,including Arabic, Chinese, Cyrillic, Hebrew, Japanese, Korean, Thai, andthe Indic languages.• Qt’s layout engine supports right-to-left layouts for languages such asArabic and Hebrew.• Certain languages require special input methods for entering text. Editorwidgets such asQLineEditandQTextEditwork well with any input methodinstalled on the user’s system.Often, it isn’t enough to allow users to enter text in their native language;the entire user interface’s must be translated as well. Qt makes this easy:Simply wrap all user-visible strings with thetr()function (as we have donein earlier chapters) and use Qt’s supporting tools to prepare translation filesin the required languages. Qt provides a GUI tool calledQt Linguistfor useby translators.Qt Linguistis complemented by two command-line programs,lupdateandlrelease, which are typically run by the application’s developers.For most applications, a translation file is loaded at startup, based on the user’slocale settings. But in a few cases, it is also necessary for users to be able toswitch language at run-time. This is perfectly possible with Qt, although itdoes require a bit of extra work. And thanks to Qt’s layout system, the varioususer interface components will automatically adjust to make room for thetranslated texts when they are longer than the original texts.361"},{"pageNumber":380,"pageContent":"36217. InternationalizationWorking with UnicodeUnicode is a character encoding standard that supports most of the world’swriting systems. The original idea behind Unicode is that by using 16bits for storing characters instead of 8 bits, it would be possible to encodearound 65,000 characters instead of only 256.HUnicode contains ASCII andISO 8859-1 (Latin-1) as subsets at the same code positions. For example, thecharacter ‘A’ has value0x41in ASCII, Latin-1, and Unicode, and the character‘Â’ has value0xD1in both Latin-1 and Unicode.Qt’sQStringclass stores strings as Unicode. Each character in aQStringis a16-bitQCharrather than an 8-bitchar. Here are two ways of setting the firstcharacter of a string to ‘A’:str[0] = ’A’;str[0] = QChar(0x41);If the source file is encoded in Latin-1, specifying Latin-1 characters is justas easy:str[0] = ’N~’;And if the source file has another encoding, the numeric value works fine:str[0] = QChar(0xD1);We can specify any Unicode character by its numeric value. For example,here’s how to specify the Greek capital letter sigma (‘Σ’) and the euro currencysymbol (‘’):str[0] = QChar(0x3A3);str[0] = QChar(0x20AC);The numeric values of all the characters supported by Unicode are listedathttp://www.unicode.org/standard/. If you rarely need non-Latin-1 Unicodecharacters, looking up characters online is sufficient; but Qt provides moreconvenient ways of entering Unicode strings in a Qt program, as we will seelater in this section.Qt 4’s text engine supports the following writing systems on all platforms: Ara-bic, Chinese, Cyrillic, Greek, Hebrew, Japanese, Korean, Lao, Latin, Thai, andVietnamese. It also supports all the Unicode 4.1 scripts that don’t require anyspecial processing. In addition, the following writing systems are supported onX11 with Fontconfig and on recent versions of Windows: Bengali, Devanagari,Gujarati, Gurmukhi, Kannada, Khmer, Malayalam, Syriac, Tamil, Telugu,Thaana (Dhivehi), and Tibetan. Finally, Oriya is supported on X11, and Mon-golian and Sinhala are supported on Windows XP. Assuming that the properfonts are installed on the system, Qt can render text using any of these writingHRecent versions of the Unicode standard assign character values above 65,535. These characterscan be represented using sequences of two 16-bit values called “surrogate pairs”."},{"pageNumber":381,"pageContent":"Working with Unicode363systems. And assuming that the proper input methods are installed, users willbe able to enter text that uses these writing systems in their Qt applications.Programming withQCharis slightly different from programming withchar. Toobtain the numeric value of aQChar, callunicode()on it. To obtain the ASCII orLatin-1 value of aQChar(as achar), calltoLatin1(). For non-Latin-1 characters,toLatin1()returns ‘\\0’.If we know that all the strings in a program are ASCII, we can use standard<cctype>functions likeisalpha(),isdigit(), andisspace()on the return valueoftoLatin1(). However, it is generally better to useQChar’s member functions forperforming these operations, since they will work for any Unicode character.The functionsQCharprovides includeisPrint(),isPunct(),isSpace(),isMark(),isLetter(),isNumber(),isLetterOrNumber(),isDigit(),isSymbol(),isLower(), andisUpper(). For example, here’s one way to test that a character is a digit or anuppercase letter:if (ch.isDigit() || ch.isUpper()) ...The code snippet works for any alphabet that distinguishes between uppercaseand lowercase, including Latin, Greek, and Cyrillic.Once we have a Unicode string, we can use it anywhere in Qt’s API where aQStringis expected. It is then Qt’s responsibility to display it properly and toconvert it to the relevant encodings when talking to the operating system.Special care is needed when we read and write text files. Text files can use avariety of encodings, and it is often impossible to guess a text file’s encodingfrom its contents. By default,QTextStreamuses the system’s local 8-bit encoding(available asQTextCodec::codecForLocale()) for both reading and writing. ForAmerican and West European locales, this usually means Latin-1.If we design our own file format and want to be able to read and write arbitraryUnicode characters, we can save the data as Unicode by callingstream.setCodec(\"UTF-16\");stream.setGenerateByteOrderMark(true);before we start writing to theQTextStream. The data will then be saved in UTF-16, a format that requires two bytes per character, and will be prefixed with aspecial 16-bit value (the Unicode byte order mark,0xFFFE) identifying that thefile is in Unicode and whether the bytes are in little-endian or big-endian or-der. The UTF-16 format is identical to the memory representation of aQString,so reading and writing Unicode strings in UTF-16 can be very fast. However,there is an inherent overhead when saving pure ASCII data in UTF-16 format,since it stores two bytes for every character instead of just one.Other encodings can be specified by callingsetCodec()with an appropriateQTextCodec. AQTextCodecis an object that converts between Unicode and a givenencoding.QTextCodecs are used in a variety of contexts by Qt. Internally, they"},{"pageNumber":382,"pageContent":"36417. Internationalizationare used to support fonts, input methods, the clipboard, drag and drop, and filenames. But they are also available to us when we write Qt applications.When reading a text file,QTextStreamdetects Unicode automatically if the filestarts with the byte order mark. This behavior can be turned off by callingsetAutoDetectUnicode(false). If the data can’t be assumed to start with the byteorder mark, it is best to callsetCodec()with “UTF-16” before reading.Another encoding that supports the whole of Unicode is UTF-8. Its mainadvantage over UTF-16 is that it is a superset of ASCII. Any character in therange0x00to0x7Fis represented as a single byte. Other characters, includingLatin-1 characters above0x7F, are represented by multi-byte sequences. Fortext that is mostly ASCII, UTF-8 takes up about half the space consumed byUTF-16. To use UTF-8 withQTextStream, callsetCodec()with “UTF-8” as thecodec name before reading and writing.If we always want to read and write Latin-1 regardless of the user’s locale, wecan set the “ISO 8859-1” codec on theQTextStream. For example:QTextStream in(&file);in.setCodec(\"ISO 8859-1\");Some file formats specify their encoding in their header. The header is typi-cally plain ASCII to ensure that it is read correctly no matter what encodingis used (assuming that it is a superset of ASCII). The XML file format is aninteresting example of this. XML files are normally encoded as UTF-8 or UTF-16. The proper way to read them in is to callsetCodec()with “UTF-8”. If theformat is UTF-16,QTextStreamwill automatically detect this and adjust itself.The<?xml?>header of an XML file sometimes contains anencodingargument,for example:<?xml version=\"1.0\" encoding=\"EUC-KR\"?>SinceQTextStreamdoesn’t allow us to change the encoding once it has startedreading, the right way to respect an explicit encoding is to start reading thefile afresh, using the correct codec (obtained fromQTextCodec::codecForName()).In the case of XML, we can avoid having to handle the encoding ourselves byusing Qt’s XML classes, described in Chapter 15.Another use ofQTextCodecs is to specify the encoding of strings that occur in thesource code. Let’s consider for example a team of Japanese programmers whoare writing an application targeted primarily at Japan’s home market. Theseprogrammers are likely to write their source code in a text editor that uses anencoding such as EUC-JP or Shift-JIS. Such an editor allows them to type inJapanese characters seamlessly, so that they can write code like this:QPushButton *button = new QPushButton(tr(\"\"));By default, Qt interprets arguments totr()as Latin-1. To change this, call theQTextCodec::setCodecForTr()static function. For example:QTextCodec::setCodecForTr(QTextCodec::codecForName(\"EUC-JP\"));"},{"pageNumber":383,"pageContent":"Working with Unicode365This must be done before the first call totr(). Typically, we would do this inmain(), immediately after theQApplicationobject is created.Other strings specified in the program will still be interpreted as Latin-1strings. If the programmers want to enter Japanese characters in those aswell, they can explicitly convert them to Unicode using aQTextCodec:QString text = japaneseCodec->toUnicode(\"\");Alternatively, they can tell Qt to use a specific codec when converting betweenconst char *andQStringby callingQTextCodec::setCodecForCStrings():QTextCodec::setCodecForCStrings(QTextCodec::codecForName(\"EUC-JP\"));The techniques described above can be applied to any non-Latin-1 language,including Chinese, Greek, Korean, and Russian.Here’s a list of the encodings supported by Qt 4:• Apple Roman• Big5• Big5-HKSCS• EUC-JP• EUC-KR• GB18030-0• IBM 850• IBM 866• IBM 874• ISO 2022-JP• ISO 8859-1• ISO 8859-2• ISO 8859-3• ISO 8859-4• ISO 8859-5• ISO 8859-6• ISO 8859-7• ISO 8859-8• ISO 8859-9• ISO 8859-10• ISO 8859-13• ISO 8859-14• ISO 8859-15• ISO 8859-16• Iscii-Bng• Iscii-Dev• Iscii-Gjr• Iscii-Knd• Iscii-Mlm• Iscii-Ori• Iscii-Pnj• Iscii-Tlg• Iscii-Tml• JIS X 0201• JIS X 0208• KOI8-R• KOI8-U• MuleLao-1• ROMAN8• Shift-JIS• TIS-620• TSCII• UTF-8• UTF-16• UTF-16BE• UTF-16LE• Windows-1250• Windows-1251• Windows-1252• Windows-1253• Windows-1254• Windows-1255• Windows-1256• Windows-1257• Windows-1258• WINSAMI2For all of these,QTextCodec::codecForName()will always return a valid pointer.Other encodings can be supported by subclassingQTextCodec.Making Applications Translation-AwareIf we want to make our applications available in multiple languages, we mustdo two things:• Make sure that every user-visible string goes throughtr().• Load a translation (.qm) file at startup.Neither of these is necessary for applications that will never be translated.However, usingtr()requires almost no effort and leaves the door open fordoing translations at a later date."},{"pageNumber":384,"pageContent":"36617. InternationalizationThetr()function is a static function defined inQObjectand overridden in everysubclass defined with theQ_OBJECTmacro. When writing code inside aQObjectsubclass, we can calltr()without formality. A call totr()returns a translationif one is available; otherwise, the original text is returned.To prepare translation files, we must run Qt’slupdatetool. This tool extractsall the string literals that appear intr()calls and produces translation filesthat contain all of these strings ready to be translated. The files can then besent to a translator to have the translations added. This process is explainedin the “Translating Applications” section later in this chapter.Atr()call has the following general syntax:Context::tr(sourceText, comment)TheContextpart is the name of aQObjectsubclass defined with theQ_OBJECTmacro. We don’t need to specify it if we calltr()from a member function ofthe class in question. ThesourceTextpart is the string literal that needs to betranslated. Thecommentpart is optional; it can be used to provide additionalinformation to the translator.Here are a few examples:RockyWidget::RockyWidget(QWidget *parent) : QWidget(parent){ QString str1 = tr(\"Letter\"); QString str2 = RockyWidget::tr(\"Letter\"); QString str3 = SnazzyDialog::tr(\"Letter\"); QString str4 = SnazzyDialog::tr(\"Letter\", \"US paper size\");}The first two calls totr()have “RockyWidget” as context, and the last twocalls have “SnazzyDialog”. All four have “Letter” as source text. The last callalso has a comment to help the translator understand the meaning of thesource text.Strings in different contexts (classes) are translated independently of eachother. Translators typically work on one context at a time, often with theapplication running and showing the widget or dialog being translated.When we calltr()from a global function, we must specify the context explicitly.AnyQObjectsubclass in the application can be used as the context. If none isappropriate, we can always useQObjectitself. For example:int main(int argc, char *argv[]){ QApplication app(argc, argv);••• QPushButton button(QObject::tr(\"Hello Qt!\")); button.show(); return app.exec();}"},{"pageNumber":385,"pageContent":"Making Applications Translation-Aware367In every example so far, the context has been a class name. This is convenient,because we can almost always omit it, but this doesn’t have to be the case.The most general way of translating a string in Qt is to use theQApplication::translate()function, which accepts up to three arguments: the context, thesource text, and the optional comment. For example, here’s another way totranslate “Hello Qt!”:QApplication::translate(\"Global Stuff\", \"Hello Qt!\")This time, we put the text in the “Global Stuff ” context.Thetr()andtranslate()functions serve a dual purpose: They are markersthatlupdateuses to find user-visible strings, and at the same time they are C++functions that translate text. This has an impact on how we write code. Forexample, the following will not work:// WRONGconst char *appName = \"OpenDrawer 2D\";QString translated = tr(appName);The problem here is thatlupdatewill not be able to extract the “OpenDraw-er 2D” string literal, as it doesn’t appear inside atr()call. This means thatthe translator will not have the opportunity to translate the string. This issueoften arises in conjunction with dynamic strings:// WRONGstatusBar()->showMessage(tr(\"Host \" + hostName + \" found\"));Here, the string we pass totr()varies depending on the value ofhostName, sowe can’t reasonably expecttr()to translate it correctly.The solution is to useQString::arg():statusBar()->showMessage(tr(\"Host %1 found\").arg(hostName));Notice how it works: The string literal “Host %1 found” is passed totr(). As-suming that a French translation file is loaded,tr()would return somethinglike “Hôte %1 trouvé”. Then the “%1” parameter is replaced with the contentsof thehostNamevariable.Although it is generally inadvisable to calltr()on a variable, it can be madeto work. We must use theQT_TR_NOOP()macro to mark the string literals fortranslation before we assign them to a variable. This is mostly useful for staticarrays of strings. For example:void OrderForm::init(){ static const char * const flowers[] = { QT_TR_NOOP(\"Medium Stem Pink Roses\"), QT_TR_NOOP(\"One Dozen Boxed Roses\"), QT_TR_NOOP(\"Calypso Orchid\"), QT_TR_NOOP(\"Dried Red Rose Bouquet\"), QT_TR_NOOP(\"Mixed Peonies Bouquet\"), 0"},{"pageNumber":386,"pageContent":"36817. Internationalization }; for (int i = 0; flowers[i]; ++i) comboBox->addItem(tr(flowers[i]));}TheQT_TR_NOOP()macro simply returns its argument. Butlupdatewill extractall the strings wrapped inQT_TR_NOOP()so that they can be translated. Whenusing the variable later on, we calltr()to perform the translation as usual.Even though we have passedtr()a variable, the translation will still work.There is also aQT_TRANSLATE_NOOP()macro that works likeQT_TR_NOOP()but alsotakes a context. This macro is useful when initializing variables outside ofa class:static const char * const flowers[] = { QT_TRANSLATE_NOOP(\"OrderForm\", \"Medium Stem Pink Roses\"), QT_TRANSLATE_NOOP(\"OrderForm\", \"One Dozen Boxed Roses\"), QT_TRANSLATE_NOOP(\"OrderForm\", \"Calypso Orchid\"), QT_TRANSLATE_NOOP(\"OrderForm\", \"Dried Red Rose Bouquet\"), QT_TRANSLATE_NOOP(\"OrderForm\", \"Mixed Peonies Bouquet\"), 0};The context argument must be the same as the context given totr()ortranslate()later on.When we start usingtr()in an application, it’s easy to forget to surround someuser-visible strings with atr()call, especially when we are just beginning touse it. These missingtr()calls are eventually discovered by the translatoror, worse, by users of the translated application, when some strings appear inthe original language. To avoid this problem, we can tell Qt to forbid implicitconversions fromconst char *toQString. We do this by defining theQT_NO_CAST_FROM_ASCIIpreprocessor symbol before including any Qt header. The easiestway to ensure this symbol is set is to add the following line to the application’s.profile:DEFINES += QT_NO_CAST_FROM_ASCIIThis will force every string literal to require wrapping bytr()or byQLatin1String(), depending on whether it should be translated or not. Stringsthat are not suitably wrapped will produce a compile-time error, thereby com-pelling us to add the missingtr()orQLatin1String()call.Once we have wrapped every user-visible string by atr()call, the only thingleft to do to enable translation is to load a translation file. Typically, we woulddo this in the application’smain()function. For example, here’s how we wouldtry to load a translation file depending on the user’s locale:int main(int argc, char *argv[]){ QApplication app(argc, argv); QTranslator appTranslator;"},{"pageNumber":387,"pageContent":"Making Applications Translation-Aware369 appTranslator.load(\"myapp_\" + QLocale::system().name(),  qApp->applicationDirPath()); app.installTranslator(&appTranslator);••• return app.exec();}TheQLocale::system()function returns aQLocaleobject that provides informa-tion about the user’s locale. Conventionally, we use the locale’s name as partof the.qmfile name. Locale names can be more or less precise; for example,frspecifies a French-language locale,fr_CAspecifies a French Canadian locale,andfr_CA.ISO8859-15specifies a French Canadian locale with ISO 8859-15 en-coding (an encoding that supports ‘’, ‘Œ’, ‘œ’, and ‘Y ̈’).Assuming that the locale isfr_CA.ISO8859-15, theQTranslator::load()functionfirst tries to load the filemyapp_fr_CA.ISO8859-15.qm. If this file does not exist,load()next triesmyapp_fr_CA.qm, thenmyapp_fr.qm, and finallymyapp.qm, beforegiving up. Normally, we would only providemyapp_fr.qm, containing a standardFrench translation, but if we need a different file for French-speaking Canada,we can also providemyapp_fr_CA.qmand it will be used forfr_CAlocales.The second argument toQTranslator::load()is the directory where we wantload()to look for the translation file. In this case, we assume that the transla-tion files are located in the same directory as the executable.The Qt libraries contain a few strings that need to be translated. Trolltechprovides French, German, and Simplified Chinese translations in Qt’stransla-tionsdirectory. A few other languages are provided as well, but these are con-tributed by Qt users and are not officially supported. The Qt libraries’ trans-lation file should also be loaded:QTranslator qtTranslator;qtTranslator.load(\"qt_\" + QLocale::system().name(), qApp->applicationDirPath());app.installTranslator(&qtTranslator);AQTranslatorobject can only hold one translation file at a time, so we use a sep-arateQTranslatorfor Qt’s translation. Having just one file per translator is nota problem since we can install as many translators as we need.QApplicationwill use all of them when searching for a translation.Some languages, such as Arabic and Hebrew, are written right-to-left insteadof left-to-right. In those languages, the whole layout of the application mustbe reversed, and this is done by callingQApplication::setLayoutDirection(Qt::RightToLeft). The translation files for Qt contain a special marker called“LTR” that tells Qt whether the language is left-to-right or right-to-left, so wenormally don’t need to callsetLayoutDirection()ourselves.It may prove more convenient for our users if we supply our applications withthe translation files embedded in the executable, using Qt’s resource system.Not only does this reduce the number of files distributed as part of the product,it also avoids the risk of translation files getting lost or deleted by accident."},{"pageNumber":388,"pageContent":"37017. InternationalizationAssuming that the.qmfiles are located in atranslationssubdirectory in thesource tree, we would then have amyapp.qrcfile with the following contents:<!DOCTYPE RCC><RCC version=\"1.0\"><qresource> <file>translations/myapp_de.qm</file> <file>translations/myapp_fr.qm</file> <file>translations/myapp_zh.qm</file> <file>translations/qt_de.qm</file> <file>translations/qt_fr.qm</file> <file>translations/qt_zh.qm</file></qresource></RCC>The.profile would contain the following entry:RESOURCES = myapp.qrcFinally, inmain(), we must specify:/translationsas the path for the translationfiles. The leading colon indicates that the path refers to a resource as opposedto a file in the file system.We have now covered all that is required to make an application able to operateusing translations into other languages. But language and the directionof the writing system are not the only things that vary between countriesand cultures. An internationalized program must also take into account thelocal date and time formats, monetary formats, numeric formats, and stringcollation order. Qt includes aQLocaleclass that provides localized numeric anddate/time formats. To query other locale-specific information, we can use thestandard C++setlocale()andlocaleconv()functions.Some Qt classes and functions adapt their behavior to the locale:•QString::localeAwareCompare()compares two strings in a locale-dependentmanner. It is useful for sorting user-visible items.• ThetoString()function provided byQDate,QTime, andQDateTimereturns astring in a local format when called withQt::LocalDateas argument.• By default, theQDateEditandQDateTimeEditwidgets present dates in thelocal format.Finally, a translated application may need to use different icons in certainsituations rather than the original icons. For example, the left and rightarrows on a web browser’sBackandForwardbuttons should be swapped whendealing with a right-to-left language. We can do this as follows:if (QApplication::isRightToLeft()) { backAction->setIcon(forwardIcon); forwardAction->setIcon(backIcon);} else { backAction->setIcon(backIcon); forwardAction->setIcon(forwardIcon);}"},{"pageNumber":389,"pageContent":"Making Applications Translation-Aware371Icons that contain alphabetic characters very commonly need to be translated.For example, the letter ‘I’ on a toolbar button associated with a word processor’sItalicoption should be replaced by a ‘C’ in Spanish (Cursivo) and by a ‘K’ in Dan-ish, Dutch, German, Norwegian, and Swedish (Kursiv). Here’s a simple way todo it:if (tr(\"Italic\")[0] == ’C’) { italicAction->setIcon(iconC);} else if (tr(\"Italic\")[0] == ’K’) { italicAction->setIcon(iconK);} else { italicAction->setIcon(iconI);}An alternative is to use the resource system’s support for multiple locales. Inthe.qrcfile, we can specify a locale for a resource using thelangattribute.For example:<qresource> <file>italic.png</file></qresource><qresource lang=\"es\"> <file alias=\"italic.png\">cursivo.png</file></qresource><qresource lang=\"sv\"> <file alias=\"italic.png\">kursiv.png</file></qresource>If the user’s locale ises(Español),:/italic.pngbecomes a reference to thecursivo.pngimage. If the locale issv(Svenska), thekursiv.pngimage is used.For other locales,italic.pngis used.Dynamic Language SwitchingFor most applications, detecting the user’s preferred language inmain()andloading the appropriate.qmfiles there is perfectly satisfactory. But there aresome situations where users might need the ability to switch language dynam-ically. An application that is used continuously by different people in shiftsmay need to change language without having to be restarted. For example,applications used by call center operators, by simultaneous translators, and bycomputerized cash register operators often require this capability.Making an application able to switch language dynamically requires a littlemore work than loading a single translation at startup, but it is not difficult.Here’s what must be done:• Provide a means by which the user can switch language.• For every widget or dialog, set all of its translatable strings in a separatefunction (often calledretranslateUi()) and call this function when thelanguage changes."},{"pageNumber":390,"pageContent":"37217. InternationalizationLet’s review the relevant parts of a “call center” application’s source code. Theapplication provides aLanguagemenu to allow the user to set the language atrun-time. The default language is English.Figure 17.1.A dynamicLanguagemenuSince we don’t know which language the user will want to use when the appli-cation is started, we no longer load translations in themain()function. Instead,we will load them dynamically when they are needed, so all the code that weneed to handle translations must go in the main window and dialog classes.Let’s have a look at the application’sQMainWindowsubclass.MainWindow::MainWindow(){ journalView = new JournalView; setCentralWidget(journalView); qApp->installTranslator(&appTranslator); qApp->installTranslator(&qtTranslator); qmPath = qApp->applicationDirPath() + \"/translations\"; createActions(); createMenus(); retranslateUi();}In the constructor, we set the central widget to be aJournalView, aQTableWid-getsubclass. Then we set up a few private member variables related to trans-lation:• TheappTranslatorvariable is aQTranslatorobject used for storing thecurrent application’s translation.• TheqtTranslatorvariable is aQTranslatorobject used for storing Qt’stranslation.• TheqmPathvariable is aQStringthat specifies the path of the directory thatcontains the application’s translation files.At the end, we call thecreateActions()andcreateMenus()private functions tocreate the menu system, and we callretranslateUi(), also a private function, toset the user-visible strings for the first time."},{"pageNumber":391,"pageContent":"Dynamic Language Switching373void MainWindow::createActions(){ newAction = new QAction(this); connect(newAction, SIGNAL(triggered()), this, SLOT(newFile()));••• aboutQtAction = new QAction(this); connect(aboutQtAction, SIGNAL(triggered()), qApp, SLOT(aboutQt()));}ThecreateActions()function creates theQActionobjects as usual, but withoutsetting any of the texts or shortcut keys. These will be done inretranslate-Ui().void MainWindow::createMenus(){ fileMenu = new QMenu(this); fileMenu->addAction(newAction); fileMenu->addAction(openAction); fileMenu->addAction(saveAction); fileMenu->addAction(exitAction);••• createLanguageMenu(); helpMenu = new QMenu(this); helpMenu->addAction(aboutAction); helpMenu->addAction(aboutQtAction); menuBar()->addMenu(fileMenu); menuBar()->addMenu(editMenu); menuBar()->addMenu(reportsMenu); menuBar()->addMenu(languageMenu); menuBar()->addMenu(helpMenu);}ThecreateMenus()function creates menus, but does not give them any titles.Again, this will be done inretranslateUi().In the middle of the function, we callcreateLanguageMenu()to fill theLanguagemenu with the list of supported languages. We will review its source code ina moment. First, let’s look atretranslateUi():void MainWindow::retranslateUi(){ newAction->setText(tr(\"&New\")); newAction->setShortcut(tr(\"Ctrl+N\")); newAction->setStatusTip(tr(\"Create a new journal\"));••• aboutQtAction->setText(tr(\"About &Qt\")); aboutQtAction->setStatusTip(tr(\"Show the Qt library’s About box\")); fileMenu->setTitle(tr(\"&File\")); editMenu->setTitle(tr(\"&Edit\")); reportsMenu->setTitle(tr(\"&Reports\")); languageMenu->setTitle(tr(\"&Language\")); helpMenu->setTitle(tr(\"&Help\"));"},{"pageNumber":392,"pageContent":"37417. Internationalization setWindowTitle(tr(\"Call Center\"));}TheretranslateUi()function is where all thetr()calls for theMainWindowclassoccur. It is called at the end of theMainWindowconstructor and also every timea user changes the application’s language using theLanguagemenu.We set eachQAction’s text, shortcut key, and status tip. We also set eachQMenu’stitle, as well as the window title.ThecreateMenus()function presented earlier calledcreateLanguageMenu()topopulate theLanguagemenu with a list of languages:void MainWindow::createLanguageMenu(){ languageMenu = new QMenu(this); languageActionGroup = new QActionGroup(this); connect(languageActionGroup, SIGNAL(triggered(QAction *)), this, SLOT(switchLanguage(QAction *))); QDir dir(qmPath); QStringList fileNames = dir.entryList(QStringList(\"callcenter_*.qm\")); for (int i = 0; i < fileNames.size(); ++i) { QString locale = fileNames[i]; locale.remove(0, locale.indexOf(’_’) + 1); locale.truncate(locale.lastIndexOf(’.’)); QTranslator translator; translator.load(fileNames[i], qmPath); QString language = translator.translate(\"MainWindow\",  \"English\"); QAction *action = new QAction(tr(\"&%1 %2\")  .arg(i + 1).arg(language), this); action->setCheckable(true); action->setData(locale); languageMenu->addAction(action); languageActionGroup->addAction(action); if (language == \"English\") action->setChecked(true); }}Instead of hard-coding the languages supported by the application, we createone menu entry for each.qmfile located in the application’stranslationsdirec-tory. For simplicity, we assume that English also has a.qmfile. An alternativewould have been to callclear()on theQTranslatorobjects when the user choos-es English.One particular difficulty is to present a nice name for the language providedby each.qmfile. Just showing “en” for “English” or “de” for “Deutsch”, based on"},{"pageNumber":393,"pageContent":"Dynamic Language Switching375the name of the.qmfile, looks crude and will confuse some users. The solutionused increateLanguageMenu()is to check the translation of the string “English”in the “MainWindow” context. That string should be translated to “Deutsch”in a German translation, to “Français” in a French translation, and to “”in a Japanese translation.We create one checkableQActionfor each language and store the locale namein the action’s “data” item. We add them to aQActionGroupobject to ensure thatonly oneLanguagemenu item is checked at a time. When an action from thegroup is chosen by the user, theQActionGroupemits thetriggered(QAction *)signal, which is connected toswitchLanguage().void MainWindow::switchLanguage(QAction *action){ QString locale = action->data().toString(); appTranslator.load(\"callcenter_\" + locale, qmPath); qtTranslator.load(\"qt_\" + locale, qmPath); retranslateUi();}TheswitchLanguage()slot is called when the user chooses a language from theLanguagemenu. We load the translation files for the application and for Qt,and we callretranslateUi()to retranslate all the strings for the main window.On Windows, an alternative to providing aLanguagemenu is to respond toLo-caleChangeevents, a type of event emitted by Qt when it detects a change inthe environment’s locale. The event type exists on all platforms supported byQt, but is only actually generated on Windows, when the user changes the sys-tem’s locale settings (in the Control Panel’s Regional and Language Options).To handleLocaleChangeevents, we can reimplementQWidget::changeEvent()asfollows:void MainWindow::changeEvent(QEvent *event){ if (event->type() == QEvent::LocaleChange) { appTranslator.load(\"callcenter_\"  + QLocale::system().name(), qmPath); qtTranslator.load(\"qt_\" + QLocale::system().name(), qmPath); retranslateUi(); } QMainWindow::changeEvent(event);}If the user switches locale while the application is being run, we attempt toload the correct translation files for the new locale and callretranslateUi()to update the user interface. In all cases, we pass the event on to the baseclass’schangeEvent()function, since the base class may also be interested inLocaleChangeor other change events.We have now finished our review of theMainWindowcode. Next we will look atthe code for one of the application’s widget classes, theJournalViewclass, to seewhat changes are needed to make it support dynamic translation."},{"pageNumber":394,"pageContent":"37617. InternationalizationJournalView::JournalView(QWidget *parent) : QTableWidget(parent){••• retranslateUi();}TheJournalViewclass is aQTableWidgetsubclass. At the end of the constructor,we call the private functionretranslateUi()to set the widget’s strings. This issimilar to what we did forMainWindow.void JournalView::changeEvent(QEvent *event){ if (event->type() == QEvent::LanguageChange) retranslateUi(); QTableWidget::changeEvent(event);}We also reimplement thechangeEvent()function to callretranslateUi()onLan-guageChangeevents. Qt generates aLanguageChangeevent when the contents ofaQTranslatorcurrently installed onQApplicationchanges. In our application,this occurs when we callload()onappTranslatororqtTranslator, either fromMainWindow::switchLanguage()or fromMainWindow::changeEvent().LanguageChangeevents should not be confused withLocaleChangeevents.Locale-Changeevents are generated by the system and tell the application, “Maybe youshould load a new translation.”LanguageChangeevents are generated by Qt andtell the application’s widgets, “Maybe you should retranslate all your strings.”When we implementedMainWindow, we didn’t need to respond toLanguageChange.Instead, we simply calledretranslateUi()whenever we calledload()on aQTranslator.void JournalView::retranslateUi(){ QStringList labels; labels << tr(\"Time\") << tr(\"Priority\") << tr(\"Phone Number\") << tr(\"Subject\"); setHorizontalHeaderLabels(labels);}TheretranslateUi()function updates the column headers with newly translat-ed texts, completing the translation-related code of a hand written widget. Forwidgets and dialogs developed withQt Designer, theuictool automatically gen-erates a function similar to ourretranslateUi()function that is automaticallycalled in response toLanguageChangeevents.Translating ApplicationsTranslating a Qt application that containstr()calls is a three-step process:1. Runlupdateto extract all the user-visible strings from the application’ssource code."},{"pageNumber":395,"pageContent":"Translating Applications3772. Translate the application usingQt Linguist.3. Runlreleaseto generate binary.qmfiles that the application can loadusingQTranslator.Steps 1 and 3 are performed by application developers. Step 2 is handledby translators. This cycle can be repeated as often as necessary during theapplication’s development and lifetime.As an example, we will show how to translate the Spreadsheet applicationof Chapter 3. The application already containstr()calls around every user-visible string.First, we must modify the application’s.profile slightly to specify whichlanguages we want to support. For example, if we want to support Germanand French in addition to English, we would add the followingTRANSLATIONSentry tospreadsheet.pro:TRANSLATIONS = spreadsheet_de.ts \\ spreadsheet_fr.tsHere, we specify two translation files: one for German and one for French.These files will be created the first time we runlupdateand are updated everytime we subsequently runlupdate.These files normally have a.tsextension. They are in a straightforward XMLformat and are not as compact as the binary.qmfiles understood byQTranslator.It islrelease’s job to convert human-readable.tsfiles into machine-efficient.qmfiles. For the curious,.tsstands for “translation source” and.qmfor “Qtmessage” file.Assuming that we are located in the directory that contains the Spreadsheetapplication’s source code, we can runlupdateonspreadsheet.profrom thecommand line as follows:lupdate -verbose spreadsheet.proThe-verboseoption tellslupdateto provide more feedback than usual. Here’sthe expected output:Updating ’spreadsheet_de.ts’... Found 98 source texts (98 new and 0 already existing)Updating ’spreadsheet_fr.ts’... Found 98 source texts (98 new and 0 already existing)Every string that appears within atr()call in the application’s source code isstored in the.tsfiles, along with an empty translation. Strings that appear inthe application’s.uifiles are also included.Thelupdatetool assumes by default that the arguments totr()are Latin-1strings. If this isn’t the case, we must add aCODECFORTRentry to the.profile.For example:CODECFORTR = EUC-JP"},{"pageNumber":396,"pageContent":"37817. InternationalizationThis must be done in addition to callingQTextCodec::setCodecForTr()from theapplication’smain()function.Translations then need to be added to thespreadsheet_de.tsandspreadsheet_fr.tsfiles usingQt Linguist.To runQt Linguist, clickQt by Trolltech v4.x.y|Linguistin theStartmenu onWindows, typelinguiston the command line on Unix, or double-clickLinguistinthe Mac OS X Finder. To start adding translations to a.tsfile, clickFile|Openand choose the file to translate.The left-hand side ofQt Linguist’s main window shows the list of contexts forthe application being translated. For the Spreadsheet application, the con-texts are “FindDialog”, “GoToCellDialog”, “MainWindow”, “SortDialog”, and“Spreadsheet”. The top-right area is the list of source texts for the current con-text. Each source text is shown along with a translation and aDoneflag. Themiddle-right area is where we can enter a translation for the current sourceitem. The bottom-right area is a list of suggestions automatically provided byQt Linguist.Once we have a translated.tsfile, we need to convert it to a binary.qmfilefor it to be usable byQTranslator. To do this from withinQt Linguist, clickFile|Release. Typically, we would start by translating only a few strings and runthe application with the.qmfile to make sure that everything works properly.Figure 17.2.Qt Linguistin actionIf we want to regenerate the.qmfiles for all.tsfiles, we can use thelreleasetool as follows:lrelease -verbose spreadsheet.pro"},{"pageNumber":397,"pageContent":"Translating Applications379Assuming that we translated 19 strings to French and clicked theDoneflag for17 of them,lreleaseproduces the following output:Updating ’spreadsheet_de.qm’... Generated 0 translations (0 finished and 0 unfinished) Ignored 98 untranslated source textsUpdating ’spreadsheet_fr.qm’... Generated 19 translations (17 finished and 2 unfinished) Ignored 79 untranslated source textsUntranslated strings are shown in the original languages when running theapplication. TheDoneflag is ignored bylrelease; it can be used by translatorsto identify which translations are finished and which ones must be revisited.When we modify the source code of the application, the translation files maybecome out of date. The solution is to runlupdateagain, provide translationsfor the new strings, and regenerate the.qmfiles. Some development teamsfind it useful to runlupdatefrequently, while others prefer to wait until theapplication is almost ready to release.ThelupdateandQt Linguisttools are quite smart. Translations that are nolonger used are kept in the.tsfiles in case they are needed in later releases.When updating.tsfiles,lupdateuses an intelligent merging algorithm thatcan save translators considerable time with text that is the same or similar indifferent contexts.For more information aboutQt Linguist,lupdate, andlrelease, refer to theQt Linguistmanual athttp://doc.trolltech.com/4.1/linguist-manual.html.The manual contains a full explanation ofQt Linguist’s user interface and astep-by-step tutorial for programmers."},{"pageNumber":399,"pageContent":"18. MultithreadinguCreating ThreadsuSynchronizing ThreadsuCommunicating with the MainThreaduUsing Qt’s Classes in SecondaryThreadsConventional GUI applications have one thread of execution and perform oneoperation at a time. If the user invokes a time-consuming operation from theuser interface, the interface typically freezes while the operation is in progress.Chapter 7 (Event Processing) presents some solutions to this problem. Multi-threading is another solution.In a multithreaded application, the GUI runs in its own thread and the pro-cessing takes place in one or more other threads. This results in applicationsthat have responsive GUIs even during intensive processing. Another benefitof multithreading is that multiprocessor systems can execute several threadssimultaneously on different processors, resulting in better performance.In this chapter, we will start by showing how to subclassQThreadand how to useQMutex,QSemaphore, andQWaitConditionto synchronize threads. Then we will seehow to communicate with the main thread from secondary threads while theevent loop is running. Finally, we round off with a review of which Qt classescan be used in secondary threads and which cannot.Multithreading is a large topic with many books devoted exclusively to thesubject. Here it is assumed that you already understand the fundamentalsof multithreaded programming, so the focus is on explaining how to developmultithreaded Qt applications rather than on the subject of threading itself.Creating ThreadsProviding multiple threads in a Qt application is straightforward: We justsubclassQThreadand reimplement itsrun()function. To show how this works,we will start by reviewing the code for a very simpleQThreadsubclass thatrepeatedly prints a given string on a console.class Thread : public QThread{ Q_OBJECT381"},{"pageNumber":400,"pageContent":"38218. Multithreadingpublic: Thread(); void setMessage(const QString &message); void stop();protected: void run();private: QString messageStr; volatile bool stopped;};TheThreadclass inherits fromQThreadand reimplements therun()function. Itprovides two additional functions:setMessage()andstop().Thestoppedvariable is declared volatile because it is accessed from differentthreads and we want to be sure that it is freshly read every time it is needed.If we omitted thevolatilekeyword, the compiler might optimize access to thevariable, possibly leading to incorrect results.Thread::Thread(){ stopped = false;}We setstoppedtofalsein the constructor.void Thread::run(){ while (!stopped) cerr << qPrintable(messageStr); stopped = false; cerr << endl;}Therun()function is called to start executing the thread. As long as thestoppedvariable isfalse, the function keeps printing the given message to theconsole. The thread terminates when control leaves therun()function.void Thread::stop(){ stopped = true;}Thestop()function sets thestoppedvariable totrue, thereby tellingrun()tostop printing text to the console. This function can be called from any threadat any time. For the purposes of this example, we assume that assignment toaboolis an atomic operation. This is a reasonable assumption, consideringthat aboolcan only have two states. We will see later in this section how touseQMutexto guarantee that assigning to a variable is an atomic operation.QThreadprovides aterminate()function that terminates the execution of athread while it is still running. Usingterminate()is not recommended, since"},{"pageNumber":401,"pageContent":"Creating Threads383it can stop the thread at any point and does not give the thread any chance toclean up after itself. It is always safer to use astoppedvariable and astop()function as we did here.Figure 18.1.The Threads applicationWe will now see how to use theThreadclass in a small Qt application that usestwo threads, A and B, in addition to the main thread.class ThreadDialog : public QDialog{ Q_OBJECTpublic: ThreadDialog(QWidget *parent = 0);protected: void closeEvent(QCloseEvent *event);private slots: void startOrStopThreadA(); void startOrStopThreadB();private: Thread threadA; Thread threadB; QPushButton *threadAButton; QPushButton *threadBButton; QPushButton *quitButton;};TheThreadDialogclass declares two variables of typeThreadand some buttonsto provide a basic user interface.ThreadDialog::ThreadDialog(QWidget *parent) : QDialog(parent){ threadA.setMessage(\"A\"); threadB.setMessage(\"B\"); threadAButton = new QPushButton(tr(\"Start A\")); threadBButton = new QPushButton(tr(\"Start B\")); quitButton = new QPushButton(tr(\"Quit\")); quitButton->setDefault(true); connect(threadAButton, SIGNAL(clicked()), this, SLOT(startOrStopThreadA()));"},{"pageNumber":402,"pageContent":"38418. Multithreading connect(threadBButton, SIGNAL(clicked()), this, SLOT(startOrStopThreadB()));•••}In the constructor, we callsetMessage()to make the first thread repeatedlyprint ‘A’s and the second thread ‘B’s.void ThreadDialog::startOrStopThreadA(){ if (threadA.isRunning()) { threadA.stop(); threadAButton->setText(tr(\"Start A\")); } else { threadA.start(); threadAButton->setText(tr(\"Stop A\")); }}When the user clicks the button for thread A,startOrStopThreadA()stops thethread if it was running and starts it otherwise. It also updates the but-ton’s text.void ThreadDialog::startOrStopThreadB(){ if (threadB.isRunning()) { threadB.stop(); threadBButton->setText(tr(\"Start B\")); } else { threadB.start(); threadBButton->setText(tr(\"Stop B\")); }}The code forstartOrStopThreadB()is very similar.void ThreadDialog::closeEvent(QCloseEvent *event){ threadA.stop(); threadB.stop(); threadA.wait(); threadB.wait(); event->accept();}If the user clicksQuitor closes the window, we stop any running threads andwait for them to finish (usingQThread::wait()) before we callQCloseEvent::accept(). This ensures that the application exits in a clean state, although itdoesn’t really matter in this example.If you run the application and clickStart A, the console will be filled with ‘A’s.If you clickStart B, it will now fill with alternating sequences of ‘A’s and ‘B’s.ClickStop A, and now it will only print ‘B’s."},{"pageNumber":403,"pageContent":"Synchronizing Threads385Synchronizing ThreadsA common requirement for multithreaded applications is that of synchroniz-ing several threads. Qt provides the following synchronization classes:QMutex,QReadWriteLock,QSemaphore, andQWaitCondition.TheQMutexclass provides a means of protecting a variable or a piece of codeso that only one thread can access it at a time. The class provides alock()function that locks the mutex. If the mutex is unlocked, the current threadseizes it immediately and locks it; otherwise, the current thread is blockeduntil the thread that holds the mutex unlocks it. Either way, when the call tolock()returns, the current thread holds the mutex until it callsunlock(). TheQMutexclass also provides atryLock()function that returns immediately if themutex is already locked.For example, let’s suppose that we wanted to protect thestoppedvariable oftheThreadclass from the previous section with aQMutex. We would then add thefollowing data member toThread:private:••• QMutex mutex;};Therun()function would change to this:void Thread::run(){ forever { mutex.lock(); if (stopped) { stopped = false; mutex.unlock(); break; } mutex.unlock(); cerr << qPrintable(messageStr); } cerr << endl;}Thestop()function would become this:void Thread::stop(){ mutex.lock(); stopped = true; mutex.unlock();}Locking and unlocking a mutex in complex functions, or functions that useC++exceptions, can be error-prone. Qt offers theQMutexLockerconvenienceclass to simplify mutex handling.QMutexLocker’s constructor accepts aQMutex"},{"pageNumber":404,"pageContent":"38618. Multithreadingas argument and locks it.QMutexLocker’s destructor unlocks the mutex. Forexample, we could rewrite the previousrun()andstop()functions as follows:void Thread::run(){ forever { { QMutexLocker locker(&mutex); if (stopped) { stopped = false; break; } } cerr << qPrintable(messageStr); } cerr << endl;}void Thread::stop(){ QMutexLocker locker(&mutex); stopped = true;}One issue with using mutexes is that only one thread can access the samevariable at a time. In programs with lots of threads trying to read the samevariable simultaneously (without modify it), the mutex can be a serious per-formance bottleneck. In these cases, we can useQReadWriteLock, a synchroniza-tion class that allows simultaneous read-only access without compromisingperformance.In theThreadclass, it would make no sense to replaceQMutexwithQReadWriteLockto protect thestoppedvariable, because at most one thread might try to readthe variable at any given time. A more appropriate example would involve oneor many reader threads accessing some shared data and one or many writerthreads modifying the data. For example:MyData data;QReadWriteLock lock;void ReaderThread::run(){ ... lock.lockForRead(); access_data_without_modifying_it(&data); lock.unlock(); ...}void WriterThread::run(){ ... lock.lockForWrite(); modify_data(&data);"},{"pageNumber":405,"pageContent":"Synchronizing Threads387 lock.unlock(); ...}For convenience, we can use theQReadLockerandQWriteLockerclasses to lockand unlock aQReadWriteLock.QSemaphoreis another generalization of mutexes, but unlike read/write locks,semaphores can be used to guard a certain number of identical resources. Thefollowing two code snippets show the correspondence betweenQSemaphoreandQMutex:QSemaphore semaphore(1);semaphore.acquire();semaphore.release();QMutex mutex; mutex.lock();mutex.unlock();By passing 1 to the constructor, we tell the semaphore that it controls a singleresource. The advantage of using a semaphore is that we can pass numbersother than 1 to the constructor and then callacquire()multiple times toacquire many resources.A typical application of semaphores is when transferring a certain amount ofdata (DataSize) between two threads using a shared circular buffer of a certainsize (BufferSize):const int DataSize = 100000;const int BufferSize = 4096;char buffer[BufferSize];The producer thread writes data to the buffer until it reaches the end and thenrestarts from the beginning, overwriting existing data. The consumer threadreads the data as it is generated. Figure 18.2 illustrates this, assuming a tiny16-byte buffer.0123456789 1011 12131415AAGCCTACconsumerconsumerproducerproducerSpaceusedSpace(5)SpacefreeSpace(11)Figure 18.2.The producer–consumer modelThe need for synchronization in the producer–consumer example is twofold:If the producer generates the data too fast, it will overwrite data that theconsumer hasn’t yet read; if the consumer reads the data too fast, it will passthe producer and read garbage.A crude way to solve this problem is to have the producer fill the buffer, thenwait until the consumer has read the entire buffer, and so on. However, on mul-tiprocessor machines, this isn’t as fast as letting the producer and consumerthreads operate on different parts of the buffer at the same time."},{"pageNumber":406,"pageContent":"38818. MultithreadingOne way to efficiently solve the problem involves two semaphores:QSemaphore freeSpace(BufferSize);QSemaphore usedSpace(0);ThefreeSpacesemaphore governs the part of the buffer that the producer canfill with data. TheusedSpacesemaphore governs the area that the consumercan read. These two areas are complementary. ThefreeSpacesemaphore isinitialized withBufferSize(4096), meaning that it has that many resourcesthat can be acquired. When the application starts, the reader thread willstart acquiring “free” bytes and convert them into “used” bytes. TheusedSpacesemaphore is initialized with 0 to ensure that the consumer won’t read garbageat startup.For this example, each byte counts as one resource. In a real-world application,we would probably operate on larger units (for example, 64 or 256 bytes at atime) to reduce the overhead associated with using semaphores.void Producer::run(){ for (int i = 0; i < DataSize; ++i) { freeSpace.acquire(); buffer[i % BufferSize] = \"ACGT\"[uint(rand()) % 4]; usedSpace.release(); }}In the producer, every iteration starts by acquiring one “free” byte. If thebuffer is full of data that the consumer hasn’t read yet, the call toacquire()will block until the consumer has started to consume the data. Once we haveacquired the byte, we fill it with some random data (‘A’, ‘C’, ‘G’, or ‘T’) andrelease the byte as “used”, so that it can be read by the consumer thread.void Consumer::run(){ for (int i = 0; i < DataSize; ++i) { usedSpace.acquire(); cerr << buffer[i % BufferSize]; freeSpace.release(); } cerr << endl;}In the consumer, we start by acquiring one “used” byte. If the buffer containsno data to read, the call toacquire()will block until the producer has producedsome. Once we have acquired the byte, we print it and release the byte as“free”, making it possible for the producer to fill it with data again.int main(){ Producer producer; Consumer consumer; producer.start();"},{"pageNumber":407,"pageContent":"Synchronizing Threads389 consumer.start(); producer.wait(); consumer.wait(); return 0;}Finally, inmain(), we start the producer and consumer threads. What happensthen is that the producer converts some “free” space into “used” space, and theconsumer can then convert it back to “free” space.When we run the program, it writes a random sequence of 100,000 ‘A’s, ‘C’s,‘G’s, and ‘T’s to the console and terminates. To really understand what isgoing on, we can disable writing the output and instead write ‘P’ each time theproducer generates a byte and ‘c’ each time the consumer reads a byte. Andto make things as simple to follow as possible, we can use smaller values forDataSizeandBufferSize.For example, here’s a possible run with aDataSizeof 10 and aBufferSizeof 4:“PcPcPcPcPcPcPcPcPcPc”. In this case, the consumer reads the bytes as soonas they are generated by the producer; the two threads are executing at thesame speed. Another possibility is that the producer fills the whole bufferbefore the consumer even starts reading it: “PPPPccccPPPPccccPPcc”. Thereare many other possibilities. Semaphores give a lot of latitude to the system-specific thread scheduler, which can study the threads’ behavior and choose anappropriate scheduling policy.A different approach to the problem of synchronizing a producer and a con-sumer is to useQWaitConditionandQMutex. AQWaitConditionallows a threadto wake up other threads when some condition has been met. This allowsfor more precise control than is possible with mutexes alone. To show how itworks, we will redo the producer–consumer example using wait conditions.const int DataSize = 100000;const int BufferSize = 4096;char buffer[BufferSize];QWaitCondition bufferIsNotFull;QWaitCondition bufferIsNotEmpty;QMutex mutex;int usedSpace = 0;In addition to the buffer, we declare twoQWaitConditions, oneQMutex, and onevariable that stores how many bytes in the buffer are “used” bytes.void Producer::run(){ for (int i = 0; i < DataSize; ++i) { mutex.lock(); while (usedSpace == BufferSize) bufferIsNotFull.wait(&mutex); buffer[i % BufferSize] = \"ACGT\"[uint(rand()) % 4]; ++usedSpace; bufferIsNotEmpty.wakeAll();"},{"pageNumber":408,"pageContent":"39018. Multithreading mutex.unlock(); }}In the producer, we start by checking whether the buffer is full. If it is, we waiton the “buffer is not full” condition. When that condition is met, we write onebyte to the buffer, incrementusedSpace, and wake any thread waiting for the“buffer is not empty” condition to turn true.We use a mutex to protect all accesses to theusedSpacevariable. TheQWaitCon-dition::wait()function can take a locked mutex as its first argument, which itunlocks before blocking the current thread and then locks before returning.For this example, we could have replaced thewhileloopwhile (usedSpace == BufferSize) bufferIsNotFull.wait(&mutex);with thisifstatement:if (usedSpace == BufferSize) { mutex.unlock(); bufferIsNotFull.wait(); mutex.lock();}However, this would break as soon as we allow more than one producer thread,since another producer could seize the mutex immediately after thewait()calland make the “buffer is not full” condition false again.void Consumer::run(){ for (int i = 0; i < DataSize; ++i) { mutex.lock(); while (usedSpace == 0) bufferIsNotEmpty.wait(&mutex); cerr << buffer[i % BufferSize]; --usedSpace; bufferIsNotFull.wakeAll(); mutex.unlock(); } cerr << endl;}The consumer does the exact opposite of the producer: It waits for the “bufferis not empty” condition and wakes up any thread waiting for the “buffer is notfull” condition.In all the examples so far, our threads have accessed the same global vari-ables. But some threaded applications need to have a global variable hold dif -ferent values in different threads. This is often called thread-local storage orthread-specific data. We can fake it using a map keyed on thread IDs (returnedbyQThread::currentThread()), but a nicer approach is to use theQThreadStor-age<T>class."},{"pageNumber":409,"pageContent":"Synchronizing Threads391A common use ofQThreadStorage<T>is for caches. By having a separate cachein different threads, we avoid the overhead of locking, unlocking, and possiblywaiting for a mutex. For example:QThreadStorage<QHash<int, double> *> cache;void insertIntoCache(int id, double value){ if (!cache.hasLocalData()) cache.setLocalData(new QHash<int, double>); cache.localData()->insert(id, value);}void removeFromCache(int id){ if (cache.hasLocalData()) cache.localData()->remove(id);}Thecachevariable holds one pointer to aQMap<int,double>per thread. (Becauseof problems with some compilers, the template type inQThreadStorage<T>mustbe a pointer type.) The first time we use the cache in a particular thread,has-LocalData()returnsfalseand we create theQHash<int,double>object.In addition to caching,QThreadStorage<T>can be used for global error-statevariables (similar toerrno) to ensure that modifications in one thread don’taffect other threads.Communicating with the Main ThreadWhen a Qt application starts, only one thread is running—the main thread.This is the only thread that is allowed to create theQApplicationorQCoreAppli-cationobject and callexec()on it. After the call toexec(), this thread is eitherwaiting for an event or processing an event.The main thread can start new threads by creating objects of aQThreadsub-class, as we did in the previous section. If these new threads need to communi-cate among themselves, they can use shared variables together with mutexes,read/write locks, semaphores, or wait conditions. But none of these techniquescan be used to communicate with the main thread, since they would lock theevent loop and freeze the user interface.The solution for communicating from a secondary thread to the main threadis to use signal–slot connections across threads. Normally, the signals andslots mechanism operates synchronously, meaning that the slots connected toa signal are invoked immediately when the signal is emitted, using a directfunction call.However, when we connect objects that “live” in different threads, the mech-anism becomes asynchronous. (This behavior can be changed through an op-tional fifth parameter toQObject::connect().) Behind the scenes, these connec-tions are implemented by posting an event. The slot is then called by the event"},{"pageNumber":410,"pageContent":"39218. Multithreadingloop of the thread in which the receiver object exists. By default, aQObjectex-ists in the thread in which it was created; this can be changed at any time bycallingQObject::moveToThread().Figure 18.3.The Image Pro applicationTo illustrate how signal–slot connections across threads work, we will reviewthe code of the Image Pro application, a basic image processing application thatallows the user to rotate, resize, and change the color depth of an image. Theapplication uses one secondary thread to perform operations on images withoutlocking the event loop. This makes a significant difference when processingvery large images. The secondary thread has a list of tasks, or “transactions”,to accomplish and sends events to the main window to report progress.ImageWindow::ImageWindow(){ imageLabel = new QLabel; imageLabel->setBackgroundRole(QPalette::Dark); imageLabel->setAutoFillBackground(true); imageLabel->setAlignment(Qt::AlignLeft | Qt::AlignTop); setCentralWidget(imageLabel); createActions(); createMenus(); statusBar()->showMessage(tr(\"Ready\"), 2000); connect(&thread, SIGNAL(transactionStarted(const QString &)), statusBar(), SLOT(showMessage(const QString &))); connect(&thread, SIGNAL(finished()), this, SLOT(allTransactionsDone())); setCurrentFile(\"\");}"},{"pageNumber":411,"pageContent":"Communicating with the Main Thread393The interesting part of theImageWindowconstructor is the two signal–slotconnections. Both of them involve signals emitted by theTransactionThreadobject, which we will cover in a moment.void ImageWindow::flipHorizontally(){ addTransaction(new FlipTransaction(Qt::Horizontal));}TheflipHorizontally()slot creates a “flip” transaction and registers it usingthe private functionaddTransaction(). TheflipVertically(),resizeImage(),convertTo32Bit(),convertTo8Bit(), andconvertTo1Bit()functions are similar.void ImageWindow::addTransaction(Transaction *transact){ thread.addTransaction(transact); openAction->setEnabled(false); saveAction->setEnabled(false); saveAsAction->setEnabled(false);}TheaddTransaction()function adds a transaction to the secondary thread’stransaction queue and disables theOpen,Save, andSave Asactions whiletransactions are being processed.void ImageWindow::allTransactionsDone(){ openAction->setEnabled(true); saveAction->setEnabled(true); saveAsAction->setEnabled(true); imageLabel->setPixmap(QPixmap::fromImage(thread.image())); setWindowModified(true); statusBar()->showMessage(tr(\"Ready\"), 2000);}TheallTransactionsDone()slot is called when theTransactionThread’s transac-tion queue becomes empty.Now, let’s turn to theTransactionThreadclass:class TransactionThread : public QThread{ Q_OBJECTpublic: void addTransaction(Transaction *transact); void setImage(const QImage &image); QImage image();signals: void transactionStarted(const QString &message);protected: void run();private:"},{"pageNumber":412,"pageContent":"39418. Multithreading QMutex mutex; QImage currentImage; QQueue<Transaction *> transactions;};TheTransactionThreadclass maintains a list of transactions to process andexecutes them one after the other in the background.void TransactionThread::addTransaction(Transaction *transact){ QMutexLocker locker(&mutex); transactions.enqueue(transact); if (!isRunning()) start();}TheaddTransaction()function adds a transaction to the transaction queue andstarts the transaction thread if it isn’t already running. All accesses to thetransactionsmember variable are protected by a mutex, because the mainthread might modify them throughaddTransaction()at the same time as thesecondary thread is iterating overtransactions.void TransactionThread::setImage(const QImage &image){ QMutexLocker locker(&mutex); currentImage = image;}QImage TransactionThread::image(){ QMutexLocker locker(&mutex); return currentImage;}ThesetImage()andimage()functions let the main thread set the image onwhich to perform the transactions and retrieve the resulting image once alltransactions are done. Again, we protect accesses to a member variable usinga mutex.void TransactionThread::run(){ Transaction *transact; forever { mutex.lock(); if (transactions.isEmpty()) { mutex.unlock(); break; } QImage oldImage = currentImage; transact = transactions.dequeue(); mutex.unlock(); emit transactionStarted(transact->message()); QImage newImage = transact->apply(oldImage);"},{"pageNumber":413,"pageContent":"Communicating with the Main Thread395 delete transact; mutex.lock(); currentImage = newImage; mutex.unlock(); }}Therun()function goes through the transaction queue and executes eachtransaction in turn by callingapply()on them.When a transaction is started, we emit thetransactionStarted()signal with amessage to display in the application’s status bar. When all the transactionshave finished processing, therun()function returns andQThreademits thefinished()signal.class Transaction{public: virtual ~Transaction() { } virtual QImage apply(const QImage &image) = 0; virtual QString message() = 0;};TheTransactionclass is an abstract base class for operations that the user canperform on an image. The virtual destructor is necessary because we need todelete instances ofTransactionsubclasses through aTransactionpointer. (Also,if we omit it, some compilers emit a warning.)Transactionhas three concretesubclasses:FlipTransaction,ResizeTransaction, andConvertDepthTransaction. Wewill only reviewFlipTransaction; the other two classes are similar.class FlipTransaction : public Transaction{public: FlipTransaction(Qt::Orientation orientation); QImage apply(const QImage &image); QString message();private: Qt::Orientation orientation;};TheFlipTransactionconstructor takes one parameter that specifies theorientation of the flip (horizontal or vertical).QImage FlipTransaction::apply(const QImage &image){ return image.mirrored(orientation == Qt::Horizontal,  orientation == Qt::Vertical);}Theapply()function callsQImage::mirrored()on theQImageit receives asparameter and returns the resultingQImage."},{"pageNumber":414,"pageContent":"39618. MultithreadingQString FlipTransaction::message(){ if (orientation == Qt::Horizontal) { return QObject::tr(\"Flipping image horizontally...\"); } else { return QObject::tr(\"Flipping image vertically...\"); }}Themessage()function returns the message to display in the status bar whilethe operation is in progress. This function is called inTransactionThread::run()when emitting thetransactionStarted()signal.Using Qt’s Classes in Secondary ThreadsA function is said to bethread-safewhen it can safely be called from differentthreads simultaneously. If two thread-safe functions are called from differentthreads on the same shared data, the result is always defined. By extension,a class is said to be thread-safe when all of its functions can be called fromdifferent threads simultaneously without interfering with each other, evenwhen operating on the same object.Qt’s thread-safe classes areQMutex,QMutexLocker,QReadWriteLock,QReadLocker,QWriteLocker,QSemaphore,QThreadStorage<T>,QWaitCondition, and parts of theQThreadAPI. In addition, several functions are thread-safe, includingQObject::connect(),QObject::disconnect(),QCoreApplication::postEvent(),QCoreApplica-tion::removePostedEvent(), andQCoreApplication::removePostedEvents().Most of Qt’s non-GUI classes meet a less stringent requirement: They arereentrant. A class is reentrant if different instances of the class can be usedsimultaneously in different threads. However, accessing the same reentrantobject in multiple threads simultaneously is not safe, and such accesses shouldbe protected with a mutex. Reentrant classes are marked as such in the Qtreference documentation. Typically, any C++class that doesn’t referenceglobal or otherwise shared data is reentrant.QObjectis reentrant, but there are three constraints to keep in mind:•Child QObjects must be created in their parent’s thread.In particular, this means that the objects created in a secondary threadmust never be created with theQThreadobject as their parent, because thatobject was created in another thread (either the main thread or a differentsecondary thread).•We must delete all QObjects created in a secondary thread beforedeleting the corresponding QThread object.This can be done by creating the objects on the stack inQThread::run()."},{"pageNumber":415,"pageContent":"Using Qt’s Classes in Secondary Threads397•QObjects must be deleted in the thread that created them.If we need to delete aQObjectthat exists in a different thread, we mustcall the thread-safeQObject::deleteLater()function instead, which postsa “deferred delete” event.Non-GUIQObjectsubclasses such asQTimer,QProcess, and the network classesare reentrant. We can use them in any thread, as long as the thread has anevent loop. For secondary threads, the event loop is started by callingQThread::exec()or by convenience functions such asQProcess::waitForFinished()andQAbstractSocket::waitForDisconnected().Because of limitations inherited from the low-level libraries on which Qt’s GUIsupport is built,QWidgetand its subclasses are not reentrant. One consequenceof this is that we cannot directly call functions on a widget from a secondarythread. If we want to, say, change the text of aQLabelfrom a secondary thread,we can emit a signal connected toQLabel::setText()or callQMetaObject::invokeMethod()from that thread. For example:void MyThread::run(){ ... QMetaObject::invokeMethod(label, SLOT(setText(const QString &)),  Q_ARG(QString, \"Hello\")); ...}Many of Qt’s non-GUI classes, includingQImage,QString, and the containerclasses, use implicit sharing as an optimization technique. While this optimiza-tion usually makes a class non-reentrant, in Qt this is not an issue because Qtuses atomic assembly language instructions to implement thread-safe refer-ence counting, making Qt’s implicitly shared classes reentrant.Qt’sQtSqlmodule can also be used in multithreaded applications, but it hasits own restrictions, which vary from database to database. For details, seehttp://doc.trolltech.com/4.1/sql-driver.html. For a complete list of multi-threading caveats, seehttp://doc.trolltech.com/4.1/threads.html."},{"pageNumber":417,"pageContent":"19. Creating PluginsuExtending Qt with PluginsuMaking Applications Plugin-AwareuWriting Application PluginsDynamic libraries (also called shared libraries or DLLs) are independentmodules that are stored in a separate file on disk and can be accessed bymultiple applications. Programs usually specify which dynamic libraries theyneed at link time, in which case the libraries are automatically loaded whenthe application starts. This approach usually involves adding the library andpossibly its include path to the application’s.profile and including the relevantheaders in the source files. For example:LIBS += -ldb_cxxINCLUDEPATH += /usr/local/BerkeleyDB.4.2/includeThe alternative is to dynamically load the library when it is required, andthen resolve the symbols that we want to use from it. Qt provides theQLibraryclass to achieve this in a platform-independent manner. Given the stem ofa library’s name,QLibrarysearches the platform’s standard locations for thelibrary looking for an appropriate file. For example, given the namemimetype,it will look formimetype.dllon Windows,mimetype.soon Linux, andmimetype.dylibon Mac OS X.Modern GUI applications can often be extended by the use of plugins. A pluginis a dynamic library that implements a particular interface to provide optionalextra functionality. For example, in Chapter 5, we created a plugin to integratea custom widget withQt Designer(p. 113).Qt recognizes its own set of plugin interfaces for various domains, includingimage formats, database drivers, widget styles, text encodings, and accessibil-ity. This chapter’s first section explains how to extend Qt with a Qt plugin.It is also possible to create application-specific plugins for particular Qt appli-cations. Qt makes writing such plugins easy through its plugin framework,which adds crash safety and convenience toQLibrary. In the last two sectionsof this chapter, we show how to make an application support plugins and howto create a custom plugin for an application.399"},{"pageNumber":418,"pageContent":"40019. Creating PluginsExtending Qt with PluginsQt can be extended with a variety of plugin types, the most common beingdatabase drivers, image formats, styles, and text codecs. For each type ofplugin, we normally need at least two classes: a plugin wrapper class thatimplements the generic plugin API functions, and one or more handler classesthat each implement the API for a particular type of plugin. The handlers areaccessed through the wrapper class.Plugin ClassHandler Base ClassQAccessibleBridgePluginQAccessibleBridgeQAccessiblePluginQAccessibleInterfaceQIconEnginePluginQIconEngineQImageIOPluginQImageIOHandlerQInputContextPluginQInputContextQPictureFormatPluginN/AQSqlDriverPluginQSqlDriverQStylePluginQStyleQTextCodecPluginQTextCodecFigure 19.1.Qt plugin and handler classes (excluding Qtopia Core)To demonstrate this, we will implement a plugin that can read monochromeWindows cursor files (.curfiles). These files can hold several images of thesame cursor at different sizes. Once the cursor plugin is built and installed,Qt will be able to read.curfiles and access individual cursors (for example,throughQImage,QImageReader, orQMovie), and will be able to write the cursorsout in any of Qt’s other image file formats, such as BMP, JPEG, and PNG. Theplugin could also be deployed with Qt applications since they automaticallycheck the standard locations for Qt plugins and load any that they find.New image format plugin wrappers must subclassQImageIOPluginand reimple-ment a few virtual functions:class CursorPlugin : public QImageIOPlugin{public: QStringList keys() const; Capabilities capabilities(QIODevice *device,  const QByteArray &format) const; QImageIOHandler *create(QIODevice *device,  const QByteArray &format) const;};Thekeys()function returns a list of the image formats the plugin supports.Theformatparameter of thecapabilities()andcreate()functions can beassumed to have a value from that list."},{"pageNumber":419,"pageContent":"Extending Qt with Plugins401QStringList CursorPlugin::keys() const{ return QStringList() << \"cur\";}Our plugin only supports one image format, so it returns a list with justone name. Ideally the name should be the file extension used by the format.When dealing with formats with several extensions (such as.jpgand.jpegforJPEG), we can return a list with several entries for the same format, one foreach extension.QImageIOPlugin::CapabilitiesCursorPlugin::capabilities(QIODevice *device,  const QByteArray &format) const{ if (format == \"cur\") return CanRead; if (format.isEmpty()) { CursorHandler handler; handler.setDevice(device); if (handler.canRead()) return CanRead; } return 0;}Thecapabilities()function returns what the image handler is capable ofdoing with the given image format. There are three capabilities (CanRead,CanWrite, andCanReadIncremental), and the return value is a bitwise OR of thosethat apply.If the format is “cur”, our implementation returnsCanRead. If no format isgiven, we create a cursor handler and check whether it is capable of readingthe data from the given device. ThecanRead()function only peeks at the data,seeing if it recognizes the file, without changing the file pointer. A capabilityof 0 means that the file cannot be read or written by this handler.QImageIOHandler *CursorPlugin::create(QIODevice *device,  const QByteArray &format) const{ CursorHandler *handler = new CursorHandler; handler->setDevice(device); handler->setFormat(format); return handler;}When a cursor file is opened (for example, byQImageReader), the plugin wrap-per’screate()function will be called with the device pointer and with “cur” asthe format. We create aCursorHandlerinstance and set it up with the specifieddevice and format. The caller takes ownership of the handler and will deleteit when it is no longer required. If multiple files are to be read, a fresh handlerwill be created for each one.q"},{"pageNumber":420,"pageContent":"40219. Creating PluginsQ_EXPORT_PLUGIN2(cursorplugin, CursorPlugin)At the end of the.cppfile, we use theQ_EXPORT_PLUGIN2()macro to ensurethat the plugin is recognized by Qt. The first parameter is an arbitraryname that we want to give to the plugin. The second parameter is the pluginclass name.SubclassingQImageIOPluginis straightforward. The real work of the plugin isdone in the handler. Image format handlers must subclassQImageIOHandlerandreimplement some or all of its public functions. Let’s start with the header:class CursorHandler : public QImageIOHandler{public: CursorHandler(); bool canRead() const; bool read(QImage *image); bool jumpToNextImage(); int currentImageNumber() const; int imageCount() const;private: enum State { BeforeHeader, BeforeImage, AfterLastImage, Error }; void readHeaderIfNecessary() const; QBitArray readBitmap(int width, int height, QDataStream &in) const; void enterErrorState() const; mutable State state; mutable int currentImageNo; mutable int numImages;};The signatures of all the public functions are fixed. We have omitted severalfunctions that we don’t need to reimplement for a read-only handler, in par-ticularwrite(). The member variables are declared with themutablekeywordbecause they are modified inside const functions.CursorHandler::CursorHandler(){ state = BeforeHeader; currentImageNo = 0; numImages = 0;}When the handler is constructed, we begin by setting its state. We set thecurrent cursor image number to the first cursor, but since we setnumImagesto0 it is clear that we have no images yet.bool CursorHandler::canRead() const{ if (state == BeforeHeader) { return device()->peek(4) == QByteArray(\"\\0\\0\\2\\0\", 4); } else {"},{"pageNumber":421,"pageContent":"Extending Qt with Plugins403 return state != Error; }}ThecanRead()function can be called at any time to determine whether theimage handler can read more data from the device. If the function is calledbefore we have read any data, while we are still in theBeforeHeaderstate, wecheck for the particular signature that identifies Windows cursor files. TheQIODevice::peek()call reads the first four byteswithoutchanging the device’sfile pointer. IfcanRead()is called later on, we returntrueunless an errorhas occurred.int CursorHandler::currentImageNumber() const{ return currentImageNo;}This trivial function returns the number of the cursor at which the device filepointer is positioned.Once the handler is constructed, it is possible for the user to call any of its pub-lic functions, in any order. This is a potential problem since we must assumethat we can only read serially, so we need to read the file header once before do-ing anything else. We solve the problem by calling thereadHeaderIfNecessary()function in those functions that depend on the header having been read.int CursorHandler::imageCount() const{ readHeaderIfNecessary(); return numImages;}This function returns the number of images in the file. For a valid file whereno reading errors have occurred, it will return a count of at least 1.Headerquint16reserved (0x0000)quint16type (0x0002)quint16image countImage 1quint32sizequint32widthquint32heightquint16planesquint16bits per pixelquint32compression(size+--20) + 8 bytes color tablewidth∗heightbytesXOR bitmapwidth∗heightbytesAND bitmap...Imagenquint32quint32quint32quint16...Figure 19.2.The.curfile format"},{"pageNumber":422,"pageContent":"40419. Creating PluginsThe next function is quite involved, so we will review it in pieces:bool CursorHandler::read(QImage *image){ readHeaderIfNecessary(); if (state != BeforeImage) return false;Theread()function reads the data for whichever image begins at the currentdevice pointer position. If the file’s header is read successfully, or after animage has been read and the device pointer is at the start of another image,we can read the next image. quint32 size; quint32 width; quint32 height; quint16 numPlanes; quint16 bitsPerPixel; quint32 compression; QDataStream in(device()); in.setByteOrder(QDataStream::LittleEndian); in >> size; if (size != 40) { enterErrorState(); return false; } in >> width >> height >> numPlanes >> bitsPerPixel >> compression; height /= 2; if (numPlanes != 1 || bitsPerPixel != 1 || compression != 0) { enterErrorState(); return false; } in.skipRawData((size - 20) + 8);We create aQDataStreamto read the device. We must set the byte order to matchthat specified by the.curfile format specification. There is no need to set aQDataStreamversion number since the format of integers and floating-pointnumbers does not vary between data stream versions. Next, we read in variousitems of cursor header data, and we skip the irrelevant parts of the header andthe 8-byte color table usingQDataStream::skipRawData().We must account for all the format’s idiosyncrasies—for example, halving theheight because the.curformat gives a height that is twice as high as the actualimage’s height. ThebitsPerPixelandcompressionvalues are always 1 and 0 ina monochrome.curfile. If we have any problems, we callenterErrorState()and returnfalse. QBitArray xorBitmap = readBitmap(width, height, in); QBitArray andBitmap = readBitmap(width, height, in);"},{"pageNumber":423,"pageContent":"Extending Qt with Plugins405 if (in.status() != QDataStream::Ok) { enterErrorState(); return false; }The next items in the file are two bitmaps, one an XOR mask and the other anAND mask. We read these intoQBitArrays rather than intoQBitmaps. AQBitmapis a class designed to be drawn on and painted on-screen, but what we needhere is a plain array of bits.When we are done with reading the file, we check theQDataStream’s status. Thisworks because if aQDataStreamenters an error state, it stays in that state andcan only return zeros. For example, if reading fails on the first bit array, theattempt to read the second will result in an emptyQBitArray. *image = QImage(width, height, QImage::Format_ARGB32); for (int i = 0; i < int(height); ++i) { for (int j = 0; j < int(width); ++j) { QRgb color; int bit = (i * width) + j; if (andBitmap.testBit(bit)) { if (xorBitmap.testBit(bit)) { color = 0x7F7F7F7F; } else { color = 0x00FFFFFF; } } else { if (xorBitmap.testBit(bit)) { color = 0xFFFFFFFF; } else { color = 0xFF000000; } } image->setPixel(j, i, color); } }We construct a newQImageof the correct size and setimageto point to it. Thenwe iterate over every pixel in the XOR and AND bit arrays and convert theminto 32-bit ARGB color specifications. The AND and XOR bit arrays are usedas shown in the following table to obtain the color of each cursor pixel:ANDXORResult11Inverted background pixel10Transparent pixel01White pixel00Black pixelBlack, white, and transparent pixels are no problem, but there’s no way ofobtaining an inverted background pixel using an ARGB color specification"},{"pageNumber":424,"pageContent":"40619. Creating Pluginswithout knowing the color of the original background pixel. As a substitute,we use a semi-transparent gray color (0x7F7F7F7F). ++currentImageNo; if (currentImageNo == numImages) state = AfterLastImage; return true;}Once we have finished reading the image, we update the current imagenumber and update the state if we have reached the last image. At the end ofthe function, the device will be positioned at the next image or at the end of thefile.qbool CursorHandler::jumpToNextImage(){ QImage image; return read(&image);}ThejumpToNextImage()function is used to skip an image. For simplicity, we sim-ply callread()and ignore the resultingQImage. A more efficient implementationwould use the information stored in the.curfile header to skip directly to theappropriate offset in the file.qvoid CursorHandler::readHeaderIfNecessary() const{ if (state != BeforeHeader) return; quint16 reserved; quint16 type; quint16 count; QDataStream in(device()); in.setByteOrder(QDataStream::LittleEndian); in >> reserved >> type >> count; in.skipRawData(16 * count); if (in.status() != QDataStream::Ok || reserved != 0 || type != 2 || count == 0) { enterErrorState(); return; } state = BeforeImage; currentImageNo = 0; numImages = int(count);}ThereadHeaderIfNecessary()private function is called fromimageCount()andread(). If the file’s header has already been read, the state is notBeforeHeaderand we return immediately. Otherwise, we open a data stream on the device,read in some generic data (including the number of cursors in the file), and set"},{"pageNumber":425,"pageContent":"Extending Qt with Plugins407the state toBeforeImage. At the end, the device’s file pointer is positioned beforethe first image.void CursorHandler::enterErrorState() const{ state = Error; currentImageNo = 0; numImages = 0;}If an error occurs, we assume that there are no valid images and set the statetoError. Once in theErrorstate, the handler’s state cannot change.QBitArray CursorHandler::readBitmap(int width, int height,  QDataStream &in) const{ QBitArray bitmap(width * height); quint8 byte; quint32 word; for (int i = 0; i < height; ++i) { for (int j = 0; j < width; ++j) { if ((j % 32) == 0) { word = 0; for (int k = 0; k < 4; ++k) { in >> byte; word = (word << 8) | byte; } } bitmap.setBit(((height - i - 1) * width) + j,  word & 0x80000000); word <<= 1; } } return bitmap;}ThereadBitmap()function is used to read a cursor’s AND and XOR masks.These masks have two unusual features. First, they store the rows from bot-tom to top, instead of the more common top-to-bottom approach. Second, theendianness of the data appears to be reversed from that used everywhere elsein.curfiles. In view of this, we must invert theycoordinate in thesetBit()call,and we read in the mask values one byte at a time, bit-shifting and masking toextract their correct values.This completes the implementation of theCursorHandlerimage format plugin.Plugins for other image formats would follow the same pattern, although somemight implement more of theQImageIOHandlerAPI, in particular the functionsused for writing images. Plugins of other kinds, for example, text codecsor database drivers, follow the same pattern of having a plugin wrapper toprovide a generic API that applications can use, and a handler to provide theunderlying functionality."},{"pageNumber":426,"pageContent":"40819. Creating PluginsThe.profile is different for plugins than for applications, so we will endwith that:TEMPLATE = libCONFIG += pluginHEADERS = cursorhandler.h \\ cursorplugin.hSOURCES = cursorhandler.cpp \\ cursorplugin.cppDESTDIR = $(QTDIR)/plugins/imageformatsBy default,.profiles use theapptemplate, but here we must specify thelibtemplate because a plugin is a library, not a stand-alone application. TheCON-FIGline is used to tell Qt that the library is not just a plain library, but a plu-gin library. TheDESTDIRspecifies the directory where the plugin should go. AllQt plugins must go in the appropriatepluginssubdirectory where Qt was in-stalled, and since our plugin provides a new image format we put it inplugins/imageformats. The list of directory names and plugin types is given athttp://doc.trolltech.com/4.1/plugins-howto.html. For this example, we assume thattheQTDIRenvironment variable is set to the directory where Qt is installed.Plugins built for Qt in release mode and debug mode are different, so if bothversions of Qt are installed, it is wise to specify which one to use in the.profile—for example, by adding the lineCONFIG += releaseApplications that use Qt plugins must be deployed with the plugins theyare intended to use. Qt plugins must be placed in specific subdirectories (forexample,imageformatsfor image formats). Qt applications search for pluginsin thepluginsdirectory in the directory where the application’s executableresides, so for image plugins they searchapplication_dir/plugins/imageformats.If we want to deploy Qt plugins in a different directory, the plugins search pathcan be augmented by usingQCoreApplication::addLibraryPath().Making Applications Plugin-AwareAn application plugin is a dynamic library that implements one or moreinter-faces. An interface is a class that consists exclusively of pure virtual functions.The communication between the application and the plugins is done throughthe interface’s virtual table. In this section, we will focus on how to use a pluginin a Qt application through its interfaces, and in the next section we will showhow to implement a plugin.To provide a concrete example, we will create the simple Text Art applicationshown in Figure 19.3. The text effects are provided by plugins; the applicationretrieves the list of text effects provided by each plugin and iterates over themto show each one as an item in aQListWidget."},{"pageNumber":427,"pageContent":"Making Applications Plugin-Aware409Figure 19.3.The Text Art applicationThe Text Art application defines one interface:class TextArtInterface{public: virtual ~TextArtInterface() { } virtual QStringList effects() const = 0; virtual QPixmap applyEffect(const QString &effect,  const QString &text,  const QFont &font, const QSize &size,  const QPen &pen,  const QBrush &brush) = 0;};Q_DECLARE_INTERFACE(TextArtInterface, \"com.software-inc.TextArt.TextArtInterface/1.0\")An interface class normally declares a virtual destructor, a virtual functionthat returns aQStringList, and one or more other virtual functions. The de-structor is there primarily to silence the compiler, which might otherwise com-plain about the lack of a virtual destructor in a class that has virtual func-tions. In this example, theeffects()function returns a list of the text effectsthe plugin can provide. We can think of this list as a list of keys. Every timewe call one of the other functions, we pass one of these keys as first argument,making it possible to implement multiple effects in one plugin.At the end, we use theQ_DECLARE_INTERFACE()macro to associate an identifierto the interface. The identifier normally has four components: an inverted do-main name specifying the creator of the interface, the name of the application,the name of the interface, and a version number. Whenever we alter the inter-face (for example, by adding a virtual function or changing the signature of anexisting function), we must remember to increase the version number; other-wise, the application might crash trying to access an outdated plugin."},{"pageNumber":428,"pageContent":"41019. Creating PluginsThe application is implemented in a class calledTextArtDialog. We will onlyshow the code relevant to making it plugin-aware. Let’s start with the con-structor:TextArtDialog::TextArtDialog(const QString &text, QWidget *parent) : QDialog(parent){ listWidget = new QListWidget; listWidget->setViewMode(QListWidget::IconMode); listWidget->setMovement(QListWidget::Static); listWidget->setIconSize(QSize(260, 80));••• loadPlugins(); populateListWidget(text);•••}The constructor creates aQListWidgetto list the available effects. It calls theprivate functionloadPlugins()to find and load any plugins that implement theTextArtInterfaceand populates the list widget accordingly by calling anotherprivate function,populateListWidget().void TextArtDialog::loadPlugins(){ QDir pluginDir(QApplication::applicationDirPath());#if defined(Q_OS_WIN) if (pluginDir.dirName().toLower() == \"debug\" || pluginDir.dirName().toLower() == \"release\") pluginDir.cdUp();#elif defined(Q_OS_MAC) if (pluginDir.dirName() == \"MacOS\") { pluginDir.cdUp(); pluginDir.cdUp(); pluginDir.cdUp(); }#endif if (!pluginDir.cd(\"plugins\")) return; foreach (QString fileName, pluginDir.entryList(QDir::Files)) { QPluginLoader loader(pluginDir.absoluteFilePath(fileName)); if (TextArtInterface *interface = qobject_cast<TextArtInterface *>(loader.instance())) interfaces.append(interface); }}InloadPlugins(), we attempt to load all the files in the application’spluginsdirectory. (On Windows, the application’s executable usually lives in adebugorreleasesubdirectory, so we move one directory up. On Mac OS X, we take thebundle directory structure into account.)If the file we try to load is a Qt plugin that uses the same version of Qt as theapplication,QPluginLoader::instance()will return aQObject *that points to a"},{"pageNumber":429,"pageContent":"Making Applications Plugin-Aware411Qt plugin. We useqobject_cast<T>()to check whether the plugin implementstheTextArtInterface. Each time the cast is successful, we add the interface totheTextArtDialog’s list of interfaces (of typeQList<TextArtInterface *>).Some applications may want to load two or more different interfaces, in whichcase the code for obtaining the interfaces would look more like that shownbelow:QObject *plugin = loader.instance();if (TextArtInterface *i = qobject_cast<TextArtInterface *>(plugin)) textArtInterfaces.append(i);if (BorderArtInterface *i = qobject_cast<BorderArtInterface *>(plugin)) borderArtInterfaces.append(i);if (TextureInterface *i = qobject_cast<TextureInterface *>(plugin)) textureInterfaces.append(i);The same plugin may successfully cast to more than one interface pointer,since it is possible for plugins to provide multiple interfaces by using multipleinheritance.void TextArtDialog::populateListWidget(const QString &text){ QSize iconSize = listWidget->iconSize(); QPen pen(QColor(\"darkseagreen\")); QLinearGradient gradient(0, 0, iconSize.width() / 2,  iconSize.height() / 2); gradient.setColorAt(0.0, QColor(\"darkolivegreen\")); gradient.setColorAt(0.8, QColor(\"darkgreen\")); gradient.setColorAt(1.0, QColor(\"lightgreen\")); QFont font(\"Helvetica\", iconSize.height(), QFont::Bold); foreach (TextArtInterface *interface, interfaces) { foreach (QString effect, interface->effects()) { QListWidgetItem *item = new QListWidgetItem(effect,   listWidget); QPixmap pixmap = interface->applyEffect(effect, text, font,   iconSize, pen,   gradient); item->setData(Qt::DecorationRole, pixmap); } } listWidget->setCurrentRow(0);}ThepopulateListWidget()function begins by creating some variables to pass totheapplyEffect()function, in particular a pen, a linear gradient, and a font. Itthen iterates over everyTextArtInterfacethat was found byloadPlugins(). Foreach effect provided by each interface, a newQListWidgetItemis created with itstext set to the name of the effect it represents, and aQPixmapis created usingapplyEffect()."},{"pageNumber":430,"pageContent":"41219. Creating PluginsIn this section we have seen how to load plugins by callingloadPlugins()in theconstructor, and how to make use of them inpopulateListWidget(). The codecopes gracefully whether there are no plugins providingTextArtInterfaces, justone, or more than one. Furthermore, additional plugins could be added later:Every time the application starts up it loads whatever plugins it finds thatprovide the interfaces it wants. This makes it easy to extend the application’sfunctionality without changing the application itself.Writing Application PluginsAn application plugin is a subclass ofQObjectand of the interfaces it wants toprovide. The CD that accompanies this book includes two plugins for the TextArt application presented in the previous section, to show that the applicationcorrectly handles multiple plugins.Here, we will only review the code for one of them, the Basic Effects Plugin.We will assume that the plugin’s source code is located in a directory calledbasiceffectspluginand that the Text Art application is located in a paralleldirectory calledtextart. Here’s the declaration of the plugin class:class BasicEffectsPlugin : public QObject, public TextArtInterface{ Q_OBJECT Q_INTERFACES(TextArtInterface)public: QStringList effects() const; QPixmap applyEffect(const QString &effect, const QString &text, const QFont &font, const QSize &size, const QPen &pen, const QBrush &brush);};The plugin implements only one interface,TextArtInterface. In addition toQ_OBJECT, we must use theQ_INTERFACES()macro for each of the interfaces that aresubclassed to ensure smooth cooperation betweenmocandqobject_cast<T>().QStringList BasicEffectsPlugin::effects() const{ return QStringList() << \"Plain\" << \"Outline\" << \"Shadow\";}Theeffects()function returns a list of text effects supported by the plugin.This plugin supports three effects, so we just return a list containing the nameof each one.TheapplyEffect()function provides the plugin’s functionality and is slightlyinvolved, so we will review it in pieces.QPixmap BasicEffectsPlugin::applyEffect(const QString &effect, const QString &text, const QFont &font, const QSize &size, const QPen &pen, const QBrush &brush){"},{"pageNumber":431,"pageContent":"Writing Application Plugins413 QFont myFont = font; QFontMetrics metrics(myFont); while ((metrics.width(text) > size.width() || metrics.height() > size.height()) && myFont.pointSize() > 9) { myFont.setPointSize(myFont.pointSize() - 1); metrics = QFontMetrics(myFont); }We want to ensure that the given text will fit in the specified size if possible.For this reason, we use the font’s metrics to see if the text is too large to fit, andif it is we enter a loop where we reduce the point size until we find a size thatwill fit, or until we reach 9 points, our fixed minimum size. QPixmap pixmap(size); QPainter painter(&pixmap); painter.setFont(myFont); painter.setPen(pen); painter.setBrush(brush); painter.setRenderHint(QPainter::Antialiasing, true); painter.setRenderHint(QPainter::TextAntialiasing, true); painter.setRenderHint(QPainter::SmoothPixmapTransform, true); painter.eraseRect(pixmap.rect());We create a pixmap of the required size and a painter to paint onto the pixmap.We also set some render hints to ensure the smoothest possible results. Thecall toeraseRect()clears the pixmap with the background color. if (effect == \"Plain\") { painter.setPen(Qt::NoPen); } else if (effect == \"Outline\") { QPen pen(Qt::black); pen.setWidthF(2.5); painter.setPen(pen); } else if (effect == \"Shadow\") { QPainterPath path; painter.setBrush(Qt::darkGray); path.addText(((size.width() - metrics.width(text)) / 2) + 3, (size.height() - metrics.descent()) + 3, myFont, text); painter.drawPath(path); painter.setBrush(brush); }For the “Plain” effect, no outline is required. For the “Outline” effect, we ignorethe original pen and create our own black pen with a 2.5-pixel width. Forthe “Shadow” effect, we need to draw the shadow first, so that the text can bepainted on top of it. QPainterPath path; path.addText((size.width() - metrics.width(text)) / 2, size.height() - metrics.descent(), myFont, text);"},{"pageNumber":432,"pageContent":"41419. Creating Plugins painter.drawPath(path); return pixmap;}We now have the pen and brushes set appropriately for each text effect, and inthe “Shadow” effect case have drawn the shadow. We are now ready to renderthe text. The text is horizontally centered and drawn far enough above thebottom of the pixmap to allow room for descenders.Q_EXPORT_PLUGIN2(basiceffectsplugin, BasicEffectsPlugin)At the end of the.cppfile, we use theQ_EXPORT_PLUGIN2()macro to make theplugin available to Qt.The.profile is similar to the one we used for the Windows cursor plugin earlierin this chapter (p. 408):TEMPLATE = libCONFIG += pluginHEADERS = ../textart/textartinterface.h \\ basiceffectsplugin.hSOURCES = basiceffectsplugin.cppDESTDIR = ../textart/pluginsIf this chapter has whet your appetite for application plugins, you might liketo study the more advanced Plug & Paint example provided with Qt. Theapplication supports three different interfaces and includes a useful PluginInformation dialog that lists the plugins and interfaces that are available tothe application."},{"pageNumber":433,"pageContent":"20. Platform-Specific FeaturesuInterfacing with Native APIsuUsing ActiveX on WindowsuHandling X11 Session ManagementIn this chapter, we will review some of the platform-specific options availableto Qt programmers. We begin by looking at how to access native APIs such asthe Win32 API on Windows, Carbon on Mac OS X, and Xlib on X11. We thenmove on to explore the ActiveQt extension, showing how to use ActiveX con-trols within Qt/Windows applications and how to create applications that actas ActiveX servers. In the last section, we explain how to make Qt applicationscooperate with the session manager under X11.In addition to the features presented here, Trolltech offers several platform-specific Qt Solutions, including the Qt/Motif and Qt/MFC migration frame-works to ease the migration of Motif/Xt and MFC applications to Qt. A similarextension for Tcl/Tk applications is provided byfroglogic, and a Microsoft Win-dows resource converter is available from Klarälvdalens Datakonsult. See thefollowing web pages for details:•http://www.trolltech.com/products/solutions/catalog/•http://www.froglogic.com/tq/•http://www.kdab.net/knut/For embedded development, Trolltech offers the Qtopia application platform.This is covered in Chapter 21.Interfacing with Native APIsQt’s comprehensive API caters for most needs on all platforms, but in somecircumstances, we may want to use the underlying platform-specific APIs. Inthis section, we will show how to use the native APIs for the different platformssupported by Qt to accomplish particular tasks.On every platform,QWidgetprovides awinId()function that returns the windowID or handle.QWidgetalso provides a static function calledfind()that returnstheQWidgetwith a particular window ID. We can pass this ID to native APIfunctions to achieve platform-specific effects. For example, the following code415"},{"pageNumber":434,"pageContent":"41620. Platform-Specific FeaturesuseswinId()to move the title bar of a tool window to the left using nativeMac OS X functions:#ifdef Q_WS_MAC ChangeWindowAttributes(HIViewGetWindow(HIViewRef(toolWin.winId())),  kWindowSideTitlebarAttribute,  kWindowNoAttributes);#endifFigure 20.1.A Mac OS X tool window with the title bar on the sideOn X11, here’s how we would modify a window property:#ifdef Q_WS_X11 Atom atom = XInternAtom(QX11Info::display(), \"MY_PROPERTY\", False); long data = 1; XChangeProperty(QX11Info::display(), window->winId(), atom, atom, 32, PropModeReplace, reinterpret_cast<uchar *>(&data), 1);#endifThe#ifdefand#endifdirectives around the platform-specific code ensure thatthe application will still compile on other platforms.For a Windows-only application, here’s an example of how we can use GDI callsto draw on a Qt widget:void GdiControl::paintEvent(QPaintEvent * /* event */){ RECT rect; GetClientRect(winId(), &rect); HDC hdc = GetDC(winId()); FillRect(hdc, &rect, HBRUSH(COLOR_WINDOW + 1)); SetTextAlign(hdc, TA_CENTER | TA_BASELINE); TextOutW(hdc, width() / 2, height() / 2, text.utf16(), text.size()); ReleaseDC(winId(), hdc);}"},{"pageNumber":435,"pageContent":"Interfacing with Native APIs417For this to work, we must also reimplementQPaintDevice::paintEngine()to re-turn a null pointer and set theQt::WA_PaintOnScreenattribute in the widget’sconstructor.The next example shows how to combineQPainterand GDI calls in a paintevent handler usingQPaintEngine’sgetDC()andreleaseDC()functions:void MyWidget::paintEvent(QPaintEvent * /* event */){ QPainter painter(this); painter.fillRect(rect().adjusted(20, 20, -20, -20), Qt::red);#ifdef Q_WS_WIN HDC hdc = painter.paintEngine()->getDC(); Rectangle(hdc, 40, 40, width() - 40, height() - 40); painter.paintEngine()->releaseDC();#endif}MixingQPainterand GDI calls like this can sometimes lead to strange results,especially whenQPaintercalls occur after GDI calls, becauseQPaintermakessome assumptions about the state of the underlying drawing layer.Qt defines one of the following four window system symbols:Q_WS_WIN,Q_WS_X11,Q_WS_MAC, andQ_WS_QWS(Qtopia). We must include at least one Qt headerbefore we can use them in applications. Qt also provides preprocessor symbolsto identify the operating system:•Q_OS_AIX•Q_OS_BSD4•Q_OS_BSDI•Q_OS_CYGWIN•Q_OS_DGUX•Q_OS_DYNIX•Q_OS_FREEBSD•Q_OS_HPUX•Q_OS_HURD•Q_OS_IRIX•Q_OS_LINUX•Q_OS_LYNX•Q_OS_MAC•Q_OS_NETBSD•Q_OS_OPENBSD•Q_OS_OS2EMX•Q_OS_OSF•Q_OS_QNX6•Q_OS_QNX•Q_OS_RELIANT•Q_OS_SCO•Q_OS_SOLARIS•Q_OS_ULTRIX•Q_OS_UNIXWARE•Q_OS_WIN32•Q_OS_WIN64We can assume that at most one of these will be defined. For convenience, Qtalso definesQ_OS_WINwhen either Win32 or Win64 is detected, andQ_OS_UNIXwhen any Unix-based operating system (including Linux and Mac OS X) isdetected. At run-time, we can checkQSysInfo::WindowsVersionorQSysInfo::MacintoshVersionto distinguish between different versions of Windows (2000,ME, etc.) or Mac OS X (10.2, 10.3, etc.).In addition to the operating system and window system macros, there is alsoa set of compiler macros. For example,Q_CC_MSVCis defined if the compiler isMicrosoft Visual C++. These can be useful for working around compiler bugs.Several of Qt’s GUI-related classes provide platform-specific functionsthat return low-level handles to the underlying object. These are listed inFigure 20.2."},{"pageNumber":436,"pageContent":"41820. Platform-Specific FeaturesMac OS XATSFontFormatRefQFont::handle()CGImageRefQPixmap::macCGHandle()GWorldPtrQPixmap::macQDAlphaHandle()GWorldPtrQPixmap::macQDHandle()RgnHandleQRegion::handle()HIViewRefQWidget::winId()WindowsHCURSORQCursor::handle()HDCQPaintEngine::getDC()HDCQPrintEngine::getPrinterDC()HFONTQFont::handle()HPALETTEQColormap::hPal()HRGNQRegion::handle()HWNDQWidget::winId()X11CursorQCursor::handle()FontQFont::handle()PictureQPixmap::x11PictureHandle()PictureQWidget::x11PictureHandle()PixmapQPixmap::handle()QX11InfoQPixmap::x11Info()QX11InfoQWidget::x11Info()RegionQRegion::handle()ScreenQCursor::x11Screen()SmcConnQSessionManager::handle()WindowQWidget::handle()WindowQWidget::winId()Figure 20.2.Platform-specific functions to access low-level handlesOn X11,QPixmap::x11Info()andQWidget::x11Info()return aQX11Infoobjectthat provides various pointers or handles, such asdisplay(),screen(),col-ormap(), andvisual(). We can use these to set up an X11 graphics context on aQPixmaporQWidget, for example.Qt applications that need to interface with other toolkits or libraries fre-quently need to access the low-level events (XEvents on X11,MSGs on Windows,EventRefon Mac OS X,QWSEvents on Qtopia) before they are converted into"},{"pageNumber":437,"pageContent":"Interfacing with Native APIs419QEvents. We can do this by subclassingQApplicationand reimplementing therelevant platform-specific event filter, one ofx11EventFilter(),winEventFil-ter(),macEventFilter(), andqwsEventFilter(). Alternatively, we can access theplatform-specific events that are sent to a givenQWidgetby reimplementingone ofx11Event(),winEvent(),macEvent(), andqwsEvent(). This can be usefulfor handling certain types of events that Qt normally ignores, such as joy-stick events.For more information about platform-specific issues, including how to deployQt applications on different platforms, seehttp://doc.trolltech.com/4.1/win-system.html.Using ActiveX on WindowsMicrosoft’s ActiveX technology allows applications to incorporate user interfacecomponents provided by other applications or libraries. It is built on MicrosoftCOM and defines one set of interfaces for applications that use componentsand another set of interfaces for applications and libraries that provide com-ponents.The Qt/Windows Desktop Edition provides the ActiveQt framework to seam-lessly combine ActiveX and Qt. ActiveQt consists of two modules:• TheQAxContainermodule allows us to use COM objects and to embedActiveX controls in Qt applications.• TheQAxServermodule allows us to export custom COM objects andActiveX controls written using Qt.Our first example will embed the Windows Media Player in a Qt applicationusing theQAxContainermodule. The Qt application adds anOpenbutton,aPlay/Pausebutton, aStopbutton, and a slider to the Windows Media PlayerActiveX control.Figure 20.3.The Media Player application"},{"pageNumber":438,"pageContent":"42020. Platform-Specific FeaturesThe application’s main window is of typePlayerWindow:class PlayerWindow : public QWidget{ Q_OBJECT Q_ENUMS(ReadyStateConstants)public: enum PlayStateConstants { Stopped = 0, Paused = 1, Playing = 2 }; enum ReadyStateConstants { Uninitialized = 0, Loading = 1,  Interactive = 3, Complete = 4 }; PlayerWindow();protected: void timerEvent(QTimerEvent *event);private slots: void onPlayStateChange(int oldState, int newState); void onReadyStateChange(ReadyStateConstants readyState); void onPositionChange(double oldPos, double newPos); void sliderValueChanged(int newValue); void openFile();private: QAxWidget *wmp; QToolButton *openButton; QToolButton *playPauseButton; QToolButton *stopButton; QSlider *seekSlider; QString fileFilters; int updateTimer;};ThePlayerWindowclass inherits fromQWidget. TheQ_ENUMS()macro (just belowQ_OBJECT) is necessary to tellmocthat theReadyStateConstantstype used in theonReadyStateChange()slot is an enum type. In the private section, we declare aQAxWidget *data member.PlayerWindow::PlayerWindow(){ wmp = new QAxWidget; wmp->setControl(\"{22D6F312-B0F6-11D0-94AB-0080C74C7E95}\");In the constructor, we start by creating aQAxWidgetobject to encapsulate theWindows Media Player ActiveX control. TheQAxContainermodule consistsof three classes:QAxObjectencapsulates a COM object,QAxWidgetencapsulatesan ActiveX control, andQAxBaseimplements the core COM functionality forQAxObjectandQAxWidget.We callsetControl()on theQAxWidgetwith the class ID of the Windows MediaPlayer 6.4 control. This will create an instance of the required component.From then on, all the properties, events, and methods of the ActiveX controlare available as Qt properties, signals, and slots through theQAxWidgetobject."},{"pageNumber":439,"pageContent":"Using ActiveX on Windows421QObjectQAxBaseQWidgetQAxObjectQAxWidgetFigure 20.4.Inheritance tree for theQAxContainermoduleThe COM data types are automatically converted into the correspondingQt types, as summarized in Figure 20.5. For example, an in-parameter oftypeVARIANT_BOOLbecomes abool, and an out-parameter of typeVARIANT_BOOLbecomes abool &. If the resulting type is a Qt class (QString,QDateTime, etc.), thein-parameter is a const reference (for example,const QString &).COM typesQt typesVARIANT_BOOLboolchar,short,int,longintunsigned char,unsigned short,unsigned int,unsigned longuintfloat,doubledoubleCYqlonglong,qulonglongBSTRQStringDATEQDateTime,QDate,QTimeOLE_COLORQColorSAFEARRAY(VARIANT)QList<QVariant>SAFEARRAY(BSTR)QStringListSAFEARRAY(BYTE)QByteArrayVARIANTQVariantIFontDisp *QFontIPictureDisp *QPixmapUser defined typeQRect,QSize,QPointFigure 20.5.Relationship between COM types and Qt typesTo obtain the list of all the properties, signals, and slots available in aQAxObjectorQAxWidgetwith their Qt data types, callQAxBase::generateDocumentation()oruse Qt’sdumpdoccommand-line tool, located in Qt’stools\\activeqt\\dumpdocdi-rectory.Let’s continue with thePlayerWindowconstructor: wmp->setProperty(\"ShowControls\", false); wmp->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);"},{"pageNumber":440,"pageContent":"42220. Platform-Specific Features connect(wmp, SIGNAL(PlayStateChange(int, int)), this, SLOT(onPlayStateChange(int, int))); connect(wmp, SIGNAL(ReadyStateChange(ReadyStateConstants)), this, SLOT(onReadyStateChange(ReadyStateConstants))); connect(wmp, SIGNAL(PositionChange(double, double)), this, SLOT(onPositionChange(double, double)));After callingQAxWidget::setControl(), we callQObject::setProperty()to set theShowControlsproperty of the Windows Media Player tofalse, since we provideour own buttons to manipulate the component.QObject::setProperty()canbe used both for COM properties and for normal Qt properties. Its secondparameter is of typeQVariant.Next, we callsetSizePolicy()to make the ActiveX control take all the availablespace in the layout, and we connect three ActiveX events from the COMcomponent to three slots.••• stopButton = new QToolButton; stopButton->setText(tr(\"&Stop\")); stopButton->setEnabled(false); connect(stopButton, SIGNAL(clicked()), wmp, SLOT(Stop()));•••}The rest of thePlayerWindowconstructor follows the usual pattern, except thatwe connect some Qt signals to slots provided by the COM object (Play(),Pause(),andStop()). Since the buttons are similar, we have only shown theStopbutton’simplementation here.Let’s leave the constructor and look at thetimerEvent()function:void PlayerWindow::timerEvent(QTimerEvent *event){ if (event->timerId() == updateTimer) { double curPos = wmp->property(\"CurrentPosition\").toDouble(); onPositionChange(-1, curPos); } else { QWidget::timerEvent(event); }}ThetimerEvent()function is called at regular intervals while a media clip isplaying. We use it to advance the slider. This is done by callingproperty()on the ActiveX control to obtain the value of theCurrentPositionproperty asaQVariantand callingtoDouble()to convert it to adouble. We then callonPosi-tionChange()to perform the update.We will not review the rest of the code because most of it isn’t directly relevantto ActiveX and doesn’t show anything that we haven’t covered already. Thecode is included on the CD.In the.profile, we need this entry to link with theQAxContainermodule:"},{"pageNumber":441,"pageContent":"Using ActiveX on Windows423CONFIG += qaxcontainerOne frequent need when dealing with COM objects is to be able to call a COMmethod directly (as opposed to connecting it to a Qt signal). The easiest wayto do this is to invokeQAxBase::dynamicCall()with the name and signature ofthe method as first parameter and the arguments to the method as additionalparameters. For example:wmp->dynamicCall(\"TitlePlay(uint)\", 6);ThedynamicCall()function takes up to eight parameters of typeQVariantandreturns aQVariant. If we need to pass anIDispatch *or anIUnknown *this way,we can encapsulate the component in aQAxObjectand callasVariant()on itto convert it to aQVariant. If we need to call a COM method that returns anIDispatch *or anIUnknown *, or if we need to access a COM property of one ofthose types, we can usequerySubObject()instead:QAxObject *session = outlook.querySubObject(\"Session\");QAxObject *defaultContacts = session->querySubObject(\"GetDefaultFolder(OlDefaultFolders)\",  \"olFolderContacts\");If we want to call methods that have unsupported data types in their parame-ter list, we can useQAxBase::queryInterface()to retrieve the COM interface andcall the method directly. As usual with COM, we must callRelease()when wehave finished using the interface. If we often need to call such methods, we cansubclassQAxObjectorQAxWidgetand provide member functions that encapsulatethe COM interface calls. Be aware thatQAxObjectandQAxWidgetsubclasses can-not define their own properties, signals, or slots.We will now review theQAxServermodule. This module enables us to turna standard Qt program into an ActiveX server. The server can either be ashared library or a stand-alone application. Servers built as shared librariesare often called in-process servers; stand-alone applications are called out-of-process servers.Our firstQAxServerexample is an in-process server that provides a widgetthat shows a ball bouncing left and right. We will also see how to embed thewidget in Internet Explorer.Here’s the beginning of the class definition of theAxBouncerwidget:class AxBouncer : public QWidget, public QAxBindable{ Q_OBJECT Q_ENUMS(SpeedValue) Q_PROPERTY(QColor color READ color WRITE setColor) Q_PROPERTY(SpeedValue speed READ speed WRITE setSpeed) Q_PROPERTY(int radius READ radius WRITE setRadius) Q_PROPERTY(bool running READ isRunning)AxBouncerinherits from bothQWidgetandQAxBindable. TheQAxBindableclassprovides an interface between the widget and an ActiveX client. AnyQWidget"},{"pageNumber":442,"pageContent":"42420. Platform-Specific Featurescan be exported as an ActiveX control, but by subclassingQAxBindablewe cannotify the client when a property’s value changes, and we can implement COMinterfaces to supplement those already implemented byQAxServer.Figure 20.6.TheAxBouncerwidget in Internet ExplorerWhen doing multiple inheritance involving aQObject-derived class, we mustalways put theQObject-derived class first so thatmoccan pick it up.We declare three read-write properties and one read-only property. TheQ_ENUMS()macro is necessary to tellmocthat theSpeedValuetype is an enum type.The enum is declared in the public section of the class:public: enum SpeedValue { Slow, Normal, Fast }; AxBouncer(QWidget *parent = 0); void setSpeed(SpeedValue newSpeed); SpeedValue speed() const { return ballSpeed; } void setRadius(int newRadius); int radius() const { return ballRadius; } void setColor(const QColor &newColor); QColor color() const { return ballColor; } bool isRunning() const { return myTimerId != 0; } QSize sizeHint() const; QAxAggregated *createAggregate();"},{"pageNumber":443,"pageContent":"Using ActiveX on Windows425public slots: void start(); void stop();signals: void bouncing();TheAxBouncerconstructor is a standard constructor for a widget, with aparentparameter. TheQAXFACTORY_DEFAULT()macro, which we will use to export thecomponent, expects a constructor with this signature.ThecreateAggregate()function is reimplemented fromQAxBindable. We willexplain it in a moment.protected: void paintEvent(QPaintEvent *event); void timerEvent(QTimerEvent *event);private: int intervalInMilliseconds() const; QColor ballColor; SpeedValue ballSpeed; int ballRadius; int myTimerId; int x; int delta;};The protected and private sections of the class are the same as those we wouldhave if this was a standard Qt widget.AxBouncer::AxBouncer(QWidget *parent) : QWidget(parent){ ballColor = Qt::blue; ballSpeed = Normal; ballRadius = 15; myTimerId = 0; x = 20; delta = 2;}TheAxBouncerconstructor initializes the class’s private variables.void AxBouncer::setColor(const QColor &newColor){ if (newColor != ballColor && requestPropertyChange(\"color\")) { ballColor = newColor; update(); propertyChanged(\"color\"); }}ThesetColor()function sets the value of thecolorproperty. It callsupdate()torepaint the widget."},{"pageNumber":444,"pageContent":"42620. Platform-Specific FeaturesThe unusual part is therequestPropertyChange()andpropertyChanged()calls.These functions are inherited fromQAxBindableand should ideally be calledwhenever we change a property. TherequestPropertyChange()asks the client’spermission to change a property, and returnstrueif the client allows thechange. ThepropertyChanged()function notifies the client that the propertyhas been changed.ThesetSpeed()andsetRadius()property setters also follow this pattern, andso do thestart()andstop()slots, since they change the value of therunningproperty.There is one interestingAxBouncermember function left:QAxAggregated *AxBouncer::createAggregate(){ return new ObjectSafetyImpl;}ThecreateAggregate()function is reimplemented fromQAxBindable. It allowsus to implement COM interfaces that theQAxServermodule doesn’t alreadyimplement or to bypassQAxServer’s default COM interfaces. Here, we do itto provide theIObjectSafetyinterface, which is used by Internet Explorer toaccess a component’s safety options. This is the standard trick to get rid ofInternet Explorer’s infamous “Object not safe for scripting” error message.Here’s the definition of the class that implements theIObjectSafetyinterface:class ObjectSafetyImpl : public QAxAggregated, public IObjectSafety{public: long queryInterface(const QUuid &iid, void **iface); QAXAGG_IUNKNOWN HRESULT WINAPI GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions); HRESULT WINAPI SetInterfaceSafetyOptions(REFIID riid, DWORD pdwSupportedOptions, DWORD pdwEnabledOptions);};TheObjectSafetyImplclass inherits bothQAxAggregatedandIObjectSafety. TheQAxAggregatedclass is an abstract base class for implementations of additionalCOM interfaces. The COM object that theQAxAggregatedextends is accessiblethroughcontrollingUnknown(). This COM object is created behind the scenes bytheQAxServermodule.TheQAXAGG_IUNKNOWNmacro provides standard implementations ofQueryInter-face(),AddRef(), andRelease(). These implementations simply call the samefunctions on the controlling COM object.long ObjectSafetyImpl::queryInterface(const QUuid &iid, void **iface){ *iface = 0; if (iid == IID_IObjectSafety) {"},{"pageNumber":445,"pageContent":"Using ActiveX on Windows427 *iface = static_cast<IObjectSafety *>(this); } else { return E_NOINTERFACE; } AddRef(); return S_OK;}ThequeryInterface()function is a pure virtual function ofQAxAggregated. It iscalled by the controlling COM object to give access to the interfaces providedby theQAxAggregatedsubclass. We must returnE_NOINTERFACEfor interfaces thatwe don’t implement and forIUnknown.HRESULT WINAPI ObjectSafetyImpl::GetInterfaceSafetyOptions( REFIID /* riid */, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions){ *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA  | INTERFACESAFE_FOR_UNTRUSTED_CALLER; *pdwEnabledOptions = *pdwSupportedOptions; return S_OK;}HRESULT WINAPI ObjectSafetyImpl::SetInterfaceSafetyOptions( REFIID /* riid */, DWORD /* pdwSupportedOptions */, DWORD /* pdwEnabledOptions */){ return S_OK;}TheGetInterfaceSafetyOptions()andSetInterfaceSafetyOptions()functions aredeclared inIObjectSafety. We implement them to tell the world that our objectis safe for scripting.Let’s now reviewmain.cpp:#include <QAxFactory>#include \"axbouncer.h\"QAXFACTORY_DEFAULT(AxBouncer, \"{5e2461aa-a3e8-4f7a-8b04-307459a4c08c}\", \"{533af11f-4899-43de-8b7f-2ddf588d1015}\", \"{772c14a5-a840-4023-b79d-19549ece0cd9}\", \"{dbce1e56-70dd-4f74-85e0-95c65d86254d}\", \"{3f3db5e0-78ff-4e35-8a5d-3d3b96c83e09}\")TheQAXFACTORY_DEFAULT()macro exports an ActiveX control. We can use it forActiveX servers that export only one control. The next example in this sectionwill show how to export many ActiveX controls.The first argument toQAXFACTORY_DEFAULT()is the name of the Qt class toexport. This is also the name under which the control is exported. The otherfive arguments are the class ID, the interface ID, the event interface ID, thetype library ID, and the application ID. We can use standard tools likeguidgen"},{"pageNumber":446,"pageContent":"42820. Platform-Specific Featuresoruuidgento generate these identifiers. Because the server is a library, we don’tneed amain()function.Here’s the.profile for our in-process ActiveX server:TEMPLATE = libCONFIG += dll qaxserverHEADERS = axbouncer.h \\ objectsafetyimpl.hSOURCES = axbouncer.cpp \\ main.cpp \\ objectsafetyimpl.cppRC_FILE = qaxserver.rcDEF_FILE = qaxserver.defTheqaxserver.rcandqaxserver.deffiles referred to in the.profile are standardfiles that can be copied from Qt’ssrc\\activeqt\\controldirectory.The makefile or Visual C++project file generated byqmakecontains rules toregister the server in the Windows registry. To register the server on end-usermachines, we can use theregsvr32tool available on all Windows systems.We can then include the Bouncer component in an HTML page using the<object>tag:<object id=\"AxBouncer\" classid=\"clsid:5e2461aa-a3e8-4f7a-8b04-307459a4c08c\"><b>The ActiveX control is not available. Make sure you have built andregistered the component server.</b></object>We can create buttons that invoke slots:<input type=\"button\" value=\"Start\" onClick=\"AxBouncer.start()\"><input type=\"button\" value=\"Stop\" onClick=\"AxBouncer.stop()\">We can manipulate the widget using JavaScript or VBScript just like anyother ActiveX control. See thedemo.htmlfile on the CD for a rudimentary pagethat uses the ActiveX server.Our last example is a scriptable Address Book application. The applicationcan serve as a standard Qt/Windows application or an out-of-process ActiveXserver. The latter possibility allows us to script the application using, say,Visual Basic.class AddressBook : public QMainWindow{ Q_OBJECT Q_PROPERTY(int count READ count) Q_CLASSINFO(\"ClassID\", \"{588141ef-110d-4beb-95ab-ee6a478b576d}\") Q_CLASSINFO(\"InterfaceID\", \"{718780ec-b30c-4d88-83b3-79b3d9e78502}\") Q_CLASSINFO(\"ToSuperClass\", \"AddressBook\")public: AddressBook(QWidget *parent = 0); ~AddressBook();"},{"pageNumber":447,"pageContent":"Using ActiveX on Windows429 int count() const;public slots: ABItem *createEntry(const QString &contact); ABItem *findEntry(const QString &contact) const; ABItem *entryAt(int index) const;private slots: void addEntry(); void editEntry(); void deleteEntry();private: void createActions(); void createMenus(); QTreeWidget *treeWidget; QMenu *fileMenu; QMenu *editMenu; QAction *exitAction; QAction *addEntryAction; QAction *editEntryAction; QAction *deleteEntryAction;};TheAddressBookwidget is the application’s main window. The property and theslots it provides will be available for scripting. TheQ_CLASSINFO()macro is usedto specify the class and interface IDs associated with the class. These weregenerated using a tool such asguidoruuid.In the previous example, we specified the class and interface IDs when weexported theQAxBouncerclass using theQAXFACTORY_DEFAULT()macro. In thisexample, we want to export several classes, so we cannot useQAXFACTORY_DEFAULT(). There are two options available to us:• We can subclassQAxFactory, reimplement its virtual functions to provideinformation about the types we want to export, and use theQAXFACTORY_EXPORT()macro to register the factory.• We can use theQAXFACTORY_BEGIN(),QAXFACTORY_END(),QAXCLASS(), andQAX-TYPE()macros to declare and register the factory. This approach requiresus to specify the class and interface IDs usingQ_CLASSINFO().Back to theAddressBookclass definition: The third occurrence ofQ_CLASSINFO()may seem a bit mysterious. By default, ActiveX controls expose not only theirown properties, signals, and slots to clients, but also those of their superclassesup toQWidget. TheToSuperClassattribute lets us specify the highest superclass(in the inheritance tree) that we want to expose. Here, we specify the classname of the component (AddressBook) as the highest superclass to export, mean-ing that properties, signals, and slots defined inAddressBook’s superclasses willnot be exported."},{"pageNumber":448,"pageContent":"43020. Platform-Specific Featuresclass ABItem : public QObject, public QTreeWidgetItem{ Q_OBJECT Q_PROPERTY(QString contact READ contact WRITE setContact) Q_PROPERTY(QString address READ address WRITE setAddress) Q_PROPERTY(QString phoneNumber READ phoneNumber WRITE setPhoneNumber) Q_CLASSINFO(\"ClassID\", \"{bc82730e-5f39-4e5c-96be-461c2cd0d282}\") Q_CLASSINFO(\"InterfaceID\", \"{c8bc1656-870e-48a9-9937-fbe1ceff8b2e}\") Q_CLASSINFO(\"ToSuperClass\", \"ABItem\")public: ABItem(QTreeWidget *treeWidget); void setContact(const QString &contact); QString contact() const { return text(0); } void setAddress(const QString &address); QString address() const { return text(1); } void setPhoneNumber(const QString &number); QString phoneNumber() const { return text(2); }public slots: void remove();};TheABItemclass represents one entry in the address book. It inherits fromQTreeWidgetItemso that it can be shown in aQTreeWidgetand fromQObjectsothat it can be exported as a COM object.int main(int argc, char *argv[]){ QApplication app(argc, argv); if (!QAxFactory::isServer()) { AddressBook addressBook; addressBook.show(); return app.exec(); } return app.exec();}Inmain(), we check whether the application is being run stand-alone or asa server. The-activexcommand-line option is recognized byQApplicationand makes the application run as a server. If the application isn’t run as aserver, we create the main widget and show it as we would normally do in anystand-alone Qt application.In addition to-activex, ActiveX servers understand the following command-line options:•-regserverregisters the server in the system registry.•-unregserverunregisters the server from the system registry.•-dumpidl filewrites the server’s IDL to the specified file.When the application is run as a server, we must export theAddressBookandABItemclasses as COM components:"},{"pageNumber":449,"pageContent":"Using ActiveX on Windows431QAXFACTORY_BEGIN(\"{2b2b6f3e-86cf-4c49-9df5-80483b47f17b}\", \"{8e827b25-148b-4307-ba7d-23f275244818}\")QAXCLASS(AddressBook)QAXTYPE(ABItem)QAXFACTORY_END()The above macros export a factory for creating COM objects. Since we want toexport two types of COM objects, we cannot simply useQAXFACTORY_DEFAULT()aswe did in the previous example.The first argument toQAXFACTORY_BEGIN()is the type library ID; the secondargument is the application ID. BetweenQAXFACTORY_BEGIN()andQAXFACTORY_END(), we specify all the classes that can be instantiated and all the data typesthat we want to make accessible as COM objects.This is the.profile for our out-of-process ActiveX server:TEMPLATE = appCONFIG += qaxserverHEADERS = abitem.h \\ addressbook.h \\ editdialog.hSOURCES = abitem.cpp \\ addressbook.cpp \\ editdialog.cpp \\ main.cppFORMS = editdialog.uiRC_FILE = qaxserver.rcTheqaxserver.rcfile referred to in the.profile is a standard file that can becopied from Qt’ssrc\\activeqt\\controldirectory.Look in the example’svbdirectory for a Visual Basic project that uses theAddress Book server.This completes our overview of the ActiveQt framework. The Qt distributionincludes additional examples, and the documentation contains informationabout how to build theQAxContainerandQAxServermodules and how to solvecommon interoperability issues.Handling X11 Session ManagementWhen we log out on X11, some window managers ask us whether we wantto save the session. If we say yes, the applications that were running areautomatically restarted the next time we log in, with the same screen positionsand, ideally, with the same state as they had when we logged out.The X11-specific component that takes care of saving and restoring the sessionis called thesession manager. To make a Qt/X11 application aware of thesession manager, we must reimplementQApplication::saveState()and savethe application’s state there."},{"pageNumber":450,"pageContent":"43220. Platform-Specific FeaturesFigure 20.7.Logging out on KDEWindows 2000 and XP, and some Unix systems, offer a different mechanismcalled hibernation. When the user puts the computer into hibernation, theoperating system simply dumps the computer’s memory onto disk and reloadsit when it wakes up. Applications do not need to do anything or even be awarethat this happens.When the user initiates a shutdown, we can take control just before theshutdown occurs by reimplementingQApplication::commitData(). This allowsus to save any unsaved data and to interact with the user if required. This partof session management is supported on both X11 and Windows.We will explore session management by going through the code of a session-aware Tic-Tac-Toe application. First, let’s look at themain()function:int main(int argc, char *argv[]){ Application app(argc, argv); TicTacToe toe; toe.setObjectName(\"toe\"); app.setTicTacToe(&toe); toe.show(); return app.exec();}We create anApplicationobject. TheApplicationclass inherits fromQAppli-cationand reimplements bothcommitData()andsaveState()to support sessionmanagement.Next, we create aTicTacToewidget, make theApplicationobject aware of it,and show it. We have called theTicTacToewidget “toe”. We must give uniqueobject names to top-level widgets if we want the session manager to restore thewindows’ sizes and positions."},{"pageNumber":451,"pageContent":"Handling X11 Session Management433Figure 20.8.The Tic-Tac-Toe applicationHere’s the definition of theApplicationclass:class Application : public QApplication{ Q_OBJECTpublic: Application(int &argc, char *argv[]); void setTicTacToe(TicTacToe *tic); void saveState(QSessionManager &sessionManager); void commitData(QSessionManager &sessionManager);private: TicTacToe *ticTacToe;};TheApplicationclass keeps a pointer to theTicTacToewidget as a privatevariable.void Application::saveState(QSessionManager &sessionManager){ QString fileName = ticTacToe->saveState(); QStringList discardCommand; discardCommand << \"rm\" << fileName; sessionManager.setDiscardCommand(discardCommand);}On X11, thesaveState()function is called when the session manager wantsthe application to save its state. The function is available on other platformsas well, but it is never called. TheQSessionManagerparameter allows us tocommunicate with the session manager.We start by asking theTicTacToewidget to save its state to a file. Then we setthe session manager’s discard command. Adiscard commandis a command"},{"pageNumber":452,"pageContent":"43420. Platform-Specific Featuresthat the session manager must execute to delete any stored informationregarding the current state. For this example, we set it torm sessionfilewheresessionfileis the name of the file that contains the saved state for thesession, andrmis the standard Unix command to remove files.The session manager also has arestart command. This is the command thatthe session manager must execute to restart the application. By default, Qtprovides the following restart command:appname -session id_keyThe first part,appname, is derived fromargv[0]. Theidpart is the session IDprovided by the session manager; it is guaranteed to be unique among differentapplications and among different runs of the same application. Thekeypart isadded to uniquely identify the time at which the state was saved. For variousreasons, the session manager can callsaveState()multiple times during thesame session, and the different states must be distinguished.Because of limitations in existing session managers, we must ensure that theapplication’s directory is in thePATHenvironment variable if we want the ap-plication to restart correctly. In particular, if you want to try out the Tic-Tac-Toe example for yourself, you must install it in, say,/usr/binand invoke it astictactoe.For simple applications, including Tic-Tac-Toe, we could save the state as anadditional command-line argument to the restart command. For example:tictactoe -state OX-XO-X-OThis would save us from storing the data in a file and providing a discardcommand to remove the file.void Application::commitData(QSessionManager &sessionManager){ if (ticTacToe->gameInProgress() && sessionManager.allowsInteraction()) { int r = QMessageBox::warning(ticTacToe, tr(\"Tic-Tac-Toe\"), tr(\"The game hasn’t finished.\\n\"  \"Do you really want to quit?\"), QMessageBox::Yes | QMessageBox::Default, QMessageBox::No | QMessageBox::Escape); if (r == QMessageBox::Yes) { sessionManager.release(); } else { sessionManager.cancel(); } }}ThecommitData()function is called when the user logs out. We can reimplementit to pop up a message box warning the user about potential data loss. The"},{"pageNumber":453,"pageContent":"Handling X11 Session Management435default implementation closes all top-level widgets, which results in the samebehavior as when the user closes the windows one after another by clickingthe close button in their title bars. In Chapter 3, we saw how to reimplementcloseEvent()to catch this and pop up a message box.For the purposes of this example, we reimplementcommitData()and pop up amessage box asking the user to confirm the log out if a game is in progress andif the session manager allows us to interact with the user. If the user clicksYes, we callrelease()to tell the session manager to continue logging out; if theuser clicksNo, we callcancel()to cancel the log out.Figure 20.9.“Do you really want to quit?”Now let’s look at theTicTacToeclass:class TicTacToe : public QWidget{ Q_OBJECTpublic: TicTacToe(QWidget *parent = 0); bool gameInProgress() const; QString saveState() const; QSize sizeHint() const;protected: void paintEvent(QPaintEvent *event); void mousePressEvent(QMouseEvent *event);private: enum { Empty = ’-’, Cross = ’X’, Nought = ’O’ }; void clearBoard(); void restoreState(); QString sessionFileName() const; QRect cellRect(int row, int column) const; int cellWidth() const { return width() / 3; } int cellHeight() const { return height() / 3; } bool threeInARow(int row1, int col1, int row3, int col3) const; char board[3][3]; int turnNumber;};"},{"pageNumber":454,"pageContent":"43620. Platform-Specific FeaturesTheTicTacToeclass inheritsQWidgetand reimplementssizeHint(),paintEvent(),andmousePressEvent(). It also provides thegameInProgress()andsaveState()functions that we used in ourApplicationclass.TicTacToe::TicTacToe(QWidget *parent) : QWidget(parent){ clearBoard(); if (qApp->isSessionRestored()) restoreState(); setWindowTitle(tr(\"Tic-Tac-Toe\"));}In the constructor, we clear the board, and if the application was invoked withthe-sessionoption, we call the private functionrestoreState()to reload theold session.void TicTacToe::clearBoard(){ for (int row = 0; row < 3; ++row) { for (int column = 0; column < 3; ++column) { board[row][column] = Empty; } } turnNumber = 0;}InclearBoard(), we clear all the cells and setturnNumberto 0.QString TicTacToe::saveState() const{ QFile file(sessionFileName()); if (file.open(QIODevice::WriteOnly)) { QTextStream out(&file); for (int row = 0; row < 3; ++row) { for (int column = 0; column < 3; ++column) out << board[row][column]; } } return file.fileName();}InsaveState(), we write the state of the board to disk. The format is straight-forward, with ‘X’ for crosses, ‘O’ for noughts, and ‘+--’ for empty cells.QString TicTacToe::sessionFileName() const{ return QDir::homePath() + \"/.tictactoe_\" + qApp->sessionId() + \"_\" + qApp->sessionKey();}ThesessionFileName()private function returns the file name for the currentsession ID and session key. This function is used for bothsaveState()andrestoreState(). The file name is derived from the session ID and session key."},{"pageNumber":455,"pageContent":"Handling X11 Session Management437void TicTacToe::restoreState(){ QFile file(sessionFileName()); if (file.open(QIODevice::ReadOnly)) { QTextStream in(&file); for (int row = 0; row < 3; ++row) { for (int column = 0; column < 3; ++column) { in >> board[row][column]; if (board[row][column] != Empty) ++turnNumber; } } } update();}InrestoreState(), we load the file that corresponds to the restored session andfill the board with that information. We deduce the value ofturnNumberfromthe number ofX’s andO’s on the board.In theTicTacToeconstructor, we calledrestoreState()ifQApplication::isSes-sionRestored()returnedtrue. In that case,sessionId()andsessionKey()returnthe same values as when the application’s state was saved, and sosessionFile-Name()returns the file name for that session.Testing and debugging session management can be frustrating, because weneed to log in and out all the time. One way to avoid this is to use the standardxsmutility provided with X11. The first time we invokexsm, it pops up a sessionmanager window and a terminal. The applications we start from that terminalwill all usexsmas their session manager instead of the usual, system-widesession manager. We can then usexsm’s window to end, restart, or discard asession, and see if our application behaves as it should. For details about howto do this, seehttp://doc.trolltech.com/4.1/session.html."},{"pageNumber":457,"pageContent":"21. Embedded ProgramminguGetting Started with QtopiauCustomizing Qtopia CoreDeveloping software to run on mobile devices such as PDAs and mobile phonescan be very challenging because embedded systems generally have slowerprocessors, less permanent storage (flash memory or hard disk), less memory,and smaller displays than desktop computers.Qtopia Core (previously called Qt/Embedded) is a version of Qt optimized forembedded Linux. Qtopia Core provides the same API and tools as the desktopversions of Qt (Qt/Windows, Qt/X11, and Qt/Mac), and adds the classes andtools necessary for embedded programming. Through dual licensing, it isavailable for both open source and commercial development.Qtopia Core can run on any hardware that runs Linux (including Intel x86,MIPS, ARM, StrongARM, Motorola 68000, and PowerPC architectures). Ithas a memory-mapped frame buffer and supports a C++compiler. UnlikeQt/X11, it does not need the X Window System; instead, it implements its ownwindow system (QWS), enabling significant storage and memory savings.To reduce its memory footprint even more, Qtopia Core can be recompiled toexclude unused features. If the applications and components used on a deviceare known in advance, they can be compiled together into one executable thatlinks statically against the Qtopia Core libraries.Qtopia Core also benefits from various features that are also part of thedesktop versions of Qt, including the extensive use of implicit data sharing(“copy on write”) as a memory-saving technique, support for custom widgetstyles throughQStyle, and a layout system that adapts to make the best use ofthe available screen space.Qtopia Core forms the basis of Trolltech’s embedded offering, which alsoincludes Qtopia Platform, Qtopia PDA, and Qtopia Phone. These provideclasses and applications designed specifically for portable devices and can beintegrated with several third-party Java virtual machines.439"},{"pageNumber":458,"pageContent":"44021. Embedded ProgrammingGetting Started with QtopiaQtopia Core applications can be developed on any platform equipped with amulti-platform tool chain. The most common option is to build a GNU C++cross-compiler on a Unix system. This process is simplified by a script anda set of patches provided by Dan Kegel athttp://kegel.com/crosstool/. SinceQtopia Core contains the Qt API, it is usually possible to use a desktop versionof Qt, such as Qt/X11 or Qt/Windows, for most of the development.Qtopia Core’s configuration system supports cross-compilers, through thecon-figurescript’s-embeddedoption. For example, to build for the ARM architecturewe would type./configure -embedded armWe can create custom configurations by adding new files to Qt’smkspecs/qwsdirectory.Qtopia Core draws directly to the Linux frame buffer (the memory areaassociated with the video display). To access the frame buffer, you might needto grant write permissions to the/dev/fb0device.To run Qtopia Core applications, we must first start one process to act as a serv-er. The server is responsible for allocating screen regions to clients and for gen-erating mouse and keyboard events. Any Qtopia Core application can becomea server by specifying-qwson its command line or by passingQApplication::GuiServeras the third parameter to theQApplicationconstructor.Client applications communicate with the Qtopia Core server using sharedmemory. Behind the scenes, the clients draw themselves into shared memoryand are responsible for painting their own window decorations. This keepscommunication between the clients and the server to a minimum, resultingin a snappy user interface. Qtopia Core applications normally useQPaintertodraw themselves, but they can also access the video hardware directly usingQDirectPainter.Clients can communicate with each other using the QCOP procotol. A clientcan listen on a named channel by creating aQCopChannelobject and connectingto itsreceived()signal. For example:QCopChannel *channel = new QCopChannel(\"System\", this);connect(channel, SIGNAL(received(const QString &, const QByteArray &)), this, SLOT(received(const QString &, const QByteArray &)));A QCOP message consists of a name and an optionalQByteArray. The staticQCopChannel::send()broadcasts a message on a channel. For example:QByteArray data;QDataStream out(&data, QIODevice::WriteOnly);out << QDateTime::currentDateTime();QCopChannel::send(\"System\", \"clockSkew(QDateTime)\", data);"},{"pageNumber":459,"pageContent":"Getting Started with Qtopia441The previous example illustrates a common idiom: We useQDataStreamtoencode the data, and to ensure that theQByteArrayis interpreted correctly bythe receiver, we mangle the data format in the message name as if it were aC++function.Various environment variables affect Qtopia Core applications. The mostimportant ones areQWS_MOUSE_PROTOandQWS_KEYBOARD, which specify the mousedevice and the keyboard type. Seehttp://doc.trolltech.com/4.1/emb-envvars.htmlfor a complete list of environment variables.If we use Unix as our development platform, we can test the application usingthe Qtopia virtual frame buffer (qvfb), an X11 application that simulates,pixel for pixel, the actual frame buffer. This accelerates the development cycleconsiderably. To enable virtual buffer support in Qtopia Core, pass the-qvfboption to theconfigurescript. Be aware that this option is not intended forproduction use. The virtual frame buffer application is located intools/qvfband can be invoked as follows:qvfb -width 320 -height 480 -depth 32Another option that works on most platforms is to use VNC (Virtual NetworkComputing) to run the applications remotely. To enable VNC support in QtopiaCore, pass the-qt-gfx-vncoption toconfigure. Then launch your Qtopia Coreapplications with the-display VNC:0command-line option and run a VNC clientpointing at the host on which your applications are running. The display sizeand bit depth can be specified by setting theQWS_SIZEandQWS_DEPTHenviron-ment variables on the host that runs the Qtopia Core applications (for example,QWS_SIZE=320x480andQWS_DEPTH=32).Customizing Qtopia CoreWhen installing Qtopia Core, we can specify features we want to leave out toreduce its memory footprint. Qtopia Core includes over a hundred configurablefeatures, each of which is associated to a preprocessor symbol. For example,QT_NO_FILEDIALOGexcludesQFileDialogfrom theQtGuilibrary, andQT_NO_I18Nleaves out all support for internationalization. The features are listedsrc/corelib/qfeatures.txt.Qtopia Core provides five example configurations (minimum,small,medium,large,anddist) that are stored insrc/corelib/qconfig_xxx.hfiles. These configu-rations can be specified using theconfigurescript’s-qconfig xxxoption, forexample:./configure -qconfig smallTo create custom configurations, we can manually provide aqconfig-xxx.hfileand use it as if it were a standard configuration. Alternatively, we can use theqconfiggraphical tool, located in Qt’stoolssubdirectory."},{"pageNumber":460,"pageContent":"44221. Embedded ProgrammingQtopia Core provides the following classes for interfacing with input andoutput devices and for customizing the look and feel of the window system:ClassBase class forQScreenscreen driversQScreenDriverPluginscreen driver pluginsQWSMouseHandlermouse driversQMouseDriverPluginmouse driver pluginsQWSKeyboardHandlerkeyboard driversQKbdDriverPluginkeyboard driver pluginsQWSInputMethodinput methodsQDecorationwindow decoration stylesQDecorationPluginplugins providing window decoration stylesTo obtain the list of predefined drivers, input methods, and window decorationstyles, run theconfigurescript with the-helpoption.The screen driver can be specified using the-displaycommand-line optionwhen starting the Qtopia Core server, as seen in the previous section, or bysetting theQWS_DISPLAYenvironment variable. The mouse driver and the asso-ciated device can be specified using theQWS_MOUSE_PROTOenvironment variable,whose value must have the syntaxtype:device, wheretypeis one of the sup-ported drivers anddevicethe path to the device (for example,QWS_MOUSE_PRO-TO=IntelliMouse:/dev/mouse). Keyboards are handled similarly through theQWS_KEYBOARDenvironment variable. Input methods and window decorations are setprogrammatically in the server usingQWSServer::setCurrentInputMethod()andQApplication::qwsSetDecoration().Window decoration styles can be set independently of the widget style, whichinherits fromQStyle. For example, it is entirely possible to set Windows asthe window decoration style and Plastique as the widget style. If desired,decorations can be set on a per-window basis.TheQWSServerclass provides various functions for customizing the windowsystem. Applications that run as Qtopia Core servers can access the uniqueQWSServerinstance through theqwsServerglobal variable, which is initializedby theQApplicationconstructor.Qtopia Core supports the following font formats: TrueType (TTF), Post-Script Type 1, Bitmap Distribution Format (BDF), and Qt Pre-renderedFonts (QPF).Because QPF is a raster format, it is faster and usually more compact thanvector formats such as TTF and Type 1 if we need it only at one or two differentsizes. Themakeqpftool lets us pre-render a TTF or a Type 1 file and save theresult in QPF format. An alternative is to run our applications with the-savefontscommand-line option."},{"pageNumber":461,"pageContent":"Customizing Qtopia Core443At the time of writing, Trolltech is developing an additional layer on top ofQtopia Core to make embedded application development even faster and moreconvenient. It is hoped that a later edition of this book will include moreinformation on this topic."},{"pageNumber":463,"pageContent":"Appendices"},{"pageNumber":465,"pageContent":"Installing QtAAuA Note on LicensinguInstalling Qt/WindowsuInstalling Qt/MacuInstalling Qt/X11This appendix explains how to install Qt from the CD that accompanies thisbook onto your system. The CD has editions of Qt 4.1.1 for Windows, Mac OS X,and X11 (for Linux and most versions of Unix). They all include SQLite, a pub-lic domain in-process database, together with a SQLite driver. The editions ofQt on the CD are provided for your convenience. For serious software develop-ment, it is best to download the latest version of Qt fromhttp://www.trolltech.com/download/or to buy a commercial version.Trolltech also provides Qtopia Core for building applications for Linux-basedembedded devices such as PDAs and mobile phones. If you are interested increating embedded applications, you can obtain Qtopia Core from Trolltech’sdownload web page.The example applications used in the book are on the CD in theexamplesdirectory. In addition, Qt provides many small example applications located intheexamplessubdirectory.A Note on LicensingQt is produced in two forms: open source and commercial. The open source edi-tions are available free of charge; the commercial editions must be paid for.The software on the CD is suitable for creating applications for your owneducational and personal use.If you want to distribute the applications that you create with an open sourceedition of Qt, you must comply with the specific terms and conditions laid downin the licenses for the software you use to create the applications. For opensource editions, the terms and conditions include the requirement to use theGNU General Public License (GPL). Open licenses like the GPL give the appli-cations’ users certain rights, including the right to view and modify the sourceand to distribute the applications (on the same terms). If you want to distributeyour applications without source code (to keep your code private) or if you want447"},{"pageNumber":466,"pageContent":"448A. Installing Qtto apply your own commercial license conditions to your applications, you mustbuy commercial editions of the software you use to create the applications. Thecommercial editions of the software allow you to sell and distribute your appli-cations on your own terms.The CD contains GPL versions of Qt for Windows, Mac OS X, and X11. The fulllegal texts of the licenses are included with the packages on the CD, along withinformation on how to obtain commercial versions.Installing Qt/WindowsWhen you insert the CD on a Windows machine, the installation programshould start automatically. If this does not occur, use File Explorer to navigateto the CD’s root folder and double-clickinstall.exe. (This program may appearasinstalldepending on how your system is configured.)If you already have the MinGW C++compiler you must specify the directorywhere it is located; otherwise, set the check box and have the installer installMinGW for you. The GPL version of Qt supplied on the CD will not work withVisual C++, so if you do not have MinGW already installed you will need toinstall it. The installer also gives you the option to install the examples thataccompany the book. Qt’s standard examples are automatically installed,along with the documentation.If you choose to install the MinGW compiler, there may be a small delay be-tween the completion of the MinGW installation and the start of the Qt instal-lation.After installation you will have a new folder in the Start menu called “Qt byTrolltech v4.1.1 (opensource)”. This folder has shortcuts toQt AssistantandQtDesigner, and also one called “Qt 4.1.1 Command Prompt” that starts a consolewindow. When you start this window it will set the environment variablesfor compiling Qt programs with MinGW. It is in this window that you can runqmakeandmaketo build Qt applications.Installing Qt/MacBefore Qt can be installed on Mac OS X, Apple’s Xcode Tools must already beinstalled. The CD (or DVD) containing these tools is usually supplied withMac OS X; they can also be downloaded from the Apple Developer Connection,http://developer.apple.com.If you have Mac OS X 10.4 (Tiger) and Xcode Tools 2.x (with GCC 4.0.x),you can use the installer described below. If you have an earlier version ofMac OS X, or an older version of GCC, you will need to install the source pack-age manually. This package is calledqt-mac-opensource-4.1.1.tar.gzand is lo-cated in themacfolder on the CD. If you install this package, follow the instruc-tions in the next section for installing Qt on X11."},{"pageNumber":467,"pageContent":"Installing Qt/Mac449To use the installer, insert the CD and double-click the package calledQt.mpkg.This will launch the installer,Installer.app, and Qt will be installed with thestandard examples, documentation, and the examples that accompany thisbook. Qt will be installed in/Developer, with the book’s examples in/Developer/Examples/Qt4Book.To run commands likeqmakeandmake, you will need to use a terminal window,for example,Terminal.appin/Applications/Utilities. It is also possible togenerate Xcode projects usingqmake. For example, to generate an Xcode projectfor thehelloexample, start a console such asTerminal.app, change directory to/Developer/Examples/Qt4Book/chap01/hello, and enter the following command:qmake -spec macx-xcode hello.proInstalling Qt/X11To install Qt in its default location on X11, you will need to be root. If you donot have root access, useconfigure’s-prefixargument to specify a directory towhich you have permission to write.1. Change directory to a temporary directory. For example:cd /tmp2. Unpack the archive file from the CD:cp /cdrom/x11/qt-x11-opensource-src-4.1.1.tgz .gunzip qt-x11-opensource-src-4.1.1.tgztar xvf qt-x11-opensource-src-4.1.1.tarThis will create the directory/tmp/qt-x11-opensource-src-4.1.1, assumingthat your CD-ROM is mounted at/cdrom. Qt requires GNUtar; on somesystems it is calledgtar.3. Execute theconfiguretool with your preferred options to build the Qtlibrary and the tools supplied with it:cd /tmp/qt-x11-opensource-src-4.1.1./configureYou can run./configure -helpto get a list of configuration options.4. To build Qt, typemakeThis will create the library and compile all the demos, examples, and tools.On some systemsmakeis calledgmake.5. To install Qt, typesu -c \"make install\""},{"pageNumber":468,"pageContent":"450A. Installing Qtand enter the root password. This will install Qt into/usr/local/Troll-tech/Qt-4.1.1. You can change the destination by using the-prefixoptionwithconfigure, and if you have write access to the destination you can sim-ply type:make install6. Set up certain environment variables for Qt.If your shell isbash,ksh,zsh, orsh, add the following lines to your.profilefile:PATH=/usr/local/Trolltech/Qt-4.1.1/bin:$PATHexport PATHIf your shell iscshortcsh, add the following line to your.loginfile:setenv PATH /usr/local/Trolltech/Qt-4.1.1/bin:$PATHIf you used-prefixwithconfigure, use the path you specified instead ofthe default path shown above.If you are using a compiler that does not supportrpathyou must alsoextend theLD_LIBRARY_PATHenvironment variable to include/usr/local/Trolltech/Qt-4.1.1/lib. This is not necessary on Linux with GCC.Qt comes with a demo application,qtdemo, that shows off many of the library’sfeatures. It serves as a nice starting point to see what Qt can do. To see Qt’sdocumentation, either visithttp://doc.trolltech.com, or runQt Assistant, Qt’shelp application, invoked by typingassistantin a console window."},{"pageNumber":469,"pageContent":"Introduction to C++for Java and C# ProgrammersBBuGetting Started with C++uMain Language DifferencesuThe Standard C++LibraryThis appendix provides a short introduction to C++for developers who alreadyknow Java or C#. It assumes that you are familiar with object-oriented con-cepts such as inheritance and polymorphism and want to learn C++. To avoidmaking this book an unwieldy 1,500 page doorstop by including a completeC++primer, this appendix confines itself to essentials. It presents the basicknowledge and techniques necessary to understand the programs present-ed in the rest of the book, with enough information to start developing cross-platform C++GUI applications using Qt.At the time of writing, C++is the only realistic option for writing cross-platform, high-performance object-oriented GUI applications. Its detractorsusually point out that Java or C#, which dropped C compatibility, are nicer touse; in fact, Bjarne Stroustrup, the inventor of C++, noted inThe Design andEvolution of C++that “within C++, there is a much smaller and cleaner lan-guage struggling to get out”.Fortunately, when we program with Qt, we usually stick to a subset of C++that is very close to the utopian language envisioned by Stroustrup, leavingus free to concentrate on the problem at hand. Furthermore, Qt extends C++in several respects, through its innovative “signals and slots” mechanism, itsUnicode support, and itsforeachkeyword.In the first section of this appendix, we will see how to combine C++sourcefiles to obtain an executable program. This will lead us to explore core C++concepts such as compilation units, header files, object files, libraries—and toget familiar with the C++preprocessor, compiler, and linker.Then we will turn to the most important language differences between C++,Java and C#: how to define classes, how to use pointers and references, how tooverload operators, how to use the preprocessor, and so on. Although the C++syntax is superficially similar to that of Java or C#, the underlying conceptsdiffer in subtle ways. At the same time, as an inspirational source for Java and451"},{"pageNumber":470,"pageContent":"452B. Introduction to C++for Java and C# ProgrammersC#, the C++language has a lot in common with these two languages, includingsimilar data types, the same arithmetic operators, and the same basic controlflow statements.The last section is dedicated to the Standard C++library, which provides ready-made functionality that can be used in any C++program. The library is theresult of over 30 years of evolution, and as such provides a wide range of ap-proaches including procedural, object-oriented, and functional programmingstyles, and both macros and templates. Compared with the libraries provid-ed with Java and C#, the Standard C++library has a rather limited scope; forexample, it has no support for GUI programming, multithreading, databases,internationalization, networking, XML, or Unicode. To broaden C++’s scopeinto these areas, C++developers are expected to use various (often platform-specific) libraries.This is where Qt saves the day. Qt began as a cross-platform GUI toolkit (aset of classes that makes it possible to write portable graphical user interfaceapplications) but rapidly evolved into a full-blown framework that partlyextends and partly replaces the Standard C++library. Although this book usesQt, it is useful to know what the Standard C++library has to offer, since youmay have to work with code that uses it.Getting Started with C++A C++program consists of one or morecompilation units. Each compilationunit is a separate source code file, typically with a.cppextension (other com-mon extensions are.ccand.cxx) that the compiler processes in one run. Foreach compilation unit, the compiler generates anobject file, with the exten-sion.obj(on Windows) or.o(on Unix and Mac OS X). The object file is a bina-ry file that contains machine code for the architecture on which the programwill run.Once all the.cppfiles have been compiled, we can combine the object filestogether to create an executable using a special program called thelinker.The linker concatenates the object files and resolves the memory addresses offunctions and other symbols referenced in the compilation units.unit1.cppunit2.cppunit3.cppunit1.objunit2.objunit3.objprogram.execompilingcompilinglinkinglinkingFigure B.1.The C++compilation process (on Windows)"},{"pageNumber":471,"pageContent":"Getting Started with C++453When building a program, exactly one compilation unit must contain amain()function that serves as the program’s entry point. This function doesn’t belongto any class; it is aglobal function.Unlike Java, where each source file must contain exactly one class, C++lets usorganize the compilation units as we want. We can implement several classesin the same.cppfile, or spread the implementation of a class across several.cppfiles, and we can give the source files any names we like. When we make achange in one particular.cppfile, we only need to recompile that file and thenrelink the application to create a new executable.Before we go further, let’s quickly review the source code of a trivial C++program that computes the square of an integer. The program consists of twocompilation units:main.cppandsquare.cpp.Here’ssquare.cpp:001double square(double n)002{003 return n * n;004}This file simply contains a global function calledsquare()that returns thesquare of its parameter.Here’smain.cpp:001#include <cstdlib>002#include <iostream>003using namespace std;004double square(double);005int main(int argc, char *argv[])006{007 if (argc != 2) {008 cerr << \"Usage: square <number>\" << endl;009 return 1;010 }011 double n = strtod(argv[1], 0);012 cout << \"The square of \" << argv[1] << \" is \" << square(n) << endl;013 return 0;014}Themain.cppsource file contains themain()function’s definition. In C++, thisfunction takes anintand achar *array (an array of character strings) asparameters. The program’s name is available asargv[0]and the command-linearguments asargv[1],argv[2], ...,argv[argc - 1]. The parameter namesargc(“argument count”) andargv(“argument values”) are conventional. If theprogram doesn’t access the command-line arguments, we can definemain()with no parameters."},{"pageNumber":472,"pageContent":"454B. Introduction to C++for Java and C# ProgrammersThemain()function usesstrtod()(“string todouble”),cout(C++’s standardoutput stream), andcerr(C++’s standard error stream) from the Standard C++library to convert the command-line argument to adoubleand to print text tothe console. Strings, numbers, and end-of-line markers (endl) are output usingthe<<operator, which is also used for bit-shifting. To access this standardfunctionality, we need the#includedirectives on lines 1 and 2.Theusing namespacedirective on line 3 tells the compiler that we want to importall identifiers declared in thestdnamespace into the global namespace. Thisenables us to writestrtod(),cout,cerr, andendlinstead of the fully-qualifiedstd::strtod(),std::cout,std::cerr, andstd::endl. In C++, the::operatorseparates the components of a complex name.The declaration on line 4 is afunction prototype. It tells the compiler thata function exists with the given parameters and return value. The actualfunction can be located in the same compilation unit or in another compilationunit. Without the function prototype, the compiler wouldn’t let us call thefunction on line 12. Parameter names in function prototypes are optional.The procedure to compile the program varies from platform to platform. Forexample, to compile on Solaris with the Sun C++compiler, we would type thefollowing commands:CC -c main.cppCC -c square.cppld main.o square.o -o squareThe first two lines invoke the compiler to generate.ofiles for the.cppfiles. Thethird line invokes the linker and generates an executable calledsquare, whichwe can invoke as follows:./square 64The program outputs the following message to the console:The square of 64 is 4096To compile the program, you probably want to get help from your local C++guru. Failing this, you can still read the rest of this appendix without com-piling anything and follow the instructions in Chapter 1 to compile your firstC++/Qt application. Qt provides tools that make it easy to build applicationson all platforms.Back to our program: In a real-world application, we would normally put thesquare()function prototype in a separate file and include that file in all thecompilation units where we need to call the function. Such a file is called aheader fileand usually has a.hextension (.hh,.hpp, and.hxxare also common).If we redo our example using the header file approach, we would create a filecalledsquare.hwith the following contents:001#ifndef SQUARE_H002#define SQUARE_H"},{"pageNumber":473,"pageContent":"Getting Started with C++455003double square(double);004#endifThe header file is bracketed by three preprocessor directives (#ifndef,#define,and#endif). These directives ensure that the header file is processed only once,even if the header file is included several times in the same compilation unit(a situation that can arise when header files include other header files). Byconvention, the preprocessor symbol used to accomplish this is derived fromthe file name (in our example,SQUARE_H). We will come back to the preprocessorlater in this appendix.The newmain.cppfile looks like this:001#include <cstdlib>002#include <iostream>003#include \"square.h\"004using namespace std;005int main(int argc, char *argv[])006{007 if (argc != 2) {008 cerr << \"Usage: square <number>\" << endl;009 return 1;010 }011 double n = strtod(argv[1], 0);012 cout << \"The square of \" << argv[1] << \" is \" << square(n) << endl;013 return 0;014}The#includedirective on line 3 expands to the contents of the filesquare.h.Directives that start with a#are picked up by the C++preprocessor beforethe compilation proper takes place. In the old days, the preprocessor was aseparate program that the programmer invoked manually before running thecompiler. Modern compilers handle the preprocessor step implicitly.The#includedirectives on lines 1 and 2 expand to the contents of thecstdlibandiostreamheader files, which are part of the Standard C++library. Stan-dard header files have no.hsuffix. The angle brackets around the file namesindicate that the header files are located in a standard location on the system,while double quotes tell the compiler to look in the current directory. Includesare normally gathered at the top of a.cppfile.Unlike.cppfiles, header files are not compilation units in their own right anddo not result in any object files. They may only contain declarations that en-able different compilation units to communicate with each other. Consequent-ly, it would be inappropriate to put thesquare()function’s implementation in aheader file. If we did so in our example, nothing bad would happen, because weincludesquare.honly once, but if we includedsquare.hfrom several.cppfiles,we would get multiple implementations of thesquare()function (one per.cpp"},{"pageNumber":474,"pageContent":"456B. Introduction to C++for Java and C# Programmersfile that includes it). The linker would then complain about multiple (identi-cal) definitions ofsquare()and refuse to generate an executable. Inversely, ifwe declare a function but never implement it, the linker complains about an“unresolved symbol”.So far, we have assumed that an executable only consists of object files. Inpractice, they often also link against libraries that implement ready-madefunctionality. There are two main types of library:•Static librariesare put directly into the executable, as if they were objectfiles. This ensures that the library cannot get lost but increases the sizeof the executable.•Dynamic libraries(also called shared libraries or DLLs) are located at astandard location on the user’s machine and are automatically loaded atapplication startup.For thesquareprogram, we link against the Standard C++library, which isimplemented as a dynamic library on most platforms. Qt itself is a collectionof libraries that can be built either as static or as dynamic libraries (the defaultis dynamic).Main Language DifferencesWe will now take a more structured look at the areas where C++differs fromJava and C#. Many of the language differences are due to C++’s compiled na-ture and commitment to performance. Thus, C++does not check array boundsat run-time, and there is no garbage collector to reclaim unused dynamicallyallocated memory.For the sake of brevity, C++constructs that are nearly identical to their Javaand C# counterparts are not reviewed. In addition, some C++topics are notcovered here because they are not necessary when programming using Qt.Among these are defining template classes and functions, defining union types,and using exceptions. For the whole story, refer to a book such asThe C++Programming Languageby Bjarne Stroustrup orC++for Java Programmersby Mark Allen Weiss.Primitive Data TypesThe primitive data types offered by the C++language are similar to thosefound in Java or C#. Figure B.2 lists C++’s primitive types and their definitionon the platforms supported by Qt 4.By default, theshort,int,long, andlong longdata types are signed, meaningthat they can hold negative values as well as positive values. If we only needto store nonnegative integers, we can put theunsignedkeyword in front ofthe type. While ashortcan hold any value between+--32,768 and +32,767, anunsigned shortgoes from 0 to 65,535. The right-shift operator>>has unsigned(“fill with 0s”) semantics if one of the operands is unsigned."},{"pageNumber":475,"pageContent":"Main Language Differences457C++typeDescriptionboolBoolean valuechar8-bit integershort16-bit integerint32-bit integerlong32-bit or 64-bit integerlong longH64-bit integerfloat32-bit floating-point value (IEEE 754)double64-bit floating-point value (IEEE 754)Figure B.2.Primitive C++typesThebooltype can take the valuestrueandfalse. In addition, numeric typescan be used where aboolis expected, with the rule that 0 meansfalseand anynon-zero value meanstrue.Thechartype is used both for storing ASCII characters and 8-bit integers(bytes). When used as an integer, it can be signed or unsigned, depending onthe platform. The typessigned charandunsigned charare available as unam-biguous alternatives tochar. Qt provides aQChartype that stores 16-bit Unicodecharacters.Instances of built-in types are not initialized by default. When we createanintvariable, its value could conceivably be 0, but could just as likely be+--209,486,515. Fortunately, most compilers warn us when we attempt to readthe contents of an uninitialized variable, and we can use tools like RationalPurifyPlus and Valgrind to detect unitialized memory accesses and othermemory-related problems at run-time.In memory, the numeric types (exceptlong) have identical sizes on the differ-ent platforms supported by Qt, but their representation varies depending onthe system’s byte order. On big-endian architectures (such as PowerPC andSPARC), the 32-bit value0x12345678is stored as the four bytes0x12 0x34 0x560x78, whereas on little-endian architectures (such as Intel x86), the byte se-quence is reversed. This makes a difference in programs that copy memory ar-eas onto disk or that send binary data over the network. Qt’sQDataStreamclass,presented in Chapter 12 (Input/Output), can be used to store binary data in aplatform-independent way.HMicrosoft calls thelong longtype__int64. In Qt programs,qlonglongis available as an alternativethat works on all Qt platforms."},{"pageNumber":476,"pageContent":"458B. Introduction to C++for Java and C# ProgrammersClass DefinitionsClass definitions in C++are similar to those in Java and C#, but there are sev-eral differences to be aware of. We will study these differences using a seriesof examples. Let’s start with a class that represent an (x,y) coordinate pair:#ifndef POINT2D_H#define POINT2D_Hclass Point2D{public: Point2D() { xVal = 0; yVal = 0; } Point2D(double x, double y) { xVal = x; yVal = y; } void setX(double x) { xVal = x; } void setY(double y) { yVal = y; } double x() const { return xVal; } double y() const { return yVal; }private: double xVal; double yVal;};#endifThe above class definition would appear in a header file, typically calledpoint2d.h. The example exhibits the following C++idiosyncrasies:• A class definition is divided in public, protected, and private sections, andends with a semicolon. If no section is specified, the default is private. (Forcompatibility with C, C++provides astructkeyword that is identical toclassexcept that the default is public if no section is specified.)• The class has two constructors (one that has no parameters and one thathas two). If we declared no constructor, C++would automatically supplyone with no parameters and an empty body.• The getter functionsx()andy()are declared to be const. This meansthat they don’t (and can’t) modify the member variables or call non-constmember functions (such assetX()andsetY()).The functions above were implemented inline, as part of the class definition.An alternative is to provide only function prototypes in the header file and toimplement the functions in a.cppfile. Using this approach, the header filewould look like this:#ifndef POINT2D_H"},{"pageNumber":477,"pageContent":"Main Language Differences459#define POINT2D_Hclass Point2D{public: Point2D(); Point2D(double x, double y); void setX(double x); void setY(double y); double x() const; double y() const;private: double xVal; double yVal;};#endifThe functions would then be implemented inpoint2d.cpp:#include \"point2d.h\"Point2D::Point2D(){ xVal = 0.0; yVal = 0.0;}Point2D::Point2D(double x, double y){ xVal = x; yVal = y;}void Point2D::setX(double x){ xVal = x;}void Point2D::setY(double y){ yVal = y;}double Point2D::x() const{ return xVal;}double Point2D::y() const{ return yVal;}We start by includingpoint2d.hbecause the compiler needs the class definitionbefore it can parse member function implementations. Then we implement"},{"pageNumber":478,"pageContent":"460B. Introduction to C++for Java and C# Programmersthe functions, prefixing the function name with the class name using the::operator.We have seen how to implement a function inline and now how to implementit in a.cppfile. The two approaches are semantically equivalent, but when wecall a function that is declared inline, most compilers simply expand the func-tion’s body instead of generating an actual function call. This normally leadsto faster code, but might increase the size of your application. For this rea-son, only very short functions should be implemented inline; longer functionsshould always be implemented in a.cppfile. In addition, if we forget to imple-ment a function and try to call it, the linker will complain about an unresolvedsymbol.Now, let’s try to use the class.#include \"point2d.h\"int main(){ Point2D alpha; Point2D beta(0.666, 0.875); alpha.setX(beta.y()); beta.setY(alpha.x()); return 0;}In C++, variables of any types can be declared directly without usingnew.The first variable is initialized using the defaultPoint2Dconstructor (theconstructor that has no parameters). The second variable is initialized usingthe second constructor. Access to an object’s member is performed using the.(dot) operator.Variables declared this way behave like Java/C# primitive types such asintanddouble. For example, when we use the assignment operator, the contentsof the variable is copied—not just a reference to an object. And if we modi-fy a variable later on, any other variables that were assigned from it are leftunchanged.As an object-oriented language, C++supports inheritance and polymorphism.To illustrate how it works, we will review the example of aShapeabstract baseclass and a subclass calledCircle. Let’s start with the base class:#ifndef SHAPE_H#define SHAPE_H#include \"point2d.h\"class Shape{public: Shape(Point2D center) { myCenter = center; }"},{"pageNumber":479,"pageContent":"Main Language Differences461 virtual void draw() = 0;protected: Point2D myCenter;};#endifThe definition appears in a header file calledshape.h. Since the class definitionrefers to thePoint2Dclass, we includepoint2d.h.TheShapeclass has no base class. Unlike Java and C#, C++doesn’t providea genericObjectclass from which all classes inherit. Qt providesQObjectas anatural base class for all kinds of objects.Thedraw()function declaration has two interesting features: It contains thevirtualkeyword, and it ends with= 0. Thevirtualkeyword indicates thatthe function may be reimplemented in subclasses. Like in C#, C++memberfunctions aren’t reimplementable by default. The bizarre= 0syntax indicatesthat the function is apure virtual function—a function that has no defaultimplementation and that must be implemented in subclasses. The concept ofan “interface” in Java and C# maps to a class with only pure virtual functionsin C++.Here’s the definition of theCirclesubclass:#ifndef CIRCLE_H#define CIRCLE_H#include \"shape.h\"class Circle : public Shape{public: Circle(Point2D center, double radius = 0.5) : Shape(center) { myRadius = radius; } void draw() { // do something here }private: double myRadius;};#endifTheCircleclass inherits publicly fromShape, meaning that all public mem-bers ofShaperemain public inCircle. C++also supports protected and privateinheritance, which restrict the access of the base class’s public and protectedmembers.The constructor takes two parameters. The second parameter is optionaland takes the value 0.5 if not specified. The constructor passes thecenter"},{"pageNumber":480,"pageContent":"462B. Introduction to C++for Java and C# Programmersparameter to the base class’s constructor using a special syntax between thefunction signature and the function body. In the body, we initialize themyRadiusmember variable. We could also have initialized the variable on the same lineas the base class constructor initialization: Circle(Point2D center, double radius = 0.5) : Shape(center), myRadius(radius) { }On the other hand, C++doesn’t allow us to initialize a member variable in theclass definition, so the following code is wrong:// WON’T COMPILEprivate: double myRadius = 0.5;};Thedraw()function has the same signature as the virtualdraw()function de-clared inShape. It is a reimplementation and it will be invoked polymorphicallywhendraw()is called on aCircleinstance through aShapereference or pointer.C++has nooverridekeyword like in C#. Nor does C++have asuperorbasekey-word that refers to the base class. If we need to call the base implementationof a function, we can prefix the function name with the base class name andthe::operator. For example:class LabeledCircle : public Circle{public: void draw() { Circle::draw(); drawLabel(); } ...};C++supports multiple inheritance, meaning that a class can derive fromseveral classes at the same time. The syntax is as follows:class DerivedClass : public BaseClass1, public BaseClass2, ..., public BaseClassN{ ...};By default, functions and variables declared in a class are associated withinstances of that class. We can also declare static member functions and staticmember variables, which can be used without an instance. For example:#ifndef TRUCK_H#define TRUCK_Hclass Truck{public: Truck() { ++counter; }"},{"pageNumber":481,"pageContent":"Main Language Differences463 ~Truck() { --counter; } static int instanceCount() { return counter; }private: static int counter;};#endifThe static member variablecounterkeeps track of how manyTruckinstancesexist at any time. TheTruckconstructor increments it. The destructor, recog-nizable by the~prefix, decrements it. In C++, the destructor is automaticallyinvoked when a statically allocated variable goes out of scope or when a vari-able allocated usingnewis deleted. This is similar to thefinalize()method inJava, except that we can rely on it being called at a specific point in time.A static member variable has a single existence in a class: Such variables are“class variables” rather than “instance variables”. Each static member vari-able must be defined in a.cppfile (but without repeating thestatickeyword).For example:#include \"truck.h\"int Truck::counter = 0;Failing to do this would result in an “unresolved symbol” error at link time.TheinstanceCount()static function can be accessed from outside the class,prefixed by the class name. For example:#include <iostream>#include \"truck.h\"using namespace std;int main(){ Truck truck1; Truck truck2; cout << Truck::instanceCount() << \" equals 2\" << endl; return 0;}PointersApointerin C++is a variable that stores the memory address of an object(instead of storing the object directly). Java and C# have a similar concept,that of a “reference”, but the syntax is different. We will start by studying acontrived example that illustrates pointers in action:001#include \"point2d.h\"002int main()"},{"pageNumber":482,"pageContent":"464B. Introduction to C++for Java and C# Programmers003{004 Point2D alpha;005 Point2D beta;006 Point2D *ptr;007 ptr = &alpha;008 ptr->setX(1.0);009 ptr->setY(2.5);010 ptr = &beta;011 ptr->setX(4.0);012 ptr->setY(4.5);013 ptr = 0;014 return 0;015}The example relies on thePoint2Dclass from the previous subsection. Lines 4and 5 define two objects of typePoint2D. These objects are initialized to (0, 0)by the defaultPoint2Dconstructor.Line 6 defines a pointer to aPoint2Dobject. The syntax for pointers uses anasterisk in front of the variable name. Since we did not initialize the pointer,it contains a random memory address. This is solved on line 7 by assigningalpha’s address to the pointer. The unary&operator returns the memoryaddress of an object. An address is typically a 32-bit or a 64-bit integer valuespecifying the offset of an object in memory.On lines 8 and 9, we access thealphaobject through theptrpointer. Becauseptris a pointer and not an object, we must use the->(arrow) operator insteadof the.(dot) operator.On line 10, we assignbeta’s address to the pointer. From then on, any operationwe perform through the pointer will affect thebetaobject.Line 13 sets the pointer to be a null pointer. C++has no keyword for represent-ing a pointer that does not point to an object; instead, we use the value 0 (or thesymbolic constantNULL, which expands to 0). Trying to use a null pointer resultsin a crash with an error message such as “Segmentation fault”, “General pro-tection fault”, or “Bus error”. Using a debugger, we can find out which line ofcode caused the crash.At the end of the function, thealphaobject holds the coordinate pair (1.0, 2.5),whereasbetaholds (4.0, 4.5).Pointers are often used to store objects allocated dynamically usingnew. InC++jargon, we say that these objects are allocated on the “heap”, whereas localvariables (variables defined inside a function) are stored on the “stack”.Here’s a code snippet that illustrates dynamic memory allocation usingnew:#include \"point2d.h\""},{"pageNumber":483,"pageContent":"Main Language Differences465int main(){ Point2D *point = new Point2D; point->setX(1.0); point->setY(2.5); delete point; return 0;}Thenewoperator returns the memory address of a newly allocated object. Westore the address in a pointer variable and access the object through that point-er. When we are done with the object, we release its memory using thedeleteoperator. Unlike Java and C#, C++has no garbage collector; dynamically allo-cated objects must be explicitly released usingdeletewhen we don’t need themanymore. Chapter 2 describes Qt’s parent–child mechanism, which greatlysimplifies memory management in C++programs.If we forget to calldelete, the memory is kept around until the program finish-es. This would not be an issue in the example above, because we only allocateone object, but in a program that allocates new objects all the time, this couldcause the program to keep allocating memory until the machine’s memory isexhausted. Once an object is deleted, the pointer variable still holds the ad-dress of the object. Such a pointer is a “dangling pointer” and should not beused to access the object. Qt provides a “smart” pointer,QPointer<T>, that auto-matically sets itself to 0 if theQObjectit points to is deleted.In the example above, we invoked the default constructor and calledsetX()andsetY()to initialize the object. We could have used the two-parameterconstructor instead:qPoint2D *point = new Point2D(1.0, 2.5);The example didn’t require the use ofnewanddelete. We could just as well haveallocated the object on the stack as follows:Point2D point;point.setX(1.0);point.setY(2.5);Objects allocated like this are automatically freed at the end of the block inwhich they appear.If we don’t intend to modify the object through the pointer, we can declare thepointer const. For example:const Point2D *ptr = new Point2D(1.0, 2.5);double x = ptr->x();double y = ptr->y();// WON’T COMPILEptr->setX(4.0);*ptr = Point2D(4.0, 4.5);"},{"pageNumber":484,"pageContent":"466B. Introduction to C++for Java and C# ProgrammersTheptrconst pointer can only be used to call const member functions suchasx()andy(). It is good style to declare pointers const when we don’t intendto modify the object using them. Furthermore, if the object itself is const, wehave no choice but to use a const pointer to store its address. The use ofconstprovides information to the compiler that can lead to early bug detection andperformance gains. C# has aconstkeyword that is very similar to that ofC++. The closest Java equivalent isfinal, but it only protects variables fromassignment, not from calling “non-const” member functions on it.Pointers can be used with built-in types as well as with classes. In an expres-sion, the unary*operator returns the value of the object associated with thepointer. For example:int i = 10;int j = 20;int *p = &i;int *q = &j;cout << *p << \" equals 10\" << endl;cout << *q << \" equals 20\" << endl;*p = 40;cout << i << \" equals 40\" << endl;p = q;*p = 100;cout << i << \" equals 40\" << endl;cout << j << \" equals 100\" << endl;The->operator, which can be used to access an object’s members througha pointer, is pure syntactic sugar. Instead ofptr->member, we can also write(*ptr).member. The parentheses are necessary because the.(dot) operator hasprecedence over the unary*operator.Pointers had a poor reputation in C and C++, to the extent that Java is often ad-vertised as having no pointers. In reality, C++pointers are conceptually similarto Java and C# references except that we can use pointers to iterate throughmemory, as we will see later in this section. Furthermore, the inclusion of “copyon write” container classes in Qt, along with C++’s ability to instantiate anyclass on the stack, means that we can often avoid pointers.ReferencesIn addition to pointers, C++also supports the concept of a “reference”. Like apointer, a C++reference stores the address of an object. The main differencesare these:• References are declared using&instead of*.• The reference must be initialized and can’t be reassigned later."},{"pageNumber":485,"pageContent":"Main Language Differences467• The object associated with a reference is directly accessible; there is nospecial syntax such as*or->.• A reference cannot be null.References are mostly used when declaring parameters. By default, C++uses call-by-value as its parameter-passing mechanism, meaning that whenan argument is passed to a function, the function receives a brand new copyof the object. Here’s the definition of a function that receives its parametersthrough call-by-value:#include <cstdlib>using namespace std;double manhattanDistance(Point2D a, Point2D b){ return abs(b.x() - a.x()) + abs(b.y() - a.y());}We would then invoke the function as follows:Point2D broadway(12.5, 40.0);Point2D harlem(77.5, 50.0);double distance = manhattanDistance(broadway, harlem);Reformed C programmers avoid needless copy operations by declaring theirparameters as pointers instead of as values:double manhattanDistance(const Point2D *ap, const Point2D *bp){ return abs(bp->x() - ap->x()) + abs(bp->y() - ap->y());}They must then pass addresses instead of values when calling the function:Point2D broadway(12.5, 40.0);Point2D harlem(77.5, 50.0);double distance = manhattanDistance(&broadway, &harlem);C++introduced references to make the syntax less cumbersome and to preventthe caller from passing a null pointer. If we use references instead of pointers,the function looks like this:double manhattanDistance(const Point2D &a, const Point2D &b){ return abs(b.x() - a.x()) + abs(b.y() - a.y());}The declaration of a reference is similar to that of a pointer, with&insteadof*. But when we actually use the reference, we can forget that it is a memoryaddress and treat it like an ordinary variable. In addition, calling a functionthat takes references as arguments doesn’t require any special care (no&operator)."},{"pageNumber":486,"pageContent":"468B. Introduction to C++for Java and C# ProgrammersAll in all, by replacingPoint2Dwithconst Point2D &in the parameter list, wereduced the overhead of the function call: Instead of copying 256 bits (the sizeof fourdoubles), we copy only 64 or 128 bits, depending on the target platform’spointer size.The previous example used const references, preventing the function frommodifying the objects associated with the references. When this kind of sideeffect is desired, we can pass a non-const reference or pointer. For example:void transpose(Point2D &point){ double oldX = point.x(); point.setX(point.y()); point.setY(oldX);}In some cases, we have a reference and we need to call a function that takesa pointer, or vice versa. To convert a reference to a pointer, we can simply usethe unary&operator:Point2D point;Point2D &ref = point;Point2D *ptr = &ref;To convert a pointer to a reference, there’s the unary*operator:Point2D point;Point2D *ptr = &point;Point2D &ref = *ptr;References and pointers are represented the same way in memory, and theycan often be used interchangeably, which begs the question of when to usewhich. On the one hand, references have a more convenient syntax; on theother hand, pointers can be reassigned at any time to point to another object,they can hold a null value, and their more explicit syntax is often a blessingin disguise. For these reasons, pointers tend to prevail, with references almostexclusively used for declaring function parameters, in conjunction withconst.ArraysArrays in C++are declared by specifying the number of items in the arraywithin brackets in the variable declarationafterthe variable name. Two-dimensional arrays are possible using an array of arrays. Here’s the definitionof a one-dimensional array containing 10 items of typeint:int fibonacci[10];The items are accessible asfibonacci[0],fibonacci[1], ...,fibonacci[9]. Oftenwe want to initialize the array as we define it:int fibonacci[10] = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 };"},{"pageNumber":487,"pageContent":"Main Language Differences469In such cases, we can then omit the array size, since the compiler can deduceit from the number of initializers:int fibonacci[] = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 };Static initialization also works for complex types, such asPoint2D:Point2D triangle[] = { Point2D(0.0, 0.0), Point2D(1.0, 0.0), Point2D(0.5, 0.866)};If we have no intention of altering the array later on, we can make it const:const int fibonacci[] = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 };To find out how many items an array contains, we can use thesizeof()operatoras follows:int n = sizeof(fibonacci) / sizeof(fibonacci[0]);Thesizeof()operator returns the size of its argument in bytes. The numberof items in an array is its size in bytes divided by the size of one of its items.Because this is cumbersome to type, a common alternative is to declare aconstant and to use it for defining the array:enum { NFibonacci = 10 };const int fibonacci[NFibonacci] = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 };It would have been tempting to declare the constant as aconst intvariable.Unfortunately, some compilers have issues with const variables as array sizespecifiers. Theenumkeyword will be explained later in this appendix.Iterating through an array is normally done using an integer. For example:for (int i = 0; i < NFibonacci; ++i) cout << fibonacci[i] << endl;It is also possible to traverse the array using a pointer:const int *ptr = &fibonacci[0];while (ptr != &fibonacci[10]) { cout << *ptr << endl; ++ptr;}We initialize the pointer with the address of the first item and loop until wereach the “one past the last” item (the “eleventh” item,fibonacci[10]). At eachiteration, the++operator advances the pointer to the next item.Instead of&fibonacci[0], we could also have writtenfibonacci. This is becausethe name of an array used alone is automatically converted into a pointer tothe first item in the array. Similarly, we could substitutefibonacci + 10for&fibonacci[10]. This works the other way around as well: We can retrievethe contents of the current item using either*ptrorptr[0]and could access"},{"pageNumber":488,"pageContent":"470B. Introduction to C++for Java and C# Programmersthe next item using*(ptr + 1)orptr[1]. This principle is sometimes called“equivalence of pointers and arrays”.To prevent what it considers to be a gratuitous inefficiency, C++does not letus pass arrays to functions by value. Instead, they must be passed by address.For example:#include <iostream>using namespace std;void printIntegerTable(const int *table, int size){ for (int i = 0; i < size; ++i) cout << table[i] << endl;}int main(){ const int fibonacci[10] = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 }; printIntegerTable(fibonacci, 10); return 0;}Ironically, although C++doesn’t give us any choice about whether we want topass an array by address or by value, it gives us some freedom in thesyntaxused to declare the parameter type. Instead ofconst int *table, we could alsohave writtenconst int table[]to declare a pointer-to-constant-intparameter.Similarly, theargvparameter tomain()can be declared as eitherchar *argv[]orchar **argv.To copy an array into another array, one approach is to loop through thearray:const int fibonacci[NFibonacci] = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 };int temp[NFibonacci];for (int i = 0; i < NFibonacci; ++i) temp[i] = fibonacci[i];For basic data types such asint, we can also usestd::memcpy(), which copies ablock of memory. For example:memcpy(temp, fibonacci, sizeof(fibonacci));When we declare a C++array, the size must be a constant.HIf we want to createan array of a variable size, we have several options.•We can dynamically allocate the array:int *fibonacci = new int[n];HSome compilers allow variables in that context, but this feature should not be relied upon inportable programs."},{"pageNumber":489,"pageContent":"Main Language Differences471Thenew []operator allocates a certain number of items at consecutivememory locations and returns a pointer to the first item. Thanks to the“equivalence of pointers and arrays” principle, the items can be accessedthrough the pointer asfibonacci[0],fibonacci[1], ...,fibonacci[n - 1].When we have finished using the array, we should release the memory itconsumes using thedelete []operator:delete [] fibonacci;•We can use the standard std::vector<T> class:#include <vector>using namespace std;vector<int> fibonacci(n);Items are accessible using the[]operator, just like with a plain C++array.Withstd::vector<T>(whereTis the type of the items stored in the vector),we can resize the array at any time usingresize()and we can copy it usingthe assignment operator. Classes that contain angle brackets (<>) in theirname are called template classes.•We can use Qt’s QVector<T> class:#include <QVector>QVector<int> fibonacci(n);QVector<T>’s API is very similar to that ofstd::vector<T>, but it also sup-ports iteration using Qt’sforeachkeyword and uses implicit data shar-ing (“copy on write”) as a memory and speed optimization. Chapter 11presents Qt’s container classes and explains how they relate to the Stan-dard C++containers.You might be tempted to avoid built-in arrays whenever possible and usestd::vector<T>orQVector<T>instead. It is nonetheless worthwhile understand-ing how the built-in arrays work because sooner or later you might want touse them in highly optimized code, or need them to interface with existing Clibraries.Character StringsThe most basic way of representing character strings in C++is to use anarray ofchars terminated by a null byte (‘/0’). The following four functionsdemonstrate how these kinds of strings work:void hello1(){ const char str[] = { ’H’, ’e’, ’l’, ’l’, ’o’, ’ ’, ’w’, ’o’, ’r’, ’l’, ’d’, ’\\0’ }; cout << str << endl;"},{"pageNumber":490,"pageContent":"472B. Introduction to C++for Java and C# Programmers}void hello2(){ const char str[] = \"Hello world!\"; cout << str << endl;}void hello3(){ cout << \"Hello world!\" << endl;}void hello4(){ const char *str = \"Hello world!\"; cout << str << endl;}In the first function, we declare the string as an array and initialize it thehard way. Notice the ‘/0’ terminator at the end, which indicates the end of thestring. The second function has a similar array definition, but this time weuse a string literal to initialize the array. In C++, string literals are simplyconst chararrays with an implicit ‘/0’ terminator. The third function uses astring literal directly, without giving it a name. Once translated into machinelanguage instructions, it is identical to the previous two functions.The fourth function is a bit different in that it creates not only an (anonymous)array but also a pointer variable calledstrthat stores the address of thearray’s first item. In spite of this, the semantics of the function are identical tothe previous three functions, and an optimizing compiler would eliminate thesuperfluousstrvariable.Functions that take C++strings as arguments usually take either achar *oraconst char *. Here’s a short program that illustrates the use of both:#include <cctype>#include <iostream>using namespace std;void makeUppercase(char *str){ for (int i = 0; str[i] != ’\\0’; ++i) str[i] = toupper(str[i]);}void writeLine(const char *str){ cout << str << endl;}int main(int argc, char *argv[]){ for (int i = 1; i < argc; ++i) {"},{"pageNumber":491,"pageContent":"Main Language Differences473 makeUppercase(argv[i]); writeLine(argv[i]); } return 0;}In C++, thechartype normally holds an 8-bit value. This means that we caneasily store ASCII, ISO 8859-1 (Latin-1), and other 8-bit-encoded strings inachararray, but that we can’t store arbitrary Unicode characters without re-sorting to multibyte sequences. Qt provides the powerfulQStringclass, whichstores Unicode strings as sequences of 16-bitQChars and internally uses theimplicit data sharing (“copy on write”) optimization. Chapter 11 (ContainerClasses) and Chapter 17 (Internationalization) explainQStringin more detail.EnumerationsC++has an enumeration feature for declaring a set of named constants similarto that provided by C#. Let’s suppose that we want to store days of the week ina program:enum DayOfWeek { Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday};Normally, we would put this declaration in a header file, or even inside a class.The above declaration is superficially equivalent to the following constant defi-nitions:const int Sunday = 0;const int Monday = 1;const int Tuesday = 2;const int Wednesday = 3;const int Thursday = 4;const int Friday = 5;const int Saturday = 6;By using the enumeration construct, we can later declare variables or param-eters of typeDayOfWeekand the compiler will ensure that only values from theDayOfWeekenumeration are assigned to it. For example:DayOfWeek day = Sunday;If we don’t care about type safety, we can also writeint day = Sunday;Notice that to refer to theSundayconstant from theDayOfWeekenum, we simplywriteSunday, notDayOfWeek::Sunday.By default, the compiler assigns consecutive integer values to the constants ofan enum, starting at 0. We can specify other values if we want:enum DayOfWeek { Sunday = 628,"},{"pageNumber":492,"pageContent":"474B. Introduction to C++for Java and C# Programmers Monday = 616, Tuesday = 735, Wednesday = 932, Thursday = 852, Friday = 607, Saturday = 845};If we don’t specify the value of an enum item, the item takes the value of theprevious item, plus 1. Enums are sometimes used to declare integer constants,in which case we normally omit the name of the enum:enum { FirstPort = 1024, MaxPorts = 32767};Another frequent use of enums is to represent sets of options. Let’s considerthe example of a Find dialog, with four checkboxes controlling the searchalgorithm (Wildcard syntax,Case sensitive,Search backward, andWrap around). Wecan represent this by an enum where the constants are powers of 2:enum FindOption { NoOptions = 0x00000000, WildcardSyntax = 0x00000001, CaseSensitive = 0x00000002, SearchBackward = 0x00000004, WrapAround = 0x00000008};Each option is often called a “flag”. We can combine flags using the bitwise|or|=operators:int options = NoOptions;if (wilcardSyntaxCheckBox->isChecked()) options |= WildcardSyntax;if (caseSensitiveCheckBox->isChecked()) options |= CaseSensitive;if (searchBackwardCheckBox->isChecked()) options |= SearchBackwardSyntax;if (wrapAroundCheckBox->isChecked()) options |= WrapAround;We can test whether a flag is set or not using the bitwise&operator:if (options & CaseSensitive) { // case-sensitive search}A variable of typeFindOptioncan only contain one flag at a time. The resultof combining several flags using|is a plain integer. Unfortunately, this is nottype-safe: The compiler won’t complain if a function expecting a combinationofFindOptions through anintparameter receivesSaturdayinstead. Qt usesQFlags<T>to provide type safety for its own flag types. The class is also avail-"},{"pageNumber":493,"pageContent":"Main Language Differences475able when we define custom flag types. See theQFlags<T>online documentationfor details.TypedefsC++lets us give an alias to a data type using thetypedefkeyword. For example,if we useQVector<Point2D>a lot and want to save a few keystrokes (or areunfortunate enough to be stuck with a Norwegian keyboard and have troublelocating the angle brackets), we can put this typedef declaration in one of ourheader files:typedef QVector<Point2D> PointVector;From then on, we can usePointVectoras a shorthand forQVector<Point2D>.Notice that the new name for the type appears after the old name. The typedefsyntax deliberately mimics that of variable declarations.In Qt, typedefs are used mainly for three reasons:•Convenience: Qt declaresuintandQWidgetListas typedefs forunsigned intandQList<QWidget *>to save a few keystrokes.•Platform differences: Certain types need different definitions on differentplatforms. For example,qlonglongis defined as__int64on Windows andaslong longon other platforms.•Compatibility: TheQIconSetclass from Qt 3 was renamedQIconin Qt 4. Tohelp Qt 3 users port their applications to Qt 4,QIconSetis provided as atypedef forQIconwhen Qt 3 compatibility is enabled.Type ConversionsC++provides several syntaxes for casting values from one type to another.The traditional syntax, inherited from C, involves putting the resulting type inparentheses before the value to convert:const double Pi = 3.14159265359;int x = (int)(Pi * 100);cout << x << \" equals 314\" << endl;This syntax is very powerful. It can be used to change the type of pointers, toremoveconst, and much more. For example:short j = 0x1234;if (*(char *)&j == 0x12) cout << \"The byte order is big-endian\" << endl;In the example above, we cast ashort *to achar *and we use the unary*op-erator to access the byte at the given memory location. On big-endian systems,that byte is0x12; on little-endian systems, that byte is0x34. Since pointers andreferences are represented the same way, it should come as no surprise that thecode above can be rewritten using a reference cast:"},{"pageNumber":494,"pageContent":"476B. Introduction to C++for Java and C# Programmersshort j = 0x1234;if ((char &)j == 0x12) cout << \"The byte order is big-endian\" << endl;If the data type is a class name, a typedef, or a primitive type that can beexpressed as a single alphanumeric token, we can use the constructor syntaxas a cast:int x = int(Pi * 100);Casting pointers and references using the traditional C-style casts is a kindof extreme sport, on par with paragliding and elevator surfing, because thecompiler lets us cast any pointer (or reference) type into any other pointer(or reference) type. For that reason, C++introduced four new-style casts withmore precise semantics. For pointers and references, the new-style casts arepreferable to the risky C-style casts and are used in this book.•static_cast<T>()can be used to cast a pointer-to-Ato a pointer-to-B, withthe constraint that classBmust inherit from classA. For example:A *obj = new B;B *b = static_cast<B *>(obj);b->someFunctionDeclaredInB();If the object isn’t an instance ofB(but still inherits fromA), using theresulting pointer can lead to obscure crashes.•dynamic_cast<T>()is similar tostatic_cast<T>(), except that it uses run-time type information (RTTI) to check that the object associated with thepointer is an instance of classB. If this is not the case, the cast returns anull pointer. For example:A *obj = new B;B *b = dynamic_cast<B *>(obj);if (b) b->someFunctionDeclaredInB();On some compilers,dynamic_cast<T>()doesn’t work across dynamic libraryboundaries. It also relies on the compiler supporting RTTI, a feature thatprogrammers can turn off to reduce the size of their executables. Qt solvesthese problems by providingqobject_cast<T>()forQObjectsubclasses.•const_cast<T>()adds or removes aconstqualifier to a pointer or reference.For example:int MyClass::someConstFunction() const{ if (isDirty()) { MyClass *that = const_cast<MyClass *>(this); that->recomputeInternalData(); } ...}"},{"pageNumber":495,"pageContent":"Main Language Differences477In the previous example, we cast away theconstqualifier of thethispoint-er to call the non-const member functionrecomputeInternalData(). Doingso is not recommended and can normally be avoided by using themutablekeyword, as explained in Chapter 4 (Implementing Application Function-ality).•reinterpret_cast<T>()converts any pointer or reference type to any othersuch type. For example:short j = 0x1234;if (reinterpret_cast<char &>(j) == 0x12) cout << \"The byte order is big-endian\" << endl;In Java and C#, any reference can be stored as anObjectreference if needed.C++doesn’t have any universal base class, but it provides a special data type,void *, that stores the address of an instance of any type. Avoid *must be castback to another type (usingstatic_cast<T>()) before it can be used.C++provides many ways of casting types, but most of the time we don’t evenneed a cast. When using container classes such asstd::vector<T>orQVector<T>,we can specify theTtype and extract items without casts. In addition, forprimitive types, certain conversions occur implicitly (for example, fromchartoint), and for custom types we can define implicit conversions by providing aone-parameter constructor. For example:class MyInteger{public: MyInteger(); MyInteger(int i); ...};int main(){ MyInteger n; n = 5; ...}For some one-parameter constructors, the automatic conversion makes lit-tle sense. We can disable it by declaring the constructor with theexplicitkeyword:class MyVector{public: explicit MyVector(int size); ...};"},{"pageNumber":496,"pageContent":"478B. Introduction to C++for Java and C# ProgrammersOperator OverloadingC++allows us to overload functions, meaning that we can declare several func-tions with the same name in the same scope, as long as they have different pa-rameter lists. In addition, C++supportsoperator overloading—the possibilityof assigning special semantics to built-in operators (such as+,<<, and[]) whenthey are used with custom types.We have already seen a few examples of overloaded operators. When we used<<to output text tocoutorcerr, we didn’t trigger C++’s left-shift operator, butrather a special version of the operator that takes anostreamobject (such ascoutandcerr) on the left and a string (alternatively, a number or a streammanipulator such asendl) on the right side and that returns theostreamobject,allowing multiple calls in a row.The beauty of operator overloading is that we can make custom types behavejust like built-in types. To show how operator overloading works, we willoverload+=,-=,+, and-to work onPoint2Dobjects:#ifndef POINT2D_H#define POINT2D_Hclass Point2D{public: Point2D(); Point2D(double x, double y); void setX(double x); void setY(double y); double x() const; double y() const; Point2D &operator+=(const Point2D &other) { xVal += other.xVal; yVal += other.yVal; return *this; } Point2D &operator-=(const Point2D &other) { xVal -= other.xVal; yVal -= other.yVal; return *this; }private: double xVal; double yVal;};inline Point2D operator+(const Point2D &a, const Point2D &b){ return Point2D(a.x() + b.x(), a.y() + b.y());}"},{"pageNumber":497,"pageContent":"Main Language Differences479inline Point2D operator-(const Point2D &a, const Point2D &b){ return Point2D(a.x() - b.x(), a.y() - b.y());}#endifOperators can be implemented either as member functions or as global func-tions. In our example, we implemented+=and-=as member functions,+and-as global functions.The+=and-=operators take a reference to anotherPoint2Dobject and incre-ment or decrement thexandycoordinates of the current object based on theother object. They return*this, which denotes a reference to the current object(thisis of typePoint2D *). Returning a reference allows us to write exotic codelikeqa += b += c;The+and-operators take two parameters and return aPoint2Dobject by value(not a reference to an existing object). Theinlinekeyword allows us to putthese function definitions in the header file. If the function’s body had beenlonger, we would put a function prototype in the header file and the functiondefinition (without theinlinekeyword) in a.cppfile.The following code snippets shows all four overloaded operators in action:Point2D alpha(12.5, 40.0);Point2D beta(77.5, 50.0);alpha += beta;beta -= alpha;Point2D gamma = alpha + beta;Point2D delta = beta - alpha;We can also invoke theoperatorfunctions just like any other functions:Point2D alpha(12.5, 40.0);Point2D beta(77.5, 50.0);alpha.operator+=(beta);beta.operator-=(alpha);Point2D gamma = operator+(alpha, beta);Point2D delta = operator-(beta, alpha);Operator overloading in C++is a complex topic, but we can go a long way with-out knowing all the details. It is still important to understand the fundamen-tals of operator overloading because several Qt classes (includingQStringandQVector<T>) use this feature to provide a simple and more natural syntax forsuch operations as concatenation and append."},{"pageNumber":498,"pageContent":"480B. Introduction to C++for Java and C# ProgrammersValue TypesJava and C# distinguish between value types and reference types.•Value types: These are primitive types such aschar,int, andfloat, as wellas C# structs. What characterizes them is that they aren’t created usingnewand the assignment operator performs a copy of the value held by thevariable. For example:int i = 5;int j = 10;i = j;•Reference types: These are classes such asInteger(in Java),String, andMyVeryOwnClass. Instances are created usingnew. The assignment operatorcopies only a reference to the object; to obtain a deep copy, we must callclone()(in Java) orClone()(in C#). For example:Integer i = new Integer(5);Integer j = new Integer(10);i = j.clone();In C++, all types can be used as “reference types”, and those that are copyablecan be used as “value types” as well. For example, C++doesn’t need anyIntegerclass, because we can use pointers andnewas follows:int *i = new int(5);int *j = new int(10);*i = *j;Unlike Java and C#, C++treats user-defined classes the same as built-in types:Point2D *i = new Point2D(5, 5);Point2D *j = new Point2D(10, 10);*i = *j;If we want to make a C++class copyable, we must ensure that our classhas a copy constructor and an assignment operator. The copy constructor isinvoked when we initialize an object with another object of the same type. C++provides two equivalent syntaxes for this:Point2D i(20, 20);Point2D j(i); // first syntaxPoint2D k = i; // second syntaxThe assignment operator is invoked when we use the assignment operator onan existing variable:Point2D i(5, 5);Point2D j(10, 10);j = i;"},{"pageNumber":499,"pageContent":"Main Language Differences481When we define a class, the C++compiler automatically provides a copyconstructor and an assignment operator that perform member-by-membercopy. For thePoint2Dclass, this is as if we had written the following code in theclass definition:class Point2D{public: ... Point2D(const Point2D &other) : xVal(other.xVal), yVal(other.yVal) { } Point2D &operator=(const Point2D &other) { xVal = other.xVal; yVal = other.yVal; return *this; } ...private: double xVal; double yVal;};For some classes, the default copy constructor and assignment operator areunsuitable. This typically occurs if the class uses dynamic memory. To makethe class copyable, we must then implement the copy constructor and theassignment operator ourselves.For classes that don’t need to be copyable, we can disable the copy constructorand assignment operator by making them private. If we accidentally attemptto copy instances of such a class, the compiler reports an error. For example:class BankAccount{public: ...private: BankAccount(const BankAccount &other); BankAccount &operator=(const BankAccount &other);};In Qt, many classes are designed to be used as value classes. These have a copyconstructor and an assignment operator, and are normally instantiated on thestack withoutnew. This is the case forQDateTime,QImage,QString, and containerclasses such asQList<T>,QVector<T>, andQMap<K,T>.Other classes fall in the “reference type” category, notablyQObjectand itssubclasses (QWidget,QTimer,QTcpSocket, etc.). These have virtual functionsand cannot be copied. For example, aQWidgetrepresents a specific window orcontrol on screen. If there are 75QWidgetinstances in memory, there are also 75windows or controls on screen. These classes are typically instantiated usingthenewoperator."},{"pageNumber":500,"pageContent":"482B. Introduction to C++for Java and C# ProgrammersGlobal Variables and FunctionsC++lets us declare functions and variables that don’t belong to any classes andthat are accessible from any other function. We have seen several examples ofglobal functions, includingmain(), the program’s entry point. Global variablesare rarer, because they compromise modularity and thread reentrancy. It isstill important to understand them because you might encounter them in codewritten by reformed C programmers and other C++users.To illustrate how global functions and variables work, we will study a smallprogram that prints a list of 128 pseudo-random numbers using a quick-and-dirty algorithm. The program’s source code is spread over two.cppfiles.The first source file israndom.cpp:int randomNumbers[128];static int seed = 42;static int nextRandomNumber(){ seed = 1009 + (seed * 2011); return seed;}void populateRandomArray(){ for (int i = 0; i < 128; ++i) randomNumbers[i] = nextRandomNumber();}The file declares two global variables (randomNumbersandseed) and two globalfunctions (nextRandomNumber()andpopulateRandomArray()). Two of the decla-rations contain thestatickeyword; these are visible only within the currentcompilation unit (random.cpp) and are said to havestatic linkage. The two otherscan be accessed from any compilation unit in the program; these haveexternallinkage.Static linkage is ideal for helper functions and internal variables that shouldnot be used in other compilation units. It reduces the risks of having collidingidentifiers (global variables with the same name or global functions with thesame signature in different compilation units) and prevents malicious or oth-erwise ill-advised users from accessing the internals of a compilation unit.Let’s now look at the second file,main.cpp, which uses the two global variablesdeclared with external linkage inrandom.cpp:#include <iostream>using namespace std;extern int randomNumbers[128];void populateRandomArray();"},{"pageNumber":501,"pageContent":"Main Language Differences483int main(){ populateRandomArray(); for (int i = 0; i < 128; ++i) cout << randomNumbers[i] << endl; return 0;}We declare the external variables and functions before we call them. The ex-ternal variable declaration (which makes an external variable visible in thecurrent compilation unit) forrandomNumbersstarts with theexternkeyword.Withoutextern, the compiler would think it has to deal with a variabledefini-tion, and the linker would complain because the same variable is defined in twocompilation units (random.cppandmain.cpp). Variables can be declared as manytimes as we want, but they may only be defined once. The definition is whatcauses the compiler to reserve space for the variable.ThepopulateRandomArray()function is declared using a function prototype. Theexternkeyword is optional for functions.Typically we would put the external variable and function declarations in aheader file and include it in all the files that need them:#ifndef RANDOM_H#define RANDOM_Hextern int randomNumbers[128];void populateRandomArray();#endifWe have already seen howstaticcan be used to declare member variables andfunctions that are not attached to a specific instance of the class, and now wehave seen how to use it to declare functions and variables with static linkage.There is one more use of thestatickeyword that should be noted in passing.In C++, we can declare a local variable static. Such variables are initializedthe first time the function is called and hold their value between functioninvocations. For example:void nextPrime(){ static int n = 1; do { ++n; } while (!isPrime(n)); return n;}Static local variables are similar to global variables, except that they are onlyvisible inside the function where they are defined."},{"pageNumber":502,"pageContent":"484B. Introduction to C++for Java and C# ProgrammersNamespacesNamespaces are a mechanism for reducing the risks of name clashes in C++programs. Name clashes are often an issue in large programs that use severalthird-party libraries. In your own programs, you can choose whether you wantto use namespaces or not.Typically, we put a namespace around all the declarations in a header file toensure that the identifiers declared in that header file don’t leak into the globalnamespace. For example:#ifndef SOFTWAREINC_RANDOM_H#define SOFTWAREINC_RANDOM_Hnamespace SoftwareInc{ extern int randomNumbers[128]; void populateRandomArray();}#endif(Notice that we have also renamed the preprocessor macro used to avoidmultiple inclusions, reducing the risk of a name clash with a header file of thesame name but located in a different directory.)The namespace syntax is similar to that of a class, but it doesn’t end with asemicolon. Here’s the newrandom.cppfile:#include \"random.h\"int SoftwareInc::randomNumbers[128];static int seed = 42;static int nextRandomNumber(){ seed = 1009 + (seed * 2011); return seed;}void SoftwareInc::populateRandomArray(){ for (int i = 0; i < 128; ++i) randomNumbers[i] = nextRandomNumber();}Unlike classes, namespaces can be “reopened” at any time. For example:namespace Alpha{ void alpha1(); void alpha2();}"},{"pageNumber":503,"pageContent":"Main Language Differences485namespace Beta{ void beta1();}namespace Alpha{ void alpha3();}This makes it possible to define hundreds of classes, located in as many headerfiles, as part of a single namespace. Using this trick, the Standard C++libraryputs all its identifiers in thestdnamespace. In Qt, namespaces are used forglobal-like identifiers such asQt::AlignBottomandQt::yellow. For historicalreasons, Qt classes do not belong to any namespace but are prefixed with theletter ‘Q’.To refer to an identifier declared in a namespace from outside the namespace,we prefix it with the name of the namespace (and::). Alternatively, we canuse one of the following three mechanisms, which are aimed at reducing thenumber of keystrokes we must type.•We can define a namespace alias:namespace ElPuebloDeLaReinaDeLosAngeles{ void beverlyHills(); void culverCity(); void malibu(); void santaMonica();}namespace LA = ElPuebloDeLaReinaDeLosAngeles;After the alias definition, the alias can be used instead of the originalname.q•We can import a single identifier from a namespace:int main(){ using ElPuebloDeLaReinaDeLosAngeles::beverlyHills; beverlyHills(); ...}Theusingdeclaration allows us to access a given identifier from a name-space without having to prefix it with the name of the namespace.•We can import an entire namespace with a single directive:int main(){ using namespace ElPuebloDeLaReinaDeLosAngeles;"},{"pageNumber":504,"pageContent":"486B. Introduction to C++for Java and C# Programmers santaMonica(); malibu(); ...}With this approach, name clashes are more likely to occur. If the compilercomplains about an ambiguous name (for example, two classes with thesame name defined in two different namespaces), we can always qualifythe identifier with the name of the namespace when referring to it.The PreprocessorThe C++preprocessor is a program that converts a.cppsource file containing#-directives (such as#include,#ifndef, and#endif) into a source file that con-tains no such directives. These directives perform simple textual operationson the source file, such as conditional compilation, file inclusion, and macro ex-pansion. Normally, the preprocessor is invoked automatically by the compiler,but most systems still offer a way of invoking it alone (often through a-Eor/Ecompiler option).• The#includedirective expands to the contents of the file specified withinangle brackets (<>) or double quotes (\"\"), depending on whether the headerfile is installed at a standard location or is part of the current project.The file name may contain..and/(which Windows compilers correctlyinterpret as a directory separator). For example:#include \"../shared/globaldefs.h\"• The#definedirective defines a macro. Occurrences of the macro appearingafter the#definedirective are replaced with the macro’s definition. Forexample, the directive#define PI 3.14159265359tells the preprocessor to replace all future occurrences of the tokenPIinthe current compilation unit with the token3.14159265359. To avoid clasheswith variable and class names, it is common practice to give macros all-uppercase names. It is possible to define macros that take arguments:#define SQUARE(x) ((x) * (x))In the macro body, it is good style to surround all occurrences of theparameters with parentheses, as well as the entire body, to avoid problemswith operator precedence. After all, we want7 * SQUARE(2 + 3)to expand to7 * ((2 + 3) * (2 + 3)), not to7 * 2 + 3 * 2 + 3.C++compilers normally allow us to define macros on the command line,using the-Dor/Doption. For example:CC -DPI=3.14159265359 -c main.cpp"},{"pageNumber":505,"pageContent":"Main Language Differences487Macros were very popular in the old days, before typedefs, enums, con-stants, inline functions, and templates were introduced. Nowadays, theirmost important role is to protect header files against multiple inclusions.• Macros can be undefined at any point using#undef:#undef PIThis is useful if we want to redefine a macro, since the preprocessor doesn’tlet us define the same macro twice. It is also useful to control conditionalcompilation.• Portions of code can be processed or skipped using#if,#elif,#else, and#endif, based on the numeric value of macros. For example:#define NO_OPTIM 0#define OPTIM_FOR_SPEED 1#define OPTIM_FOR_MEMORY 2#define OPTIMIZATION OPTIM_FOR_MEMORY...#if OPTIMIZATION == OPTIM_FOR_SPEEDtypedef int MyInt;#elif OPTIMIZATION == OPTIM_FOR_MEMORYtypedef short MyInt;#elsetypedef long long MyInt;#endifIn the example above, only the secondtypedefdeclaration would be pro-cessed by the compiler, resulting inMyIntbeing defined as a synonym forshort. By changing the definition of theOPTIMIZATIONmacro, we get differ-ent programs. If a macro isn’t defined, its value is taken to be 0.Another approach to conditional compilation is to test whether a macrois defined or not. This can be done using the using thedefined()operatoras follows:#define OPTIM_FOR_MEMORY...#if defined(OPTIM_FOR_SPEED)typedef int MyInt;#elif defined(OPTIM_FOR_MEMORY)typedef short MyInt;#elsetypedef long long MyInt;#endif• For convenience, the preprocessor recognizes#ifdef Xand#ifndef Xassynonyms for#if defined(X)and#if !defined(X). To protect a header"},{"pageNumber":506,"pageContent":"488B. Introduction to C++for Java and C# Programmersfile against multiple inclusions, we wrap its contents with the followingidiom:#ifndef MYHEADERFILE_H#define MYHEADERFILE_H...#endifThe first time the header file is included, the symbolMYHEADERFILE_His notdefined, so the compiler processes the code between#ifndefand#endif. Thesecond and any subsequent times the header file is included,MYHEADERFILE_His defined, so the entire#ifndef...#endifblock is skipped.• The#errordirective emits a user-defined error message at compile time.This is often used in conjunction with conditional compilation to report animpossible case. For example:class UniChar{public:#if BYTE_ORDER == BIG_ENDIAN uchar row; uchar cell;#elif BYTE_ORDER == LITTLE_ENDIAN uchar cell; uchar row;#else#error \"BYTE_ORDER must be BIG_ENDIAN or LITTLE_ENDIAN\"#endif};Unlike most other C++constructs, where whitespace is irrelevant, preprocessordirectives stand alone on a line and require no semicolon. Very long directivescan be split across multiple lines by ending every line except the last with abackslash.The Standard C++LibraryIn this section, we will briefly review the Standard C++library. Figure B.3 liststhe core C++header files. The<exception>,<limits>,<new>, and<typeinfo>head-ers support the C++language; for example,<limits>allows us to test propertiesof the compiler’s integer and floating-point arithmetic support, and<typeinfo>offers basic introspection. The other headers provide generally useful classes,including a string class and a complex numeric type. The functionality offeredby<bitset>,<locale>,<string>, and<typeinfo>loosely overlaps with theQBitAr-ray,QLocale,QString, andQMetaObjectclasses in Qt.Standard C++also includes a set of header files that deal with I/O, listed inFigure B.4. The standard I/O classes’ design harks back to the 1980s and isneedlessly complex, making them very hard to extend—so difficult, in fact,"},{"pageNumber":507,"pageContent":"The Standard C++Library489that entire books have been written on the subject. It also leaves the program-mer with a Pandora’s box of unresolved issues related to character encodingsand platform-dependent binary representations of primitive data types.Header fileDescription<bitset>Template class for representing fixed-length bit sequences<complex>Template class for representing complex numbers<exception>Types and functions related to exception handling<limits>Template class that specifies properties of numeric types<locale>Classes and functions related to localization<new>Functions that manage dynamic memory allocation<stdexcept>Predefined types of exceptions for reporting errors<string>Template string container and character traits<typeinfo>Class that provides basic meta-information about a type<valarray>Template classes for representing value arraysFigure B.3.Core C++library header filesChapter 12 (Input/Output) presents the corresponding Qt classes, whichfeature Unicode I/O as well as a large set of national character encodings anda platform-independent abstraction for storing binary data. Qt’s I/O classesform the basis of Qt’s inter-process communication, networking, and XMLsupport. Qt’s binary and text stream classes are very easy to extend to handlecustom data types.Header fileDescription<fstream>Template classes that manipulate external files<iomanip>I/O stream manipulators that take an argument<ios>Template base class for I/O streams<iosfwd>Forward declarations for several I/O stream template classes<iostream>Standard I/O streams (cin,cout,cerr,clog)<istream>Template class that controls input from a stream buffer<ostream>Template class that controls output to a stream buffer<sstream>Template classes that associate stream buffers with strings<streambuf>Template classes that buffer I/O operations<strstream>Classes for performing I/O stream operations on character arraysFigure B.4.C++I/O library header filesThe early 1990s saw the introduction of the Standard Template Library(STL), a set of template-based container classes, iterators, and algorithms that"},{"pageNumber":508,"pageContent":"490B. Introduction to C++for Java and C# Programmersslipped into the ISO C++standard at the eleventh hour. Figure B.5 lists theheader files that form the STL. The STL has a very clean, almost mathematicaldesign that provides generic type-safe functionality. Qt provides its own con-tainer classes, whose design is partly inspired by STL. These are described inChapter 11.Header fileDescription<algorithm>General-purpose template functions<deque>Double-ended queue template container<functional>Templates that help construct and manipulate functors<iterator>Templates that help construct and manipulate iterators<list>Doubly-linked list template container<map>Single-valued and multi-valued map template containers<memory>Utilities for simplifying memory management<numeric>Template numeric operations<queue>Queue template container<set>Single-valued and multi-valued set template containers<stack>Stack template container<utility>Basic template functions<vector>Vector template containerFigure B.5.STL header filesSince C++is essentially a superset of the C programming language, C++pro-grammers also have the entire C library at their disposal. The C header filesare available either with their traditional names (for example,<stdio.h>) orwith new-style names with ac- prefix and no.h(for example,<cstdio>). Whenwe use the new-style version, the functions and data types are declared in thestdnamespace. (This doesn’t apply to macros such asASSERT(), because the pre-processor is unaware of namespaces.) The new-style syntax is recommendedif your compiler supports it.Figure B.6 lists the C library header files. Most of these offer functionalitythat overlaps with more recent C++headers or with Qt. One notable exceptionis<cmath>, which declares mathematical functions such assin(),sqrt(), andpow().This completes our quick overview of the Standard C++library. On the Inter-net, Dinkumware offers complete reference documentation for the StandardC++library athttp://www.dinkumware.com/refxcpp.html, and SGI has a compre-hensive STL programmer’s guide athttp://www.sgi.com/tech/stl/. The officialdefinition of the Standard C++library is found in the C and C++standards,available as PDF files or paper copies from the International Organization forStandardization (ISO)."},{"pageNumber":509,"pageContent":"The Standard C++Library491Header fileDescription<cassert>TheASSERT()macro<cctype>Functions for classifying and mapping characters<cerrno>Macros related to error condition reporting<cfloat>Macros that specify properties of primitive floating-point types<ciso646>Alternative spellings for ISO 646 charset users<climits>Macros that specify properties of primitive integer types<clocale>Functions and types related to localization<cmath>Mathematical functions and constants<csetjmp>Functions for performing non-local jumps<csignal>Functions for handling system signals<cstdarg>Macros for implementing variable argument list functions<cstddef>Common definitions for several standard headers<cstdio>Functions for performing I/O<cstdlib>General utility functions<cstring>Functions for manipulatingchararrays<ctime>Types and functions for manipulating time<cwchar>Extended multibyte and wide character utilities<cwctype>Functions for classifying and mapping wide charactersFigure B.6.C++header files for C library facilitiesIn this appendix, we have covered a lot of ground at a fast pace. When you startlearning Qt from Chapter 1, you should find that the syntax is a lot simpler andclearer than this appendix might have suggested. Good Qt programming onlyrequires the use of a subset of C++and usually avoids the need for the morecomplex and obscure syntax that C++makes possible. Once you start typing incode and building and running executables, the clarity and simplicity of the Qtapproach will become apparent. And as soon as you start writing more ambi-tious programs, especially those that need fast and fancy graphics, the C++/Qtcombination will continue to keep pace with your needs."},{"pageNumber":511,"pageContent":"Index%(percent sign), 59,265–266&(ampersand), 16&unary operator, 464->operator, 464,466.(dot) operator, 460,464,466/(slash), 67,286:/(colon slash), 48,287,355::operator, 454,460,462,485<<operator, 81,252,266,271,274,275–277,280,454,478<>(angle brackets), 253,471,475>>operator, 81,271,275–277,280,456\\(backslash), 286,488(euro symbol), 362,369AABItem, 430about()MainWindow, 66QMessageBox, 66aboutQt()(QApplication), 50absolute positioning, 138accelerator keys, 48See alsoshortcut keysaccept()QDialog, 28,33,63QEvent, 58,157,159,209,384acceptProposedAction()(QDropEvent), 206Acceptable(QValidator), 102Accepted(QDialog), 28,63acquire()(QSemaphore), 387,388actions, 48–50,156,393activateWindow()(QWidget), 61–62,86activeEditor()(MainWindow), 155ActiveQt, 357,419–431active window, 62,110,154,155activeWindow()(QWorkspace), 155ActiveX, 419–431-activexoption (ActiveX servers), 430addAction()(QWidget), 50,51,52addArtist()(ArtistForm), 302addBindValue()(QSqlQuery), 296addCd()(MainForm), 307addChildSettings()(SettingsViewer), 224addDatabase()(QSqlDatabase), 294,297addItem()(QComboBox), 35,229addLayout()(QBoxLayout), 16addLibraryPath()(QCoreApplication), 408addMenu()QMenu, 51QMenuBar, 50AddRef()(IUnknown), 426addRow()(CoordinateSetter), 222addSeparator()QMenu, 50QMenuBar, 51QToolBar, 52addStretch()(QLayout), 141addTrack()(MainForm), 308addTransaction()ImageWindow, 393TransactionThread, 394addWidget()QBoxLayout, 16QGridLayout, 141QSplitter, 145QStackedLayout, 144QStatusBar, 53AddressBook, 428–429Address Book example, 428–431adjust()(PlotSettings), 132adjustAxis()(PlotSettings), 132adjustSize()(QWidget), 121adjusted()(QRect), 124Age example, 7–9,11<algorithm>header, 263,490algorithms, 88,251,263–265,271,489aliasing.SeeantialiasingAlignAccountingStyle(QTextStream), 281AlignCenter(QTextStream), 281AlignHCenter(Qt), 54AlignLeft(QTextStream), 281AlignRight(QTextStream), 281alignment, 54,94,131,233,281allTransactionsDone()(ImageWindow), 393allocated memory.Seenewoperatoralpha channel, 106,189,190Altkey, 16,164ampersand (&), 16angle brackets (<>), 253,471,475493"},{"pageNumber":512,"pageContent":"494Indexangles, 129,178,180,182animations, 165antialiasing, 178,181,188,189,413Any(QHostAddress), 332AnyKeyPressed(QAbstractItemView), 220append()QLinkedList<T>, 253QString, 265QTextEdit, 290QVector<T>, 252appendChild()(QDomNode), 349Apple Help, 357Apple Roman, 365Application, 433–434application settings, 67–68,148,152,223apply()(Transaction), 395applyEffect()(BasicEffectsPlugin), 412Arabic, 362arcs, 176arg()(QString), 59,246,265–266,367ARGB format, 106,189,405argcandargvparameters, 3,160,434,453arguments()(QCoreApplication), 160,312ARM, 439arrays, 252,253,468–472ArtistFormclass definition, 301ArtistForm(), 302addArtist(), 302beforeInsertArtist(), 303deleteArtist(), 303ASCII, 265,280,296,362–365,368aspect ratio, 186assembly language, 259,397assignment operators, 253,254,261,480–481Assistant.See Qt Assistantassociative containers, 260–263asynchronous I/O, 287,290,311,320,325at()(container classes), 258atomicity, 259,382,397ATSFontFormatRef(Mac OS X), 418attributeswidgets, 70XML, 342,347auto-generated fields, 303autoRecalculate()(Spreadsheet), 75automatic connections, 28,288AxBouncerclass definition, 423AxBouncer(continued)AxBouncer(), 425createAggregate(), 426setColor(), 425setRadius(), 426setSpeed(), 426start(), 426stop(), 426Bbackground, 109,120,129,180BackgroundColorRole(Qt), 230,244backslash (\\), 286,488Backtabkey, 164BankAccount, 481basekeyword (C#), 462base 2, 281base 8, 281base 16, 103,281BasicEffectsPlugin, 412–413Basic Effects Plugin example, 412–414BDF, 442BDiagPattern(Qt), 177beep()(QApplication), 86beforeInsert()(QSqlTableModel), 303,306,307beforeInsertArtist()(ArtistForm), 303beforeInsertCd()(MainForm), 307beforeInsertTrack()(MainForm), 309begin()(container classes), 234,256–257,258,263beginGroup()(QSettings), 67Bengali, 362BevelJoin(Qt), 177Bézier curves, 176,178Big5, 365big-endian, 81,275,363,457,475binary I/O (compression), 80–82,274–278,279,323binary numbers, 281binary search, 263bind()(QUdpSocket), 337bindValue()(QSqlQuery), 296bit arrays, 271bit depth.Seecolor depthbitmaps, 180See alsopixmapsBLOBs, 297block-oriented protocols, 323,332blocking I/O, 290BMP, 46"},{"pageNumber":513,"pageContent":"Index495Bouncer example, 423–428boundingRect()(QPainter), 195box layouts, 9,25,140brushes, 110,176BSTR(Windows), 421bubble help.Seetooltipsbuddies, 16,25building applications, 4,454built-in dialogs, 39–40built-in widgets, 37–39,73,104bus error, 464busy cursor, 81busy indicators, 325button()(QMouseEvent), 111,201,208buttonscheckboxes, 37mouse, 111,201,208,215push, 5,37radio, 37tool, 37buttons()(QMouseEvent), 111,201,208byte arrays, 269byte order, 81,275,363,404,457,475bytes, 473bytesAvailable()(QAbstractSocket), 331CC#, 451C++library, 488–490C++-style casts, 60,476–477C-style casts, 475–476caches, 262,391canConvert<T>()(QVariant), 270canRead()(CursorHandler), 402canReadLine()(QIODevice), 333cancel()(QSessionManager), 435cap styles, 177capabilities()(CursorPlugin), 401captions.Seetitle barsCarbon, 415,416carriage return, 279,285Cartesian coordinate system, 109cascade()(QWorkspace), 156case sensitivity, 264,267,363casts, 475–477<cctype>header, 363,491cd()(QFtp), 314,317CD Collection example, 299–310CDE style, 11,124Cellclass definition, 91Cell(continued)inheritance tree, 74Cell(), 92clone(), 92data(), 93evalExpression(), 96evalFactor(), 97evalTerm(), 97formula(), 93setData(), 93setDirty(), 93setFormula(), 93value(), 94cell()(Spreadsheet), 78central widget, 46–47,73–74,147,153cerr(std), 274,288,290,453CGImageRef(Mac OS X), 418CGI scripts, 322changeEvent()(QWidget), 375,376char, 363,365,368,457,473chartypes, 471character encodings, 214,279,280,349,362–365character strings, 265–269,471–473characters()(SaxHandler), 342Chart example, 248checkable actions, 49checkable buttons.Seetoggle buttonscheckboxes, 37checkmarks, 49child dialogs, 56child layouts, 17,140–141child objects, 28,396child processes, 287child widgets, 7,121,153Chinese, 362,365,369chords, 176cin(std), 274,284Circle, 461,462circles.Seeellipsescircular buffer, 387Cities example, 234–238CityModelclass definition, 235usage, 235CityModel(), 236columnCount(), 236data(), 236flags(), 237headerData(), 236offsetOf(), 238rowCount(), 236setCities(), 238"},{"pageNumber":514,"pageContent":"496IndexCityModel(continued)setData(), 237class definitions (C++), 458–463class documentation, 9–11,490Clear(composition mode), 190clear()container classes, 240,264QTableWidget, 77QTranslator, 374Spreadsheet, 77clearBoard()(TicTacToe), 436clearCurve()(Plotter), 122clicked()(QAbstractButton), 6,163,288client–server applications, 323–332ClientSocketclass definition, 330ClientSocket(), 330generateRandomTrip(), 332readClient(), 331clients (Qtopia Core), 440clip region, 131,180clipboard()(QApplication), 83,215clipboard operations, 83–85,154,215clone()(Cell), 92close()QFtp, 313,314QHttp, 321QIODevice, 291,328,331QWidget, 16,58closeActiveWindow()(QWorkspace), 156closeAllWindows()QApplication, 70QWorkspace, 156closeConnection()(TripPlanner), 328closeEditor()(QAbstractItemDelegate),247closeEvent()Editor, 159MainWindow, 57,157ThreadDialog, 384<cmath>header, 119,491CodeEditor, 164codecForLocale()(QTextCodec), 363codecForName()(QTextCodec), 364–365CODECFORTRentry (.profiles), 377codecs, 280,349,363–365,378collection classes.Seecontainer classescolon slash (:/), 48,287,355colorData()(QMimeData), 214color depth, 106color dialog, 39ColorGroup (QPalette), 110colorNames()(QColor), 229ColorNamesDialog, 229Color Names example, 228–230color stops, 179See alsoQGLColormapcolors, 5,39,105,106,110column()(QModelIndex), 231,233ColumnCount(Spreadsheet), 76,77columnCount()CityModel, 236CurrencyModel, 233RegExpModel, 242COM, 419–431comboboxes, 39,229,305comma-separated values (CSV), 212commandFinished()(QFtp), 314command-line optionsActiveX servers, 430configure, 46Qt applications, 3,11,160,453Qtopia applications, 441,442commandStarted()(QFtp), 314commercial editions of Qt, 447–448commit()(QSqlDatabase), 296commitAndCloseEditor()(TrackDelegate),247commitData()QAbstractItemDelegate, 247QApplication, 432,434common dialogs, 39–40compilation units, 452–453,482compiler, 454compiling applications, 4,454composition modes, 189–190compressionbinary data, 279events, 108conditional compilation, 487–488CONFIGentry (.profiles), 36,356,408,423,428,431configuration data.Seesettingsconfigure, 440–442configuring Qt, 46conical gradients, 180,187connect()(QObject), 6,8,16,20–22,391,396connectToHost()QAbstractSocket, 325QFtp, 313,314,316connectToServer()(TripPlanner), 325connected()(QAbstractSocket), 325connecting to a database, 294,296–297connectionClosedByServer()(TripPlanner), 329connection mode (Qt Designer), 32–34"},{"pageNumber":515,"pageContent":"Index497console applications, 284,285,291,311constBegin()(container classes), 258const_cast<T>(), 476constData()(QByteArray), 269constEnd()(container classes), 258const iterators, 256,257,258constkeyword, 458,465–466,469,475,476constructorsC++syntax, 458copy, 253,254,261,270,480–481default, 252,261,270,458,460QObjectsubclasses, 14consumer–producer model, 387–390container classesalgorithms, 263–265as return values, 256,257bit arrays, 271byte arrays, 269caches, 262foreachloop, 258–260hashes, 261–262implicit sharing, 257,259,397,439,471Java-style iterators, 254–256,262linked lists, 252–253lists, 253maps, 260–261nesting, 253pairs, 271Qt vs. STL, 251,257–258,489queues, 253sets, 262stacks, 253STL-style iterators, 256,262strings, 265–269variable-length arrays, 271variants, 60,105,269–271,295,422vectors, 252,471container widgets, 4,37contains()QMap<K,T>, 261QRect, 112,125QString, 86contentsChanged()(QTextDocument), 158,160contextMenuEvent()(QWidget), 52context menus, 51–52,152ContiguousSelection(QAbstractItemView),76,84,212controllers (MVC), 217controllingUnknown()(QAxAggregated),426controls.Seewidgetsconvenience item view subclasses,218–224convert(ImageMagick), 287ConvertDepthTransaction, 395ConvertDialogclass definition, 288ConvertDialog(), 288on_browseButton_clicked(), 288,289on_convertButton_clicked(), 288,289processError(), 290processFinished(), 290updateOutputTextEdit(), 290convertSeparators()(QDir), 286convertToFormat()(QImage), 107CoordinateSetter, 221–222Coordinate Setter example, 221–222coordinate systemof a painter, 109,180–182of a widget, 109,112,127copy()QTextEdit, 215Spreadsheet, 83CopyAction(Qt), 209copyAvailable()(QTextEdit), 154copy constructors, 253,254,261,270,480–481copy on write.Seeimplicit sharingCore Foundation, 67count()(container classes), 252cout(std), 274,284,453.cppfiles, 452–453create()CursorPlugin, 401IconEditorPlugin, 115createAction()(QWhatsThis), 353createActions()(MainWindow), 48,70,373createAggregate()(AxBouncer), 426createConnection(), 294createContextMenu()(MainWindow), 51createDirectory()(DirectoryViewer), 228createEditor()MainWindow, 154TrackDelegate, 247createElement()(QDomDocument), 348createIndex()(QAbstractItemModel), 237createLanguageMenu()(MainWindow), 374createMenus()(MainWindow), 50,156,373createStatusBar()(MainWindow), 53createTextNode()(QDomDocument), 348createToolBars()(MainWindow), 52critical()(QMessageBox), 55CRLF.Seeline-ending conventionsCrossPattern(Qt), 177"},{"pageNumber":516,"pageContent":"498Index<cstdlib>header, 455,491CSV, 212Ctrlkey, 111,164.curfiles, 400,403–407Currencies example, 231–234currenctRowChanged()(QItemSelectionModel), 306currencyAt()(CurrencyModel), 234CurrencyModelclass definition, 232usage, 231–232CurrencyModel(), 232columnCount(), 233currencyAt(), 234data(), 233headerData(), 234rowCount(), 233setCurrencyMap(), 234currentCdChanged()(MainForm), 306currentDateTime()(QDateTime), 185currentFormula()(Spreadsheet), 80currentImageNumber()(CursorHandler),403currentIndex()(QComboBox), 64–65currentLocation()(Spreadsheet), 79currentPath()(QDir), 286currentRowChanged()(QListWidget), 36,144–145currentThread()(QThread), 390cursor (mouse), 81,126,127Cursor(X11), 418CursorHandlerclass definition, 402CursorHandler(), 402canRead(), 402currentImageNumber(), 403enterErrorState(), 407imageCount(), 403jumpToNextImage(), 406read(), 404readBitmap(), 407readHeaderIfNecessary(), 406CursorPluginclass definition, 400capabilities(), 401create(), 401keys(), 401Cursor Plugin example, 400–408custom ActiveX controls, 423custom delegates, 244–249,306custom dialogs, 13–20,23–29custom models, 230–244custom properties, 105custom styles, 124custom views, 248custom widgets, 73,101–134cut()MainWindow, 155QTextEdit, 215Spreadsheet, 83CY(Windows), 421cyclic connections, 8,22DDashDotDotLine(Qt), 177DashDotLine(Qt), 177DashLine(Qt), 177data()Cell, 93CityModel, 236CurrencyModel, 233QAbstractItemModel, 233,236,242,244QByteArray, 269QDomText, 347QMimeData, 210,214QTableWidgetItem, 91,93,220RegExpModel, 242dataChanged()QAbstractItemModel, 237,306QClipboard, 215data compression, 279data-entry widgets, 39data structures.Seecontainer classesdatabase()(QSqlDatabase), 297databasesbuilt-in drivers, 293,447connecting to, 294,296–297navigating result sets, 295,297transactions, 296value binding, 295–296date, 185DATE(Windows), 421date/time editors, 39,370DB2 (IBM), 293.dcffiles, 357debug mode, 21,408declaration vs. definition, 483decorations, 442deep copy, 258,259,480.deffiles, 428Default(QMessageBox), 55default buttons, 16,24,55default constructors, 252,261,270,458,460default database connection, 297"},{"pageNumber":517,"pageContent":"Index499deferred delete events, 397#definedirective, 14,455,486defined()operator, 487DEFINESentry (.profiles), 368definition vs. declaration, 483degrees, 129,178del()Spreadsheet, 85TeamLeadersDialog, 226delegates, 217,218,244,249,305–306deleteoperator, 4,28,63,68–70,85,240,264,465delete []operator, 470deleteArtist()(ArtistForm), 303deleteCd()(MainForm), 307deleteLater()(QObject), 331,397deleteTrack()(MainForm), 309delta()(QWheelEvent), 129Dense[1-7]PatternQt, 177dequeue()(QQueue<T>), 253deriving.SeesubclassingDesigner.See Qt DesignerDESTDIRentry (.profiles), 408Destination(composition mode), 190DestinationAtop(composition mode),190DestinationIn(composition mode), 190DestinationOut(composition mode), 190DestinationOver(composition mode),190destructors, 18,395,409,463Devanagari, 362device coordinates, 180–182Dhivehi, 362DiagCrossPattern(Qt), 177dialogsbuilt-in, 39–40creating in code, 14–15creating usingQt Designer, 23–29,29–35group leader, 355invoking, 61–66meaning of parent, 56modality, 61–63,355passing data to and from, 65–66title bar, 56dials, 39dictionaries.Seehashesdirectories, 285–286,317DirectoryViewer, 227–228Directory Viewer example, 227–228disabled actions, 156disabled widgets, 16,110,170discard command, 433disconnect()(QObject), 21,22,396disconnected()(QAbstractSocket), 325,329,330,331display context (OpenGL), 199-displayoption (Qtopia applications),441,442DisplayRole(Qt), 92,93–94,220,230,233,243division by zero, 97,108DLLs, 399,456DNS.SeeQHostInfodock areas, 46,150–151dock widgets, 47,150–152document()(QTextEdit), 158documentElement()(QDomDocument), 346documentTitle()(QTextBrowser), 355documentation, 9–11,353–357,490DOM, 339,344–349DomParser, 345–348DOM Parser example, 345–348done()FlowChartSymbolPicker, 220FtpGet, 312,314QDialog, 220,222QFtp, 313,314,315QHttp, 320Spider, 317DontConfirmOverwrite(QFileDialog), 57DotLine(Qt), 177double-click, 201,225DoubleClicked(QAbstractItemView), 225drag and dropaccepting drops, 205–207,209–210originating drags, 207–209start distance, 208dragEnterEvent()ProjectListWidget, 209QWidget, 206,209dragLeaveEvent()(QWidget), 207dragMoveEvent()ProjectListWidget, 209QWidget, 207,209draw()Circle, 462LabeledCircle, 462OvenTimer, 186Shape, 461,462Tetrahedron, 200drawArc()(QPainter), 176drawChord()(QPainter), 176drawCubicBezier()(QPainter), 176drawCurves()(Plotter), 131"},{"pageNumber":518,"pageContent":"500IndexdrawDisplay()(QItemDelegate), 247drawEllipse()(QPainter), 176,178,186–187drawFocus()(QItemDelegate), 247drawGrid()(Plotter), 130drawLine()(QPainter), 109,176,187drawLines()(QPainter), 176drawPath()(QPainter), 176,414drawPie()(QPainter), 176,178drawPixmap()(QPainter), 123,176drawPoint()(QPainter), 176drawPoints()(QPainter), 176drawPolygon()(QPainter), 176,186drawPolyline()(QPainter), 132,176drawPrimitive()QStyle, 124QStylePainter, 124drawRect()(QPainter), 176,181drawRoundRect()(QPainter), 176,187drawText()(QPainter), 130–131,167,176,182,187drill-down, 309driver()(QSqlDatabase), 296driversdatabase, 293,447keyboard, 441,442mouse, 441,442printer, 191screen, 442dropEvent()MyTableWidget, 212ProjectListWidget, 210QWidget, 206,210,212dumpdoc, 421-dumpidloption (ActiveX servers), 430duration()(OvenTimer), 185dynamicCall()(QAxBase), 423dynamic_cast<T>(), 60,476dynamic dialogs, 36See alsoshape-changing dialogsdynamic libraries, 60,399,456,476dynamic memory.Seenewoperatordynamic menus, 59–60,156Eedit()(ExternalEditor), 290editArtists()(MainForm), 309Editmenus, 83–87EditRole(Qt), 92,93–94,220,230,237edit triggers, 220,222,226editingFinished()(QAbstractSpinBox),247editions of Qt, 447–448Editorclass definition, 157Editor(), 158closeEvent(), 159newFile(), 158okToContinue(), 159open(), 159save(), 159setCurrentFile(), 159sizeHint(), 160windowMenuAction(), 157editor widgets, 39effects()(BasicEffectsPlugin), 412#elifdirective, 487ellipses, 176,178#elsedirective, 487embedded Linux, 439–443-embeddedoption (configure), 440embedded resources.Seeresource filesemitpseudo-keyword, 18Employee, 21–22emulated look and feel, 11,124enabled widgets.Seedisabled widgetsencodings, 214,279,280,349,362–365end()(container classes), 256–257,258,263endDocument()(QXmlContentHandler), 340endElement()(SaxHandler), 343endGroup()(QSettings), 67endian, 81,275,363,457,475#endifdirective, 15,455,487endl(std), 454endsWith()(QString), 267enqueue()(QQueue<T>), 253enterErrorState()(CursorHandler), 407Enterkey, 247entryHeight()(PrintWindow), 194entryInfoList()(QDir), 286entryList()(QDir), 285enumkeyword, 469,473–474environment variablesPATH, 4,357,434,450QTDIR, 116,408QWS_DEPTH, 441QWS_KEYBOARD, 441,442QWS_MOUSE_PROTO, 441,442QWS_SIZE, 441erase color, 120,129error()QAbstractSocket, 325"},{"pageNumber":519,"pageContent":"Index501error()(continued)QFile, 279QProcess, 288TripPlanner, 329error dialog, 40–41#errordirective, 488errorString()QFile, 80,82QXmlErrorHandler, 342Esckey, 55,247Escape(QMessageBox), 55escape()(Qt), 193,211,212,349EUC-JP, 365EUC-KR, 365euro symbol (), 362,369evalExpression()(Cell), 96evalFactor()(Cell), 97evalTerm()(Cell), 97event()(QObject), 164,170eventFilter()(QObject), 169,170event loop, 4,171,311,314,320,391,397EventRef(Mac OS X), 418events, 4close, 44,57,157,159,384,435compared with signals, 163compression, 108context menu, 52deferred delete, 397drag enter, 206,209drag leave, 207drag move, 207drop, 206,210filtering, 168–171,419handling, 108,164–168,170,419hide, 168key, 164–165key press, 128,164,169key release, 164language change, 376layout direction change, 170locale change, 375mouse double-click, 201mouse move, 111,126,201,208mouse press, 111,125,185,201,208mouse release, 126,215paint, 108,123,167,185,416,417pending, 173platform-specific, 419propagation, 165,171,206resize, 124–125,139show, 167timer, 165–168,168,173,422events (continued)wheel, 128examplesAddress Book, 428–431Age, 7–9,11Basic Effects Plugin, 412–414Bouncer, 423–428CD Collection, 299–310Cities, 234–238Color Names, 228–230Coordinate Setter, 221–222Currencies, 231–234Cursor Plugin, 400–408Directory Viewer, 227–228DOM Parser, 345–348Find, 13–20,61Find File, 137–140Flow Chart Symbol Picker, 219–220ftpget, 311–315Go-to-Cell, 23–29,62Hello, 3–5Hex Spin Box, 101–103,113httpget, 320–322Icon Editor, 104–112Icon Editor Plugin, 113–116Image Converter, 287–290Image Pro, 392–396imagespace, 285–286Mail Client, 146–148MDI Editor, 153–160Media Player, 419–423Oven Timer, 183–188Plotter, 116–133Preferences, 144Project Chooser, 207–210Quit, 6Regexp Parser, 238–244SAX Handler, 340–344semaphores, 387–389Settings Viewer, 222–224Sort, 29–35,63spider, 315–320Splitter, 145–146Spreadsheet, 43–72,73–99Team Leaders, 225–226Tetrahedron, 199–203Text Art, 408–411Threads, 381–384Tic-Tac-Toe, 432–437Ticker, 165–168tidy, 283–284Track Editor, 244–248Trip Planner, 323–329"},{"pageNumber":520,"pageContent":"502Indexexamples (continued)Trip Server, 323,329–332waitconditions, 389–390Weather Balloon, 333–335Weather Station, 333,335–337exceptions, 95,456,488–489ExcludeUserInput(QEventLoop), 172exclusive actions, 49exec()QCoreApplication, 3,171–172,391QDialog, 62QMenu, 52QSqlQuery, 294QThread, 397execute()(QProcess), 291exists()QDir, 286QFile, 286expand()(QTreeView), 227Expanding(QSizePolicy), 120,142–143explicitkeyword, 477exportingActiveX controls, 425,427,429,431plugins, 115–116,402,414Extensible Markup Language.SeeXMLextension dialogs, 29–35externkeyword, 483ExternalEditor, 290external linkage, 482external programs, 287FF2key, 228,305faceAtPosition()(Tetrahedron), 202fatalError()(SaxHandler), 343FDiagPattern(Qt), 177file dialog, 40,56Filemenus, 50,54–61,69fileName()(QFileInfo), 58filesattributes, 285binary I/O, 80–82,274–278,323directory separator, 286encodings, 363–364image formats, 46name filters, 56,285reading and writing XML, 339–349recently opened, 50,59–60text I/O, 279–285,363–364traversing directories, 285–286files (continued)uploading and downloading, 311–323fill()(QPixmap), 129fill patterns, 176fillRect()(QPainter), 110filter model, 228filtersfor events, 168–171,419for file names, 56,285finalkeyword (Java), 466finalize()(Java), 463find()MainWindow, 61QWidget, 415Find example, 13–20,61findChild<T>()(QObject), 36findClicked()(FindDialog), 18FindDialogclass definition, 14–15usage, 61,62FindDialog(), 15–17findClicked(), 18findNext(), 14findPrevious(), 14FindFileDialog, 137–140Find File example, 137–140findNext()FindDialog, 14Spreadsheet, 86findPrevious()FindDialog, 14Spreadsheet, 86finished()QProcess, 288QThread, 395first()(QSqlQuery), 295firstChild()(QDomNode), 348Fixed(QSizePolicy), 142FixedNotation(QTextStream), 281fixed size, 17,143flags()(CityModel), 237FlatCap(Qt), 177flicker, 4,108flipHorizontally()(ImageWindow), 393FlipTransaction, 395–396FlowChartSymbolPickerclass definition, 219FlowChartSymbolPicker(), 219done(), 220selectedId(), 219Flow Chart Symbol Picker example,219–220focus, 16,25,120,124,164,171,247"},{"pageNumber":521,"pageContent":"Index503focusNextChild()(QWidget), 169,170focus policies, 120focus rectangle, 124,247folders.SeedirectoriesFont(X11), 418font dialog, 39fontMetrics()(QWidget), 160,167FontRole(Qt), 230,244fonts, 39,140,167,176,362,413,442ForcePoint(QTextStream), 281ForceSign(QTextStream), 281foreachpseudo-keyword, 71,258–260,263foreground()(QPalette), 110foreign keys, 296,300,305foreverpseudo-keyword, 328form designer.See Qt Designerformats()QMimeData, 210,213TableMimeData, 213formula()Cell, 93Spreadsheet, 78forward declarations, 14,15frame buffer, 439,440frame widgets, 37French, 369froglogic, 415fromAscii()(QString), 268fromLatin1()(QString), 268fromName()(QHostInfo), 335fromValue()(QVariant), 270FTP, 311–320ftpCommandStarted()(FtpGet), 314ftpDone()FtpGet, 314Spider, 317FtpGetclass definition, 312FtpGet(), 312done(), 312,314ftpCommandStarted(), 314ftpDone(), 314getFile(), 313,314ftpListInfo()(Spider), 317ftpgetexample, 311–315function prototypes, 454,458functors, 89–90Ggarbage collection, 465GB18030-0, 365GCC, 19,440GDI, 416–417general protection fault, 464General Public License, 447generateDocumentation()(QAxBase), 421generateId(), 303generateRandomTrip()(ClientSocket), 332generic algorithms, 88,251,263–265,271,489geometric shapes, 176geometries, 138German, 369get()QFtp, 311,313,314,317QHttp, 321,322getColor()(QColorDialog), 202getDC()(QPaintEngine), 417,418getDirectory()(Spider), 316getFile()FtpGet, 313,314HttpGet, 320GetInterfaceSafetyOptions()(ObjectSafetyImpl), 427getOpenFileName()(QFileDialog), 56,159,289getPrinterDC()(QPrintEngine), 418getSaveFileName()(QFileDialog), 57getText()(QInputDialog), 228GIF, 46global functions, 453,482–483global variables, 482–483GNU Compiler Collection (GCC), 19,440GNU General Public License, 447GoToCellDialogclass definition, 27creating usingQt Designer, 23–29usage, 62Go-to-Cell example, 23–29,62goToCell()(MainWindow), 62GoToCellDialogGoToCellDialog(), 27on_lineEdit_textChanged(), 28–29GPL, 447gradients, 179–180,186–187graphics, 175–203gravity.SeeWA_StaticContentsgrayed out widgets, 16Greek, 362,365grid layouts, 9,30,32,140–141group()(IconEditorPlugin), 115group boxes, 37GUI builder.See Qt DesignerGUI thread.Seeinitial thread"},{"pageNumber":522,"pageContent":"504IndexGujarati, 362Gurmukhi, 362GWorldPtr(Mac OS X), 418H.hfiles.Seeheader fileshalf-pixel coordinates, 180–181handle()QCursor, 418QFont, 418QPixmap, 418QRegion, 418QSessionManager, 418QWidget, 418hasAcceptableInput()(QLineEdit), 28–29hasFeature()(QSqlDriver), 296–297hasFormat()(QMimeData), 206hasLocalData()(QThreadStorage<T>), 391hasNext()(Java-style iterators), 255hasOpenGL()(QGLFormat), 203hasPendingEvents()(QCoreApplication),173hasPrevious()(Java-style iterators), 255hashes, 261–262HCURSOR(Windows), 418HDC(Windows), 418head()QHttp, 322QQueue<T>, 253headerData()CityModel, 236CurrencyModel, 234RegExpModel, 243header files, 3,15,454–456headers (item views), 221,227,234,237,243heap memory.Seenewoperatorheavy processing, 171,381Hebrew, 362height()(QPaintDevice), 109,112Hello example, 3–5help, 51,351–357HelpBrowserclass definitions, 353,356HelpBrowser(), 354showPage(), 355,357updateWindowTitle(), 355hexmanipulator, 280HexSpinBoxclass definition, 101integration withQt Designer, 113HexSpinBox(continued)HexSpinBox(), 102textFromValue(), 102validate(), 102valueFromText(), 103Hex Spin Box example, 101–103,113hexadecimal numbers, 103,280,281HFONT(Windows), 418HIView, 416HIViewRef(Mac OS X), 418hibernation, 432hidden widgets, 4,62,121,142,325hide()(QWidget), 121,142,325hideEvent()(Ticker), 168hierarchical item models, 240–243Homekey, 164homePath()(QDir), 286HorPattern(Qt), 177horizontalHeader()(QTableView), 77horizontal layouts, 9,25,140horizontalScrollBar()(QAbstractScrollArea), 77,148host addresses.SeeIP addresseshost names, 335hourglass cursor, 81HPALETTE(Windows), 418HRGN(Windows), 418HTML, 5,9,38,192–193,211–212,212,352,353–357,357,428html()(QMimeData), 214HTTP, 311,320–323httpDone()(HttpGet), 321HttpGetHttpGet(), 320getFile(), 320httpDone(), 321httpgetexample, 320–322HWND(Windows), 418IIANA, 206IBM 8xx, 365IBM DB2, 293icon()(IconEditorPlugin), 115IconEditorclass definition, 104integration withQt Designer,113–116with scroll bars, 149IconEditor(), 105mouseMoveEvent(), 111"},{"pageNumber":523,"pageContent":"Index505IconEditor(continued)mousePressEvent(), 111paintEvent(), 108pixelRect(), 110setIconImage(), 107setImagePixel(), 111setPenColor(), 107setZoomFactor(), 107sizeHint(), 106Icon Editor example, 104–112IconEditorPluginclass definition, 114IconEditorPlugin(), 114create(), 115group(), 115icon(), 115includeFile(), 114isContainer(), 115name(), 114toolTip(), 115whatsThis(), 115Icon Editor Plugin example, 113–116IconRole(Qt), 220icons, 46,48,55,66,209,370IDof a COM component, 420,427of a timer, 167of a widget, 415of an FTP command, 314of an HTTP request, 322of an X11 session, 434IDispatch(Windows), 423IDL, 430idle processing, 173#ifdirective, 487#ifdefdirective, 487#ifndefdirective, 14,455,487IFontDisp(Windows), 421ignore()(QEvent), 58,157,159IgnoreAction(Qt), 209Ignored(QSizePolicy), 143image()QClipboard, 215TransactionThread, 394Image Converter example, 287–290imageCount()(CursorHandler), 403imageData()(QMimeData), 214ImageMagick, 287Image Pro example, 392–396imageSpace(), 285ImageWindowImageWindow(), 392addTransaction(), 393ImageWindow(continued)allTransactionsDone(), 393flipHorizontally(), 393imagesalpha channel, 106,189,190as paint devices, 175color depth, 106distributing with the application, 47file formats, 46icons, 46,48,55,66,209,370imagespaceexample, 285–286implicit sharing, 257,259,397,439,471in-process databases, 293#includedirective, 453,455,486includeFile()(IconEditorPlugin), 114INCLUDEPATHentry (.profiles), 399incomingConnection()(TripServer), 330index()(RegExpModel), 241indexOf()QLayout, 143QString, 267information()(QMessageBox), 55inheritance.SeesubclassinginitFrom()QPainter, 129,189QStyleOption, 124initial thread, 391initializeGL()(Tetrahedron), 199inlining, 458–460input dialogs, 40–41input methods, 361,363,442insert()Java-style iterators, 256QLinkedList<T>, 253QMap<K,T>, 260QMultiMap<K,T>, 261QString, 267TeamLeadersDialog, 226INSERTstatement, 295insertMulti()QHash<K,T>, 262QMap<K,T>, 261insertRow()(QAbstractItemModel), 298installEventFilter()(QObject), 169,170installTranslator()(QCoreApplication),369instance()(QPluginLoader), 410Intel x86, 439,457intensive processing, 171,381Interface Definition Language (IDL),430interfacesapplication plugins, 408COM, 423,426"},{"pageNumber":524,"pageContent":"506Indexinterfaces (continued)Java and C#, 461Intermediate(QValidator), 102internalPointer()(QModelIndex), 241internationalization, 361–379Internet Assigned Numbers Authority,206Internet Explorer, 357,423Internet protocolsDNS.SeeQHostInfoFTP, 311–320HTTP, 320–323SSL, 322TCP, 323–333UDP, 333–337inter-process communication, 287–291introspection, 22,488Invalid(QValidator), 102invalid model indexes, 228,231,241invalid variants, 94invisible widgets, 4,62,121,142,325invokeMethod()(QMetaObject), 397I/Obinary, 80–82,274–278,323devices, 82,314,320,321,323plugins, 400Standard C++library, 488text, 279–285IObjectSafety(Windows), 426–427<iostream>header, 81,274,280,455,489IP addresses, 332,335IPC (inter-process communication),287–291IPictureDisp(Windows), 421isActive()(QSqlQuery), 295isContainer()(IconEditorPlugin), 115isDigit()(QChar), 363isEmpty()container classes, 256QString, 268isLetter()(QChar), 363isLetterOrNumber()(QChar), 363isLower()(QChar), 363isMark()(QChar), 363isNumber()(QChar), 363isPrint()(QChar), 363isPunct()(QChar), 363isRightToLeft()(QApplication), 370isSessionRestored()(QApplication), 436,437isSpace()(QChar), 363isSymbol()(QChar), 363isUpper()(QChar), 363isValid()(QVariant), 94Iscii, 365ISO 2022, 365ISO 8859-1 (Latin-1), 265,296,362–365ISO 8859-15, 369ISO 8859-x, 365item()(QTableWidget), 78itemChanged()(QTableWidget), 76ItemIsEditable(Qt), 238ItemIsEnabled(Qt), 237ItemIsSelectable(Qt), 237item prototypes, 76item views, 38iteratorsJava-style, 254–256,262read-only vs. read-write, 254,256,257,258STL-style, 253,256,262,489IUnknown(Windows), 423,426JJapanese, 362Java, 339,439,451JavaScript, 428Java-style iterators, 254–256,262JIS, 365join()(QStringList), 268,282join styles, 177JournalView, 375–376JPEG, 46jumpToNextImage()(CursorHandler), 406KKannada, 362KDAB (Klarälvdalens Datakonsult),415KeepSize(QSplitter), 146key()Java-style iterators, 131,262QKeyEvent, 164STL-style iterators, 234,262key events, 164–165keyPressEvent()CodeEditor, 164MyLineEdit, 169Plotter, 128QWidget, 128,164keyReleaseEvent()(QWidget), 164keyboard accelerators, 48"},{"pageNumber":525,"pageContent":"Index507keyboard drivers, 441,442keyboard focus.Seefocuskeyboard shortcuts, 16,25,48,165,353keysAlt, 16,164Backtab, 164Ctrl, 111,164Enter, 247Esc, 55,247F2, 228,305Home, 164Shift, 111,164Space, 168Tab, 120,164keys()associative containers, 261,263CursorPlugin, 401Khmer, 362killTimer()(QObject), 168Klarälvdalens Datakonsult, 415KOI8, 365Korean, 362,365LLabeledCircle, 462labels, 3,38–39language change events, 376Languagemenus, 372,374–375languages supported by Qt, 362Lao, 362last()(QSqlQuery), 295Latin-1, 265,296,362–365Latin-9.SeeISO 8859-15launching external programs, 287layout managersbox, 9,25,140compared with manual layout, 125,138–140grid, 9,30,32,140–141inQt Designer, 25,30,32,141margin and spacing, 140nesting, 17,140–141on plain widget, 73right-to-left, 9,170,369,370size hints, 17,35,53,107,121,140,142–143size policies, 107,120,142spacer items, 17,24,141stretch factors, 143LCD numbers, 38leaders()(TeamLeadersDialog), 226left()(QString), 266,267leftColumn()(QTableWidgetSelectionRange), 64left mouse button, 111,201,208length()(QString), 265,268libraries, 399,456LIBSentry (.profiles), 399licensing, 447–448line editors, 39line-ending conventions, 279,285line-oriented protocols, 323,332linear gradients, 179,187Linguist.See Qt LinguistLinkAction(Qt), 209link errors, 19,456,460,463linked lists, 252–253linker, 452,454Linux, 415–419,439,449–450list()(QFtp), 314,317listInfo()(QFtp), 316,317list models, 230list views, 38,218,226list widgets, 36,144,207,218,220listen()(QAbstractSocket), 332lists, 253little-endian, 275,363,457,475load()QTranslator, 369,375,376QUiLoader, 36loadFile()(MainWindow), 56loadPlugins()(TextArtDialog), 410localData()(QThreadStorage<T>), 391LocalDate(Qt), 370LocalHost(QHostAddress), 325,335local variables, 464,483localeAwareCompare()(QString), 267,370locale change events, 375localeconv()(std), 370localization.Seeinternationalizationlock()(QMutex), 385,387lockForRead()(QReadWriteLock), 386lockForWrite()(QReadWriteLock), 387logical coordinates, 180–182login()(QFtp), 313,314,316logout, 432,434look and feel, 11,124lookupHost()(QHostInfo), 335lrelease, 361,377–379“LTR” marker, 369lupdate, 361,366,367–368,376–379"},{"pageNumber":526,"pageContent":"508IndexMmacCGHandle()(QPixmap), 418macEvent()(QWidget), 419macEventFilter()(QApplication), 419Mac OS X, 415–419macQDAlphaHandle()(QPixmap), 418macQDHandle()(QPixmap), 418Mac style, 11,124MacintoshVersion(QSysInfo), 417macros, 486–487MagicNumber(Spreadsheet), 76,81MailClient, 146–148Mail Client example, 146–148main()argcandargvparameters, 3,160,453for ActiveX applications, 427,430for C++programs, 453for console applications, 311for database applications, 294for internationalized applications,368for MDI applications, 160for SDI applications, 69for simple Qt application, 3for splash screen, 72for Spreadsheet example, 68MainFormclass definition, 304MainForm(), 305addCd(), 307addTrack(), 308beforeInsertCd(), 307beforeInsertTrack(), 309currentCdChanged(), 306deleteCd(), 307deleteTrack(), 309editArtists(), 309refreshTrackViewHeader(), 309main layout, 17main thread, 391MainWindowclass definition, 44–45,205MainWindow(), 46,70,154,372about(), 66activeEditor(), 155closeEvent(), 57,157createActions(), 48,70,373createContextMenu(), 51createEditor(), 154createLanguageMenu(), 374createMenus(), 50,156,373createStatusBar(), 53MainWindow(continued)createToolBars(), 52cut(), 155find(), 61goToCell(), 62loadFile(), 56newFile(), 54,69,154okToContinue(), 55open(), 55,155openRecentFile(), 60readSettings(), 67,152retranslateUi(), 373save(), 57,155saveAs(), 57saveFile(), 57setCurrentFile(), 58sort(), 64–66spreadsheetModified(), 54strippedName(), 58switchLanguage(), 375updateMenus(), 155updateRecentFileActions(), 59updateStatusBar(), 54writeSettings(), 67,152main windows, 44–47,68–71,73,150–161makefiles, 4,19,428makeqpf, 442Malayalam, 362manhattanDistance(), 467manhattanLength()(QPoint), 208manipulators, 280,478,489manual layout, 125,139map<K,T>(std), 262maps, 260–261Margin(Plotter), 118margins (in layouts), 140master–detail, 304Maximum(QSizePolicy), 142maximumproperty (QProgressBar), 325maximum size, 140,143MDI, 71,74,152–161MDI Editor example, 153–160Media Player example, 419–423memcpy()(std), 470memory addresses, 464,466memory management, 4,28,70,464–465menuBar()(QMainWindow), 50menusbars, 46,50checkable actions, 49context, 51–52,152"},{"pageNumber":527,"pageContent":"Index509menus (continued)creating, 50–52disabling entries, 156dynamic, 59–60,156message()(Transaction), 396message boxes, 40–41,55messages.SeeeventsmetaObject()(QObject), 22meta-object compiler (moc), 19,22,60,114,412,424metrics, 167,413MFC migration, 415Microsoft Internet Explorer, 357,423Microsoft SQL Server, 293Microsoft Visual Basic, 428Microsoft Visual C++(MSVC), 5,19,36,271,417Microsoft Visual Studio, 5mid()(QString), 63,266middle mouse button, 215migration, 415mimeData()QClipboard, 215QDropEvent, 206,210MIME types, 206,210–214MinGW, 5,448Minimum(QSizePolicy), 107,142MinimumExpanding(QSizePolicy), 143minimumproperty (QProgressBar), 325minimum size, 35,53,140,143minimumSizeHint()Plotter, 123QWidget, 17,123,143MIPS, 439mirror()(QImage), 395MiterJoin(Qt), 177mkdir()QDir, 286QDirModel, 228QFtp, 314moc, 19,22,60,114,412,424modal dialogs, 62–63,355model–view–controller (MVC), 217model classes, 225,232,293model indexes, 226model/view architecture, 217–218,230,248modeless dialogs, 61modified()(Spreadsheet), 75,80modified documents, 54,58,159,160modifiers()(QKeyEvent), 128,164Mongolian, 362monitoring events, 168–171,419most recently used files, 50,59–60Motif migration, 415Motif style, 11,51,124Motorola 68000, 439mouse buttons, 111,201,208,215mouse cursor, 81,126,127mouseDoubleClickEvent()(Tetrahedron),201mouse drivers, 441,442mouseMoveEvent()IconEditor, 111MyTableWidget, 211Plotter, 126ProjectListWidget, 208Tetrahedron, 201mousePressEvent()IconEditor, 111OvenTimer, 185Plotter, 125ProjectListWidget, 208Tetrahedron, 201mouseReleaseEvent()Plotter, 126QWidget, 126,215mouse tracking, 111mouse wheels, 129MoveAction(Qt), 209moveToThread()(QObject), 392Movie, 254MRU files.Seerecently opened filesMSG(Windows), 418MuleLao-1, 365multi-hashes, 262multi-line editors.SeeQTextEditmulti-maps, 261multi-page dialogs, 36multi-page widgets, 38multiple database connections, 297multiple document interface (MDI), 71,74,152–161multiple documents, 68–71multiple inheritance, 27,28,411,424,462multithreading, 381–397mutable iterators, 254,255–256,258,262mutablekeyword, 92,95,402,476mutexes, 385,387,390,394MVC (model–view–controller), 217MyInteger, 477MyVector, 477MySQL, 293MyTableWidgetdropEvent(), 212"},{"pageNumber":528,"pageContent":"510IndexMyTableWidget(continued)mouseMoveEvent(), 211startDrag(), 211toCsv(), 211toHtml(), 211Nname()(IconEditorPlugin), 114nameless database connection, 297namespacesC++, 454,484–485XML, 339,342native APIs, 415–437native dialogs, 40nested layouts, 17,140–141nested splitters, 146networking, 311–337newoperator, 28,63,68–70,460,464,465,480new []operator, 470newFile()Editor, 158MainWindow, 54,69,154newPage()(QPrinter), 191,192,196new-style casts, 60,476–477newlines, 279,285newsletter.See Qt Quarterlynext()Java-style iterators, 255,262QSqlQuery, 295nextPrime(), 483nextRandomNumber(), 482,484nextSibling()(QDomNode), 348nmake, 5NoBrush(Qt), 177Node, 239–240nodeFromIndex()(RegExpModel), 241NoEditTriggers(QAbstractItemView), 222NoError(QFile), 279non-blocking I/O.Seeasynchronous I/Onon-commercial edition of Qt, 447–448non-const iterators, 254,255–256,258,262non-mutable iterators, 256,257,258non-validating XML parsers, 339,344NoPen(Qt), 177normalized()(QRect), 123,126northwest gravity.SeeWA_StaticContentsnotify()(QCoreApplication), 170Null(QChar), 94,95null pointers, 464numCopies()(QPrinter), 196numRowsAffected()(QSqlQuery), 295number()(QString), 79,103,266OObject(Java and C#), 461object files, 452ObjectSafetyImpl, 426–427objectsdynamic casts, 60,476event processing, 163–173introspection, 22names, 432parent–child mechanism, 28properties, 22,24,105,422,425–426reparenting, 9,17,53,149signals and slots mechanism, 20–22smart pointers, 465octal numbers, 281ODBC, 293offsetOf()(CityModel), 238okToContinue()Editor, 159MainWindow, 55OLE_COLOR(Windows), 421on_browseButton_clicked()(ConvertDialog), 288,289on_convertButton_clicked()(ConvertDialog), 288,289on_lineEdit_textChanged()(GoToCellDialog), 28–29one-shot timers, 168online documentation, 9–11,490online help, 351–357opacity, 106,189,190OpaqueMode(Qt), 180open()Editor, 159MainWindow, 55,155QIODevice, 81,82,274,280,320OpenGL, 198–203openRecentFile()(MainWindow), 60open source edition of Qt, 447–448operating systems, 417operator()(), 89operator*()(STL-style iterators), 256operator+()(QString), 265operator++()(STL-style iterators), 256operator+=()(QString), 265operator--()(STL-style iterators), 256"},{"pageNumber":529,"pageContent":"Index511operator<()(keys in maps), 261operator<<(), 252,280operator=()(Point2D), 481operator==()(keys in hashes), 261operator>>(), 280operator[]()container classes, 258QMap<K,T>, 260QVector<T>, 252operator overloading, 89,478–479Oracle, 293ordered associative containers.SeemapsOriya, 362ostream(std), 478OvenTimerclass definition, 183printing, 191OvenTimer(), 184draw(), 186–187duration(), 185mousePressEvent(), 185paintEvent(), 185setDuration(), 184timeout(), 183Oven Timer example, 183–188overloaded operators, 89,478–479override cursor, 81,126overridekeyword (C#), 462Ppage setup dialog, 40paginate()(PrintWindow), 194paint()(TrackDelegate), 246paint devices, 175,190paintEngine()QPaintDevice, 417QPainter, 417paintEvent()IconEditor, 108OvenTimer, 185Plotter, 123QWidget, 108,123,167,185,416,417Ticker, 167paintGL()(Tetrahedron), 200painter coordinates, 180–182painter paths, 178–179painters.SeeQPainterpair<T1,T2>(std), 262,271palette()(QWidget), 110palettes, 109–110,120parentof a dialog, 56of a validator, 28of a widget, 7,28of an item, 79,224,231,242,347of an object, 28parent()QModelIndex, 231RegExpModel, 242parentparameter, 14,16parse()(QXmlSimpleReader), 344parseEntry()(DomParser), 347parseFile()DOM Parser example, 348SAX Handler example, 343parsers, 96,238,280,339parsing events, 339–340paste()QTextEdit, 215Spreadsheet, 84PATHenvironment variable, 4,357,434,450paths.SeeQPainterPathPatternSyntaxQRegExp, 229PdfFormat(QPrinter), 191PE_FrameFocusRect(QStyle), 124peek()(QIODevice), 279,403pendingDatagramSize()(QUdpSocket), 336pending events, 173pens, 176,177percent sign (%), 59,265–266physical coordinates, 180–182Picture(X11), 418pie segments, 176,178pixelRect()(IconEditor), 110Pixmap(X11), 418pixmap()(QClipboard), 215pixmaps, 118,175placeholders (SQL), 295–296Plastique style, 11,124,179platform-specific APIs, 415–437PlayerWindowclass definition, 420PlayerWindow(), 420timerEvent(), 422PlotSettingsclass definition, 118PlotSettings(), 132adjust(), 132adjustAxis(), 132scroll(), 132spanX(), 118"},{"pageNumber":530,"pageContent":"512IndexPlotSettings(continued)spanY(), 118Plotterclass definition, 117Margin, 118Plotter(), 119clearCurve(), 122drawCurves(), 131drawGrid(), 130keyPressEvent(), 128minimumSizeHint(), 123mouseMoveEvent(), 126mousePressEvent(), 125mouseReleaseEvent(), 126paintEvent(), 123refreshPixmap(), 129resizeEvent(), 124setCurveData(), 122setPlotSettings(), 121sizeHint(), 123updateRubberBandRegion(), 129wheelEvent(), 128zoomIn(), 122zoomOut(), 122Plotter example, 116–133Plug & Paint example, 414pluginsfor Qt, 400–408for Qt applications, 408–414forQt Designer, 113–116PNG, 46PNM, 46Point2Dcopy constructor and assignmentoperator, 481inline implementation, 458operator overloading, 478out-of-line implementation, 458–459usage, 460pointers, 463–466,468,469–470polygons, 176,186polylines, 132,176polymorphism, 460–462pop()(QStack<T>), 253populateListWidget()(TextArtDialog),411populateRandomArray(), 482,484popup menus.Seemenusport()(QUrl), 313pos()(QMouseEvent), 111,208post()(QHttp), 322postEvent()(QCoreApplication), 396PostScript, 191,442PostgreSQL, 293PowerPC, 439,457predefined models, 225PreferenceDialog, 144preferences, 67–68,148,152,223Preferences example, 144Preferred(QSizePolicy), 120,142–143premultiplied ARGB format, 189prepare()(QSqlQuery), 295–296preprocessor, 455,486–488previewing inQt Designer, 26,145previous()Java-style iterators, 255,262QSqlQuery, 295primitive data types, 456–457print()(QTextDocument), 193printBox()(PrintWindow), 197print dialog, 40,190printFlowerGuide()(PrintWindow), 192,193printHtml()(PrintWindow), 193printOvenTimer()(PrintWindow), 191printPage()(PrintWindow), 197printPages()(PrintWindow), 195PrintWindowentryHeight(), 194paginate(), 194printBox(), 197printFlowerGuide(), 192,193printHtml(), 193printOvenTimer(), 191printPage(), 197printPages(), 195printer drivers, 191printing, 190–198private inheritance, 461private section, 458.profilescreating usingqmake, 4debug vs. release mode, 408external libraries, 399for ActiveX applications, 422,428,431for application plugins, 414for console applications, 284for database applications, 310for internationalized applications,368,377for network applications, 315for OpenGL applications, 203forQt Designerplugins, 116for Qt plugins, 408for usingQAssistantClient, 356for usingQUiLoader, 36"},{"pageNumber":531,"pageContent":"Index513.profiles (continued)for XML applications, 344,348include path, 399resources, 47,121,286,370processError()(ConvertDialog), 290processEvents()(QCoreApplication),171–173processFinished()(ConvertDialog), 290processNextDirectory()(Spider), 316processPendingDatagrams()(WeatherStation), 336processes, 287producer–consumer model, 387–390programs.Seeexamplesprogress bars, 38,325progress dialogs, 40–41Project Chooser example, 207–210project files.See.profilesProjectListWidgetclass definition, 207ProjectListWidget(), 208dragEnterEvent(), 209dragMoveEvent(), 209dropEvent(), 210mouseMoveEvent(), 208mousePressEvent(), 208startDrag(), 208promotion approach (Qt Designer), 113propagation of events, 165,171,206properties, 22,24,105,422,425–426property()(QObject), 422propertyChanged()(QAxBindable),425–426proportional resizing, 139protected inheritance, 461protected section, 458protocols.SeeInternet protocolsprototypesfor C++functions, 454,458for table items, 76proxy models, 228public inheritance, 461public section, 458pure virtual functions, 408,461PurifyPlus, 457push()(QStack<T>), 253push buttons, 5,16,24,37put()(QFtp), 314QQ_ARG(), 397Q_CC_xxx, 417Q_CLASSINFO(), 428–429Q_DECLARE_INTERFACE(), 409Q_DECLARE_METATYPE(), 270Q_ENUMS(), 420,424Q_EXPORT_PLUGIN2(), 115–116,402,414Q_INTERFACES(), 114,412Q_OBJECTmacrofor meta-object system, 22for properties, 105for signals and slots, 14,21,44fortr(), 16,366runningmoc, 19Q_OS_xxx, 417Q_PROPERTY(), 104–105Q_WS_xxx, 417qAbs(), 256,265QAbstractItemDelegate, 246closeEditor(), 247commitData(), 247createEditor(), 247paint(), 246setEditorData(), 247setModelData(), 248QAbstractItemModel,232,240columnCount(), 233,236,242createIndex(), 237data(), 233,236,242,244dataChanged(), 237,306flags(), 237headerData(), 234,236,243index(), 241parent(), 242regExpChanged(), 243removeRows(), 226reset(), 234rowCount(), 233,236,242setData(), 237QAbstractItemView,150AnyKeyPressed, 220ContiguousSelection, 76,84,212DoubleClicked, 225NoEditTriggers, 222selectAll(), 86selectionModel(), 306setEditTriggers(), 220,222,225setItemDelegate(), 245setModel(), 225QAbstractListModel, 232QAbstractScrollArea, 38,39,77,150QAbstractSocket, 397QAbstractTableModel, 232,235QAccessibleBridge, 400QAccessibleBridgePlugin, 400"},{"pageNumber":532,"pageContent":"514IndexQAccessibleInterface, 400QAccessiblePlugin, 400QAction, 48–50compared with key events, 165setCheckable(), 49setChecked(), 156setEnabled(), 156setShortcutContext(), 165setStatusTip(), 351setToolTip(), 351setVisible(), 49,59toggled(), 49triggered(), 48QActionGroup, 49,155,156,375qAppglobal variable, 50,170QApplication, 3,312in console applications, 284quitOnLastWindowClosedproperty, 58subclassing, 433aboutQt(), 50arguments(), 160beep(), 86clipboard(), 83,215closeAllWindows(), 70commitData(), 432,434exec(), 3,171–172,391hasPendingEvents(), 173installTranslator(), 369isRightToLeft(), 370isSessionRestored(), 436,437macEventFilter(), 419notify(), 170processEvents(), 171–173quit(), 6,58qwsEventFilter(), 419qwsSetDecoration(), 442restoreOverrideCursor(), 80,126saveState(), 431,433sessionId(), 436sessionKey(), 436setLayoutDirection(), 369setOverrideCursor(), 80,126startDragDistance(), 208style(), 124topLevelWidgets(), 71translate(), 367winEventFilter(), 419x11EventFilter(), 419QAssistantClient, 357QAXAGG_IUNKNOWN, 426QAXFACTORY_BEGIN(), 429,431QAXFACTORY_DEFAULT(), 425,427,429QAXFACTORY_END(), 429,431QAXFACTORY_EXPORT(), 429QAxAggregated, 426QAxBase, 420dynamicCall(), 423generateDocumentation(), 421queryInterface(), 423querySubObject(), 423QAxBindable, 423createAggregate(), 426propertyChanged(), 425–426requestPropertyChange(), 425–426QAXCLASS(), 429,431QAxContainermodule, 419–423QAxObject, 420,423QAxServermodule, 419,423–431QAXTYPE(), 429,431QAxWidget, 420,423qBinaryFind(), 263QBitArray, 271,405,407,488QBitmap, 405QBrush, 110,176QBuffer, 273,320,326QByteArray,269,273,279constData(), 269data(), 269QCache<K,T>, 262QCDEStyle, 124QChar,265,362isX()functions, 363Null, 94,95toLatin1(), 363unicode(), 363QCheckBox, 37QClipboard,215setText(), 83text(), 85QCloseEvent, 58,157,159,384QColor, 106,110,229QColorDialog, 39,202QColormap, 418QComboBox,39addItem(), 35,229currentIndex(), 64–65qCompress(), 279-qconfigoption (configure), 441QConicalGradient, 186QCopChannel, 440qCopy(), 264QCoreApplication, 312addLibraryPath(), 408arguments(), 312postEvent(), 396removePostedEvent(), 396"},{"pageNumber":533,"pageContent":"Index515QCoreApplication(continued)removePostedEvents(), 396QCursor, 418QDataStreambinary format, 81,274,275container classes, 251custom types, 271on a byte array, 326on a socket, 323,331supported data types, 274syntax, 81versioning, 81with QCOP, 440–441Qt_4_1, 81,275,277readRawBytes(), 277setByteOrder(), 404setVersion(), 81,274,275,277–278skipRawData(), 404writeRawBytes(), 277QDate, 370QDateEdit, 39,370QDateTime, 185,370QDateTimeEdit, 39,370qDebug(), 266QDecoration, 442QDecorationPlugin, 442qDeleteAll(), 240,264QDesignerCustomWidgetInterface, 114create(), 115group(), 115icon(), 115includeFile(), 114isContainer(), 115name(), 114toolTip(), 115whatsThis(), 115QDial, 39QDialog, 14subclassing, 14,27,34Accepted, 28,63Rejected, 28,63accept(), 28,33,63done(), 220,222exec(), 62–63reject(), 28,33,63setModal(), 62,172QDir, 228,285convertSeparators(), 286currentPath(), 286entryInfoList(), 286entryList(), 285exists(), 286homePath(), 286QDir(continued)mkdir(), 286rename(), 286rmdir(), 286separator(), 289QDirModel, 225,226–228,228QDockWidget, 150–151QDomDocument,346createElement(), 348createTextNode(), 348documentElement(), 346setContent(), 346QDomElement, 345,346QDomNode, 346appendChild(), 349firstChild(), 348nextSibling(), 348save(), 348toElement(), 346toText(), 347QDomText, 345,347QDoubleSpinBox, 39QDoubleValidator, 28QDrag, 209QDragEnterEvent, 206,209accept(), 209acceptProposedAction(), 206mimeData(), 206setDropAction(), 209source(), 209QDragMoveEvent, 209accept(), 209setDropAction(), 209QDropEventmimeData(), 210setDropAction(), 210QErrorMessage, 40–41QEvent,418accept(), 58,157,159,384ignore(), 58,157,159type(), 163,164QEventLoop, 172QFile, 80,273,317,344implicit close, 275implicit open, 344NoError, 279close(), 291error(), 279errorString(), 80,82exists(), 286open(), 81,82,274,280remove(), 286QFileDialog, 40"},{"pageNumber":534,"pageContent":"516IndexQFileDialog(continued)DontConfirmOverwrite, 57getOpenFileName(), 56,159,289getSaveFileName(), 57QFileInfo, 58,285qFill(), 263qFind(), 263qFindChild<T>(), 36QFlags<T>, 474QFont, 176,418QFontDialog, 39QFontMetrics, 167,413QFrame, 37QFtp, 311cd(), 314,317close(), 313,314commandFinished(), 314commandStarted(), 314connectToHost(), 313,314,316done(), 313,314,315get(), 311,313,314,317list(), 314,317listInfo(), 316,317login(), 313,314,316mkdir(), 314put(), 314rawCommand(), 314read(), 320readAll(), 320readyRead(), 320remove(), 314rename(), 314rmdir(), 314stateChanged(), 315qglClearColor()(QGLWidget), 200QGLColormap, 203QGLContext, 203QGLFormat, 203QGLWidget, 198initializeGL(), 199paintGL(), 200qglClearColor(), 200resizeGL(), 200setFormat(), 199updateGL(), 201,202QGradient.SeegradientsqGreater<T>(), 264QGridLayout, 9,30,32,140–141,141QGroupBox, 37qHash(), 261QHash<K,T>, 261–262QHBoxLayout, 9,25,140addLayout(), 16QHBoxLayout(continued)addWidget(), 16QHeaderView, 77QHostAddressAny, 332LocalHost, 325,335QHttp, 320close(), 321done(), 320get(), 321,322head(), 322post(), 322read(), 323readAll(), 323readyRead(), 323request(), 322requestFinished(), 322requestStarted(), 322setHost(), 321,322setUser(), 322QIcon, 115,270QIconEngine, 400QIconEnginePlugin, 400QImage, 106as a paint device, 175,188–190composition modes, 189–190convertToFormat(), 107height(), 112mirror(), 395rect(), 112setPixel(), 112width(), 112QImageIOHandler, 400subclassing, 402canRead(), 402currentImageNumber(), 403imageCount(), 403jumpToNextImage(), 406read(), 404QImageIOPlugin, 400subclassing, 400capabilities(), 401create(), 401keys(), 401QImageReader, 400QInputContext, 400QInputContextPlugin, 400QInputDialog, 40–41,228QIntValidator, 28qintX, 81,275QIODevice,273,346ReadOnly, 82WriteOnly, 80,274"},{"pageNumber":535,"pageContent":"Index517QIODevice(continued)peek(), 279,403readAll(), 278seek(), 273,279,326ungetChar(), 279write(), 278QItemDelegate, 245drawDisplay(), 247drawFocus(), 247QItemSelectionModel, 306QKbdDriverPlugin, 442QKeyEvent, 128,164QLabel, 3,38–39,54QLatin1String(), 368QLayout, 17,140SetFixedSize, 35setMargin(), 140setSizeConstraint(), 34setSpacing(), 140QLCDNumber, 38QLibrary, 399QLineEdit,39hasAcceptableInput(), 28–29setBuddy(), 15text(), 63textChanged(), 16,28QLinearGradient, 187QLinkedList<T>, 252–253QLinkedListIterator<T>, 254QList<T>, 253QListIterator<T>, 254QListView, 38,218,226QListWidget, 36,207,218,220currentRowChanged(), 36,144–145setCurrentRow(), 144QListWidgetItem, 78,220,411setData(), 78,220setIcon(), 220setText(), 220QLocale, 369,370,488.qmfiles, 365,369,370,374,377QMacStyle, 124QMainWindow, 44,150–152areas, 47central widget, 46–47,73–74,147,153dock widgets, 150–152subclassing, 44,428toolbars, 150–152menuBar(), 50restoreState(), 152saveState(), 152setCentralWidget(), 46QMainWindow(continued)setCorner(), 151statusBar(), 53qmake, 4–5,19,22,26,286,428See also.profilesQMap<K,T>, 122,260–261QMapIterator<K,T>, 131,262QMatrix, 182–183qMax(), 265QMenu,50addAction(), 50,51addMenu(), 51addSeparator(), 50exec(), 52QMenuBaraddMenu(), 50addSeparator(), 51QMessageBox, 40–41,55,66Default, 55Escape, 55about(), 66critical(), 55information(), 55question(), 55warning(), 55QMetaObject, 397,488QMimeData,209copying to the clipboard, 215subclassing, 212colorData(), 214data(), 210,214formats(), 210,213hasFormat(), 206html(), 214imageData(), 214retrieveData(), 210,213setData(), 210,211setHtml(), 211setText(), 211text(), 210,214urls(), 207,214qMin(), 185,265QModelIndex, 226column(), 231,233internalPointer(), 241parent(), 231row(), 231,233QMotifStyle, 124QMouseDriverPlugin, 442QMouseEvent, 111,201,208QMovie, 400QMultiHash<K,T>, 262QMultiMap<K,T>, 261,263"},{"pageNumber":536,"pageContent":"518IndexQMutableListIterator<K,T>, 255QMutableMapIterator<K,T>, 262QMutableStringListIterator, 59QMutableVectorIterator<T>, 254QMutex,385,389lock(), 385,387tryLock(), 385unlock(), 385,387QMutexLocker, 385–386QObject,21,22dynamic casts, 60,476smart pointers, 465storing in containers, 253subclassing, 21–22,430connect(), 6,8,16,20–22,391,396deleteLater(), 331,397disconnect(), 21,22,396event(), 164,170eventFilter(), 169,170findChild<T>(), 36installEventFilter(), 169,170killTimer(), 168metaObject(), 22moveToThread(), 392property(), 422qt_metacall(), 22sender(), 60,247setProperty(), 422startTimer(), 167timerEvent(), 168,173,422tr(), 16,22,361,364,365–368,374,377–378qobject_cast<T>(), 60,71,209,214,411,412,476QPageSetupDialog, 40QPaintDevice, 417QPaintEngine, 417,418QPainter,175–198combining with GDI calls, 417composition modes, 189–190coordinate system, 109,180–182on a printer, 190SmoothPixmapTransform, 413TextAntialiasing, 413boundingRect(), 195drawArc(), 176drawChord(), 176drawCubicBezier(), 176drawEllipse(), 176,178,186–187drawLine(), 109,176,187drawLines(), 176drawPath(), 176,414drawPie(), 176,178QPainter(continued)drawPixmap(), 123,176drawPoint(), 176drawPoints(), 176drawPolygon(), 176,186drawPolyline(), 132,176drawRect(), 176,181drawRoundRect(), 176,187drawText(), 130–131,167,176,182,187fillRect(), 110initFrom(), 129–130,189paintEngine(), 417restore(), 180,188rotate(), 183,187–188save(), 180,188scale(), 183setBrush(), 176setClipRect(), 131setCompositionMode(), 190setFont(), 176setMatrix(), 182setPen(), 109,176setRenderHint(), 178,185,413setViewport(), 185setWindow(), 182,185shear(), 183translate(), 183QPainterPath, 178–179,413QPair<T1,T2>, 260,271QPalette, 110QPen, 176QPF, 442QPictureFormatPlugin, 400QPixmapas a paint device, 175for double buffering, 118fill(), 129handle(), 418macCGHandle(), 418macQDAlphaHandle(), 418macQDHandle(), 418x11Info(), 418x11PictureHandle(), 418QPlastiqueStyle, 124QPluginLoader, 410QPoint, 109,208QPointF, 118QPointer<T>, 465QPrintDialog, 40,190,196QPrintEngine, 418qPrintable(), 269,274QPrinter, 190–198"},{"pageNumber":537,"pageContent":"Index519QPrinter(continued)PdfFormat, 191newPage(), 191,192,196numCopies(), 196setPrintProgram(), 191QProcess, 273,287–291,357error(), 288execute(), 291finished(), 288readAllStandardError(), 290readyReadStandardError(), 288start(), 289,291waitForFinished(), 291,397waitForStarted(), 291QProgressBar, 38,325as busy indicator, 325minimumandmaximumproperties, 325QProgressDialog, 40–41,172–173invoking, 172setRange(), 172setValue(), 173wasCanceled(), 172QPushButton, 5,37,333clicked(), 6,163,288setDefault(), 15setText(), 35toggled(), 33–34QQueue<T>, 253QRadialGradient, 187QRadioButton, 37.qrcfiles, 47,286,287,370,371QReadLocker, 387QReadWriteLock, 386–387QRect, 111,125–126adjusted(), 124contains(), 112,125normalized(), 123,126QRegExp, 28,98,102,230QRegExpValidator, 28,102QRegion, 418qRegisterMetaTypeStreamOperators<T>(),271,277QRgb, 106qRgb(), 106qRgba(), 106QRubberBand(), 129QSA, 22QScreen, 442QScreenDriverPlugin, 442QScrollArea,148–150constituent widgets, 148wheel mouse support, 129horizontalScrollBar(), 148QScrollArea(continued)setHorizontalScrollBarPolicy(), 149setVerticalScrollBarPolicy(), 149setWidget(), 149setWidgetResizable(), 149verticalScrollBar(), 148viewport(), 148,149QScrollBar, 39,77,148QSemaphore, 387acquire(), 387,388release(), 387,388QSessionManager,433cancel(), 435handle(), 418release(), 435setDiscardCommand(), 433QSet<K>, 262QSettings,67–68,223–224saving main window state, 152saving splitter state, 148support for custom types, 277support for variants, 67,269beginGroup(), 67endGroup(), 67setValue(), 67value(), 67–68QSharedData, 259QSharedDataPointer, 259QShortcut, 165QSizePolicy, 107,142stretch factors, 143Expanding, 120,142–143Fixed, 142Ignored, 143Maximum, 142Minimum, 107,142MinimumExpanding, 143Preferred, 120,142–143QSlider, 7,39setRange(), 7setValue(), 7–8valueChanged(), 7–8qSort(), 91,264QSortFilterProxyModel, 225,228–230setFilterKeyColumn(), 229setFilterRegExp(), 230setSourceModel(), 229QSpinBox, 7,39,101subclassing, 101–103setRange(), 7setValue(), 7–8textFromValue(), 102validate(), 102"},{"pageNumber":538,"pageContent":"520IndexQSpinBox(continued)valueChanged(), 7–8valueFromText(), 103QSplashScreen, 71–72QSplitter, 74,145–148KeepSize, 146addWidget(), 145restoreState(), 148saveState(), 148setSizes(), 147setStretchFactor(), 147sizes(), 256QSqlDatabase, 294addDatabase(), 294,297commit(), 296database(), 297driver(), 296rollback(), 296setDatabaseName(), 294setHostName(), 294setPassword(), 294setUserName(), 294transaction(), 296QSqlDriver, 296,400QSqlDriverPlugin, 400QSqlQuery, 294addBindValue(), 296bindValue(), 296exec(), 294–296first(), 295isActive(), 295last(), 295next(), 295numRowsAffected(), 295prepare(), 295–296previous(), 295seek(), 295setForwardOnly(), 295value(), 295QSqlQueryModel, 225QSqlRelation, 305QSqlRelationalDelegate, 305QSqlRelationalTableModel, 225,293,305,307QSqlTableModel, 225,293,302,306beforeInsert(), 303,306,307insertRow(), 298record(), 297–299,309removeRow(), 304removeRows(), 299select(), 297,298,304setData(), 298,299setFilter(), 297QSqlTableModel(continued)setTable(), 297submitAll(), 298value(), 297–299qStableSort(), 88–91,264QStack<T>, 253QStackedLayout, 143–145addWidget(), 144indexOf(), 143setCurrentIndex(), 143,144,145QStackedWidget, 36,143QStandardItemModel, 225QStatusBar, 53addWidget(), 53showMessage(), 56QString,259,473,488case sensitivity, 264,267conversion to and fromconst char *,268–269Unicode support, 265,362–365append(), 265arg(), 59,246,265–266,367contains(), 86endsWith(), 267fromAscii(), 268fromLatin1(), 268indexOf(), 267insert(), 267isEmpty(), 268left(), 266,267length(), 265,268localeAwareCompare(), 267,370mid(), 63,266number(), 79,103,266operator+(), 265operator+=(), 265remove(), 267replace(), 212,267right(), 266,267setNum(), 266simplified(), 268split(), 85,268,282sprintf(), 265startsWith(), 267toAscii(), 269toDouble(), 95,266toInt(), 63,103,266,283toLatin1(), 269toLongLong(), 266toLower(), 264,267toStdString(), 274toUpper(), 103,267trimmed(), 267–268"},{"pageNumber":539,"pageContent":"Index521QString(continued)truncate(), 259QStringList,59,253join(), 268,282removeAll(), 59takeFirst(), 282QStringListModel, 225,226,229QStyle,124,400compared with window decorations,442PE_FrameFocusRect, 124drawPrimitive(), 124QStyleOptionFocusRect, 124QStylePainter, 124QStylePlugin, 400qSwap(), 264QSysInfo, 417Qtnamespace,485AlignHCenter, 54BackgroundColorRole, 230,244BDiagPattern, 177BevelJoin, 177CopyAction, 209CrossPattern, 177DashDotDotLine, 177DashDotLine, 177DashLine, 177Dense[1-7]Pattern, 177DiagCrossPattern, 177DisplayRole, 92,93–94,220,230,233,243DotLine, 177EditRole, 92,93–94,220,230,237escape(), 193,211,212,349FDiagPattern, 177FlatCap, 177FontRole, 230,244HorPattern, 177IconRole, 220IgnoreAction, 209ItemIsEditable, 238ItemIsEnabled, 237ItemIsSelectable, 237LinkAction, 209LocalDate, 370MiterJoin, 177MoveAction, 209NoBrush, 177NoPen, 177OpaqueMode, 180RoundCap, 177RoundJoin, 177ScrollBarAlwaysOn, 149SolidLine, 177Qtnamespace (continued)SolidPattern, 177SquareCap, 177StatusTipRole, 230StrongFocus, 120TextAlignmentRole, 93–94,230,233,244TextColorRole, 230,244ToolTipRole, 230TransparentMode, 180UserRole, 220VerPattern, 177WA_DeleteOnClose, 70,155,158,356WA_GroupLeader, 355WA_PaintOnScreen, 417WA_StaticContents, 106,112WhatsThisRole, 230Qt_4_1(QDataStream), 81,275,277<QtAlgorithms>header, 263Qt Assistantbrowsing the Qt documentation, 9providing online help, 356<QtDebug>header, 266Qt Designercreating dialogs, 23–29creating main windows, 44launching, 23layouts, 25,30,32previewing, 26,145splitters, 148templates, 23,103,144.uifiles, 26–29,36,288using custom widgets, 113–116Qt editions, 447–448QTentry (.profiles), 203,284,310,315,344,348-qt-gfx-vncoption (configure), 441-qt-gifoption (configure), 46<QtGlobal>header, 265<QtGui>header, 15Qt Linguist, 361,377–379qt_metacall()(QObject), 22QT_NO_CAST_FROM_ASCII, 368QT_NO_xxx, 441Qt Quarterly, 11,349Qt Script for Applications, 22Qt Solutions, 322,415QT_TR_NOOP(), 367–368QT_TRANSLATE_NOOP(), 368QTabWidget, 36,38QTableView, 38,218,302,305QTableWidget,74,218,221–222constituent widgets, 77"},{"pageNumber":540,"pageContent":"522IndexQTableWidget(continued)drag and drop, 211item ownership, 79subclassing, 75clear(), 77horizontalHeader(), 77horizontalScrollBar(), 77item(), 78itemChanged(), 76selectColumn(), 86selectRow(), 86selectedRanges(), 84setColumnCount(), 77setCurrentCell(), 63setHorizontalHeaderLabels(), 221setItem(), 79,222setItemPrototype(), 76,92setRowCount(), 77setSelectionMode(), 76,212setShowGrid(), 49verticalHeader(), 77verticalScrollBar(), 77viewport(), 77QTableWidgetItem, 75,78,91ownership, 79subclassing, 91clone(), 92data(), 91,93,220setData(), 78,93text(), 78,91,93,220QTableWidgetSelectionRange, 64,213QtCoremodule, 15,270,284QTcpServer, 323,329QTcpSocket, 273,323subclassing, 330bytesAvailable(), 331canReadLine(), 333close(), 328,331connectToHost(), 325connected(), 325disconnected(), 325,329,330,331error(), 325incomingConnection(), 330listen(), 332readLine(), 333readyRead(), 325,327,328,330,331,333setSocketDescriptor(), 330write(), 327,332QTDIRenvironment variable, 116,408QTemporaryFile, 273,291QTextBrowser, 38–39,353,355QTextCodec,363,400QTextCodec(continued)codecForLocale(), 363codecForName(), 364–365setCodecForCStrings(), 365setCodecForTr(), 364,378toUnicode(), 365QTextCodecPlugin, 400QTextDocument,160,192–193contentsChanged(), 158,160print(), 193setHtml(), 193setModified(), 160QTextEdit, 39,157subclassing, 157append(), 290copy(), 215copyAvailable(), 154cut(), 215document(), 158paste(), 215setPlainText(), 145QTextStream, 82,279,363encodings, 279,363–364on a file, 280on a socket, 323on a string, 282syntax, 280AlignAccountingStyle, 281AlignCenter, 281AlignLeft, 281AlignRight, 281FixedNotation, 281ForcePoint, 281ForceSign, 281ScientificNotation, 281ShowBase, 281SmartNotation, 281UppercaseBase, 281UppercaseDigits, 281readAll(), 280readLine(), 280,282setAutoDetectUnicode(), 364setCodec(), 280,363–364setFieldAlignment(), 281setFieldWidth(), 281setGenerateByteOrderMark(), 363setIntegerBase(), 281setNumberFlags(), 281setPadChar(), 281setRealNumberNotation(), 281setRealNumberPrecision(), 281QtGuimodule, 15,270,312QThread, 381"},{"pageNumber":541,"pageContent":"Index523QThread(continued)subclassing, 381,393currentThread(), 390exec(), 397finished(), 395run(), 382,385–386,388,389,390,394,396start(), 384terminate(), 382wait(), 384QThreadStorage<T>, 390–391QTicker, 166QTime, 370QTimeEdit, 39,244,247,370QTimer, 168compared with timer events, 168single-shot, 168,184setSingleShot(), 184start(), 334timeout(), 168,184,334QtNetworkmodule, 15,311–337QToolBar, 52addAction(), 52addSeparator(), 52QToolBox, 38QToolButton, 37QtOpenGLmodule, 15,198–203Qtopia, 417,418Qtopia Core, 251,439–441Qtopia PDA, 439Qtopia Phone, 439Qtopia Platform, 439Qtopia virtual frame buffer (qvfb), 441QTranslator, 369,374,375,376QTreeView, 38,218,227,243expand(), 227scrollTo(), 228QTreeWidget, 36,218,222–224,340,344,348QTreeWidgetItem, 78,224subclassing, 430setData(), 78setText(), 342,347QtSqlmodule, 15,293–310,397QtSslSocket, 322QtSvgmodule, 15QtXmlmodule, 15,339–349QUdpSocket, 273bind(), 337pendingDatagramSize(), 336readDatagram(), 336readyRead(), 336writeDatagram(), 334,337queries, 294QueryInterface()(IUnknown), 426queryInterface()QAxAggregated, 426QAxBase, 423querySubObject()(QAxBase), 423question()(QMessageBox), 55queues, 253QUiLoader, 36quintX, 81,275quit()(QCoreApplication), 6,58Quit example, 6quitOnLastWindowClosedproperty(QApplication), 58qUncompress(), 279QUrl, 207,312,313,316QUrlInfo, 317QValidator, 28–29Acceptable, 102Intermediate, 102Invalid, 102validate(), 102QVarLengthArray<T,Prealloc>, 271QVariant,269–271for action’s “data” item, 60for databases, 295for drag and drop, 214for item views, 220for properties, 105,422isValid(), 94toString(), 94qVariantCanConvert<T>(), 271qVariantFromValue(), 271qVariantValue<T>(), 271QVBoxLayout, 9,25,140addLayout(), 16addStretch(), 141addWidget(), 16QVector<T>, 252,256,471QVectorIterator<T>, 254qvfb, 441-qvfboption (configure), 441QWaitCondition, 389wait(), 389,390wakeAll(), 389QWhatsThis, 353QWheelEvent, 129QWidget,10in multithreaded applications, 397subclassing, 104,117,166,183windowModifiedproperty, 54,55,58,158activateWindow(), 61–62,86addAction(), 51"},{"pageNumber":542,"pageContent":"524IndexQWidget(continued)adjustSize(), 121changeEvent(), 375,376close(), 16,58closeEvent(), 44,57,157,159,384,435contextMenuEvent(), 52dragEnterEvent(), 206,209dragLeaveEvent(), 207dragMoveEvent(), 207,209dropEvent(), 206,210,212find(), 415focusNextChild(), 169,170fontMetrics(), 160,167handle(), 418height(), 109hide(), 121,142,325hideEvent(), 168keyPressEvent(), 128,164,169keyReleaseEvent(), 164macEvent(), 419minimumSizeHint(), 17,123,143mouseDoubleClickEvent(), 201mouseMoveEvent(), 111,126,201,208,211mousePressEvent(), 111,125,185,201,208,210mouseReleaseEvent(), 126,210,215paintEvent(), 108,123,167,185,416,417palette(), 110qwsEvent(), 419repaint(), 108resize(), 139resizeEvent(), 124–125,139scroll(), 168setAcceptDrops(), 206,208,212setAttribute(), 70setAutoFillBackground(), 120setBackgroundRole(), 119–120,129setContextMenuPolicy(), 51setCursor(), 126setEnabled(), 15,18setFixedHeight(), 17setFixedSize(), 138setFocus(), 158setFocusPolicy(), 120setGeometry(), 68,138setLayout(), 7,9setMinimumSize(), 35,53,139setMouseTracking(), 111setSizePolicy(), 105,107,120,422setStyle(), 124QWidget(continued)setTabOrder(), 19setToolTip(), 351setVisible(), 33–34setWhatsThis(), 352setWindowIcon(), 46setWindowModified(), 54,158,160setWindowTitle(), 7,17,58–59,160show(), 3,61–62,121,142showEvent(), 167sizeHint(), 17,35,53,106,123,143,160,167startDrag(), 211style(), 124unsetCursor(), 126update(), 87,107,108,112,121–122,129,167,168,185updateGeometry(), 107,167wheelEvent(), 128width(), 109winEvent(), 419winId(), 415–416,418x11Event(), 419x11Info(), 418x11PictureHandle(), 418QWindowsStyle, 124QWindowsXPStyle, 124QWorkspace, 74,152activeWindow(), 155cascade(), 156closeActiveWindow(), 156closeAllWindows(), 156tile(), 156windowActivated(), 154QWriteLocker, 387QWS_DEPTHenvironment variable, 441QWS_DISPLAYenvironment variable, 442QWS_KEYBOARDenvironment variable, 441,442QWS_MOUSE_PROTOenvironment variable,441,442QWS_SIZEenvironment variable, 441QWSEvent, 418qwsEvent()(QWidget), 419qwsEventFilter()(QApplication), 419QWSInputMethod, 442QWSKeyboardHandler, 442QWSMouseHandler, 442-qwsoption (Qtopia applications), 440QWSServer, 442qwsServerglobal variable, 442qwsSetDecoration()(QApplication), 442QX11Info, 418"},{"pageNumber":543,"pageContent":"Index525QXmlContentHandler,340characters(), 342endDocument(), 340endElement(), 343startDocument(), 340startElement(), 342QXmlDeclHandler, 340QXmlDefaultHandler, 340,341QXmlDTDHandler, 340QXmlEntityResolver, 340QXmlErrorHandler, 340errorString(), 342fatalError(), 343QXmlLexicalHandler, 340QXmlSimpleReader, 339,340,344parse(), 344setContentHandler(), 344setErrorHandler(), 344Rradial gradients, 180,187radio buttons, 37random-access devices, 279Rational PurifyPlus, 457rawCommand()(QFtp), 314.rcfiles, 428,431rcc, 286read()CursorHandler, 404QFtp, 320QHttp, 323readAll()QFtp, 320QHttp, 323QIODevice, 278QTextStream, 280readAllStandardError()(QProcess), 290readBitmap()(CursorHandler), 407readClient()(ClientSocket), 331readDatagram()(QUdpSocket), 336readFile()(Spreadsheet), 82readHeaderIfNecessary()(CursorHandler),406readLine()QIODevice, 333QTextStream, 280,282ReadOnly(QIODevice), 82read-only iterators, 256,257,258readRawBytes()(QDataStream), 277readSettings()MailClient, 148readSettings()(continued)MainWindow, 67,152SettingsViewer, 223read-write iterators, 254,255–256,258,262read/write locks, 386–387readyRead()QFtp, 320QHttp, 323QIODevice, 325,327,328,330,331,333,336readyReadStandardError()(QProcess), 288recalculate()(Spreadsheet), 87received()(QCopChannel), 440recently opened files, 50,59–60record()(QSqlTableModel), 297–299,309rect()(QImage), 112rectangles, 111,125–126recursive-descent parsers, 96reentrancy, 396reference counting, 259,397reference documentation, 9–11,490reference types (Java and C#), 480–481references (C++), 463,466–468refreshPixmap()(Plotter), 129refreshTrackViewHeader()(MainForm), 309regExpChanged()(RegExpModel), 243RegExpModelclass definition, 240RegExpModel(), 241columnCount(), 242data(), 242headerData(), 243index(), 241nodeFromIndex(), 241parent(), 242regExpChanged(), 243rowCount(), 242setRootNode(), 241RegExpParser, 239,243–244Regexp Parser example, 238–244Region(X11), 418registry (Windows), 67-regserveroption (ActiveX servers), 430regsvr32, 428regular expressions, 28,98,102,230,238reinterpret_cast<T>(), 477reject()(QDialog), 28,33,63Rejected(QDialog), 28,63Release()(IUnknown), 423,426release()QSemaphore, 387,388"},{"pageNumber":544,"pageContent":"526Indexrelease()(continued)QSessionManager, 435releaseDC()(QPaintEngine), 417release mode, 408remove()DirectoryViewer, 228Java-style iterators, 255QFile, 286QFtp, 314QString, 267removeAll()(QList<T>), 59removePostedEvent()(QCoreApplication),396removePostedEvents()(QCoreApplication),396removeRow()(QAbstractItemModel), 304removeRows()(QAbstractItemModel), 226,299rename()QDir, 286QFtp, 314render hints, 178,413repaint()(QWidget), 108repainting, 107,108,112reparenting, 9,17,53,149replace()(QString), 212,267request()(QHttp), 322requestFinished()(QHttp), 322requestPropertyChange()(QAxBindable),425–426requestStarted()(QHttp), 322reserve()(QHash<K,T>), 261reset()(QAbstractItemModel), 234resize()(QWidget), 139resizeEvent()(QWidget), 124–125,139resizeGL()(Tetrahedron), 200ResizeTransaction, 395resizing widgets, 112,139–140resolution (of a paint device), 182,192resource files, 47–48,286–287for storing images, 47,121,352for storing translations, 369–370localization, 371RESOURCESentry (.profiles), 47,121,286,370restart command, 434restore()(QPainter), 180,188restoreOverrideCursor()(QApplication),80,126restoreState()QMainWindow, 152QSplitter, 148TicTacToe, 437result sets, 295,297retranslateUi()JournalView, 376MainWindow, 373Ui::classes, 376retrieveData()QMimeData, 210,213TableMimeData, 213reverse layouts, 9,170,369,370RGB format, 106,189RgnHandle(Mac OS X), 418rich text, 38,192,352See alsoHTMLright()(QString), 266,267rightColumn()(QTableWidgetSelectionRange), 64right mouse button, 111,201right-to-left languages, 9,369,370rmdir()QDir, 286QFtp, 314rollback()(QSqlDatabase), 296ROMAN8, 365rotate()QMatrix, 182QPainter, 183,187RoundCap(Qt), 177RoundJoin(Qt), 177round rectangles, 176row()(QModelIndex), 231,233RowCount(Spreadsheet), 76,77rowCount()CityModel, 236CurrencyModel, 233RegExpModel, 242RTTI, 476rubber bands, 116–117,125–127,129run()QThread, 382,388,389,390,394,396Thread, 382,385TransactionThread, 394running applications, 4,454running external programs, 287run-time type information, 476Russian, 365SSAFEARRAY()(Windows), 421sample programs.Seeexamplessave()Editor, 159"},{"pageNumber":545,"pageContent":"Index527save()(continued)MainWindow, 57,155QDomNode, 348QPainter, 180,188saveAs()(MainWindow), 57saveFile()(MainWindow), 57saveState()QApplication, 431,433QMainWindow, 152QSplitter, 148TicTacToe, 436-savefontoption (Qtopia applications),442SAX, 339–344SaxHandlerclass definition, 341inheritance tree, 340SaxHandler(), 341characters(), 342endElement(), 343fatalError(), 343startElement(), 342SAX Handler example, 340–344scale()(QPainter), 183ScientificNotation(QTextStream), 281Screen(X11), 418screen drivers, 442scroll()PlotSettings, 132QWidget, 168ScrollBarAlwaysOn(Qt), 149scroll bars, 38,39,77,129,148scrollTo()(QTreeView), 228SDI, 71secondary threads, 391seek()QIODevice, 273,279,326QSqlQuery, 295segmentation fault, 464select()(QSqlTableModel), 297,298,304SELECTstatement, 294selectAll()(QAbstractItemView), 86selectColumn()(QAbstractItemView), 86selectCurrentColumn()(Spreadsheet), 86selectCurrentRow()(Spreadsheet), 86selectRow()(QAbstractItemView), 86selectedId()(FlowChartSymbolPicker),219selectedRange()(Spreadsheet), 84selectedRanges()(QTableWidget), 84Selection(QClipboard), 215selectionModel()(QAbstractItemView),306semaphores, 387–389semaphoresexample, 387–389semi-transparency, 106,189,190send()(QCopChannel), 440sendDatagram()(WeatherBalloon), 334sendRequest()(TripPlanner), 326sender()(QObject), 60,247separator()(QDir), 289separatorsin file names, 286in menu bars, 51in menus, 50in toolbars, 52sequential containers, 252–260sequential devices, 279server (Qtopia Core), 440-sessionoption (X11 applications), 434,436sessionFileName()(TicTacToe), 436sessionId()(QApplication), 436sessionKey()(QApplication), 436session management, 431–437setAcceptDrops()(QWidget), 206,208,212setAllowedAreas()(QDockWidget), 151setAttribute()(QWidget), 70setAutoDetectUnicode()(QTextStream),364setAutoFillBackground()(QWidget), 120setAutoRecalculate()(Spreadsheet), 88setBackgroundRole()(QWidget), 119–120,129setBit()(QBitArray), 407setBrush()(QPainter), 176setBuddy()(QLineEdit), 15setByteOrder()(QDataStream), 404setCentralWidget()(QMainWindow), 46setCheckable()(QAction), 49setChecked()(QAction), 156setCities()(CityModel), 238setClipRect()(QPainter), 131setCodec()(QTextStream), 280,363–364setCodecForCStrings()(QTextCodec), 365setCodecForTr()(QTextCodec), 364,378setColor()(AxBouncer), 425setColorAt()(QGradient), 179,186–187setColumnCount()(QTableView), 77setColumnRange()(SortDialog), 34,64setCompositionMode()(QPainter), 190setContent()(QDomDocument), 346setContentHandler()(QXmlSimpleReader),344setContext()(QShortcut), 165setContextMenuPolicy()(QWidget), 51setControl()(QAxWidget), 420setCorner()(QMainWindow), 151"},{"pageNumber":546,"pageContent":"528IndexsetCurrencyMap()(CurrencyModel), 234setCurrentCell()(QTableWidget), 63setCurrentFile()Editor, 159MainWindow, 58setCurrentIndex()QStackedLayout, 143,144,145QStackedWidget, 36setCurrentInputMethod()(QWSServer), 442setCurrentRow()(QListWidget), 144setCursor()(QWidget), 126setCurveData()(Plotter), 122setData()Cell, 93CityModel, 237item classes, 78,93QAbstractItemModel, 237,298,299QListWidgetItem, 220QMimeData, 210,211setDatabaseName()(QSqlDatabase), 294setDefault()(QPushButton), 15setDirty()(Cell), 93setDiscardCommand()(QSessionManager),433setDropAction()(QDropEvent), 209,210setDuration()(OvenTimer), 184setEditTriggers()(QAbstractItemView),220,222,225setEditorData()(TrackDelegate), 247setEnabled()QAction, 156QWidget, 15,18setEnabledOptions()(QPrintDialog), 196setErrorHandler()(QXmlSimpleReader),344setFeatures()(QDockWidget), 150setFieldAlignment()(QTextStream), 281setFieldWidth()(QTextStream), 281setFilter()(QSqlTableModel), 297setFilterKeyColumn()(QSortFilterProxyModel), 229setFilterRegExp()(QSortFilterProxyModel), 230setFixedHeight()(QWidget), 17SetFixedSize(QLayout), 35setFixedSize()(QWidget), 138setFocus()(QWidget), 158setFocusPolicy()(QWidget), 120setFont()(QPainter), 176setFormat()(QGLWidget), 199setFormula()Cell, 93Spreadsheet, 79,283setForwardOnly()(QSqlQuery), 295setGenerateByteOrderMark()(QTextStream), 363setGeometry()(QWidget), 68,138setHorizontalHeaderLabels()(QTableWidget), 221setHorizontalScrollBarPolicy()(QAbstractScrollArea), 149setHost()(QHttp), 321,322setHostName()(QSqlDatabase), 294setHtml()QMimeData, 211QTextDocument, 193setIcon()(QListWidgetItem), 220setIconImage()(IconEditor), 107setImage()QClipboard, 215TransactionThread, 394setImagePixel()(IconEditor), 111setIntegerBase()(QTextStream), 281SetInterfaceSafetyOptions()(ObjectSafetyImpl), 427setItem()(QTableWidget), 79,222setItemDelegate()(QAbstractItemView),245setItemPrototype()(QTableWidget), 76,92setLayout()(QWidget), 7,9setLayoutDirection()(QApplication), 369setLocalData()(QThreadStorage<T>), 391setMargin()(QLayout), 140setMatrix()(QPainter), 182setMimeData()(QClipboard), 215setMinimumSize()(QWidget), 35,53,139setModal()(QDialog), 62,172setModel()(QAbstractItemView), 225setModelData()(TrackDelegate), 248setModified()(QTextDocument), 160setMouseTracking()(QWidget), 111setNum()(QString), 266setNumberFlags()(QTextStream), 281setOverrideCursor()(QApplication), 80,126setPadChar()(QTextStream), 281setPassword()(QSqlDatabase), 294setPen()(QPainter), 109,176setPenColor()(IconEditor), 107setPixel()(QImage), 112setPixmap()QClipboard, 215QDrag, 209QSplashScreen, 72setPlainText()(QTextEdit), 145setPlotSettings()(Plotter), 121setPrintProgram()(QPrinter), 191setProperty()(QObject), 422"},{"pageNumber":547,"pageContent":"Index529setRadius()(AxBouncer), 426setRange()QAbstractSlider, 7QAbstractSpinBox, 7QProgressDialog, 172setRealNumberNotation()(QTextStream),281setRealNumberPrecision()(QTextStream),281setRelation()(QSqlRelationalTableModel), 305,307setRenderHint()(QPainter), 178,185,413setRootNode()(RegExpModel), 241setRowCount()(QTableView), 77setSelectionMode()QAbstractItemView, 212QTableWidget, 76,212setShortcutContext()(QAction), 165setShowGrid()(QTableView), 49setSingleShot()(QTimer), 184setSizeConstraint()(QLayout), 34setSizePolicy()(QWidget), 105,107,120,422setSizes()(QSplitter), 147setSocketDescriptor()(QTcpSocket), 330setSourceModel()(QAbstractProxyModel),229setSpacing()(QLayout), 140setSpeed()(AxBouncer), 426setStatusTip()(QAction), 351setStretchFactor()(QSplitter), 147setStringList()(QStringListModel), 225setStyle()(QWidget), 124setTabOrder()(QWidget), 19setTable()(QSqlTableModel), 297setText()QAbstractButton, 35QClipboard, 83,215QLabel, 54QListWidgetItem, 220QMimeData, 211QTreeWidgetItem, 342,347Ticker, 167setToolTip()QAction, 351QWidget, 351setUser()(QHttp), 322setUserName()(QSqlDatabase), 294setValue()Java-style iterators, 256,262QAbstractSlider, 7–8QProgressDialog, 173QSettings, 67setValue()(continued)QSpinBox, 7setVersion()(QDataStream), 81,274,275,277–278setVerticalScrollBarPolicy()(QAbstractScrollArea), 149setViewport()(QPainter), 185setVisible()QAction, 49,59QWidget, 33setWhatsThis()(QWidget), 352setWidget()QDockWidget, 151QScrollArea, 149setWidgetResizable()(QScrollArea), 149setWindow()(QPainter), 182,185setWindowIcon()(QWidget), 46setWindowModified()(QWidget), 54,158,160setWindowTitle()(QWidget), 7,17,58–59,160setZoomFactor()(IconEditor), 107setlocale()(std), 370sets, 262settings, 67–68,148,152,223SettingsViewerSettingsViewer(), 223addChildSettings(), 224readSettings(), 223Settings Viewer example, 222–224setupUi()(Ui::classes), 26–27,288shallow copy.Seeimplicit sharingShape, 460shape-changing dialogs, 29–36shared classes, 257,259,397,439,471shared libraries, 399,456shear()(QPainter), 183Shiftkey, 111,164Shift-JIS, 365shortcut keys, 16,25,48,165,353See alsoaccelerator keysshow()(QWidget), 3,61–62,121,142ShowBase(QTextStream), 281showEvent()(Ticker), 167showMessage()(QStatusBar), 56showPage()(HelpBrowser), 355,357showbasemanipulator, 280shutdown, 432,434signals and slotsautomatic connections, 28,288compared with events, 163connecting, 6,8,20–34,21,32–34declaring, 14,20"},{"pageNumber":548,"pageContent":"530Indexsignals and slots (continued)disconnecting, 21dynamic slot invocation, 397emitting signals, 18establishing connections inQt Designer, 32–34implementing slots, 18,22in ActiveX subclasses, 423in multithreaded applications,391–395parameter types, 21Q_ENUMS()macro, 420,424return values for slots, 45SIGNAL()andSLOT()macros, 6,20signalsandslotspseudo-keywords,14,21simplified()(QString), 268single document interface (SDI), 71single-shot timers, 168,184single-valued hashes, 262single-valued maps, 261Sinhala, 362size()(QFontMetrics), 167sizeHintproperty (QSpacerItem), 32sizeHint()Editor, 160IconEditor, 106Plotter, 123QWidget, 17,35,53,106,123,143,160,167Ticker, 167size hints, 17,35,53,107,121,140,142–143size policies, 107,120,142sizeof()operator, 469sizes()(QSplitter), 256skip-lists, 260skipRawData()(QDataStream), 404slash (/), 286slash (C), 67sliders, 7,39slotsautomatic connections, 28,288connecting to a signal, 6,8,20–34,21,32–34declaring, 14,20disconnecting, 21dynamic invocation, 397establishing connections inQt Designer, 32–34implementing, 18,22in ActiveX subclasses, 423in multithreaded applications,391–395slots (continued)parameter types, 21Q_ENUMS()macro, 420,424return values, 45SLOT()macro, 6,20slotspseudo-keyword, 15,21Smalltalk, 217SmartNotation(QTextStream), 281SmcConn(X11), 418SmoothPixmapTransform(QPainter), 413sockets.SeeQTcpSocketSolidLine(Qt), 177SolidPattern(Qt), 177somethingChanged()(Spreadsheet), 80sort()MainWindow, 64Spreadsheet, 88SortDialogclass definition, 34creating usingQt Designer, 29–35usage, 64,65SortDialog, 34setColumnRange(), 34,64SortDialog, 34Sort example, 29–35,63sorting model, 228Source(composition mode), 190source()(QDropEvent), 209SourceAtop(composition mode), 190SourceIn(composition mode), 190SourceOut(composition mode), 190SourceOver(composition mode), 190Spacekey, 168spacer items, 17,24,32,141spaces (in text), 267–268,283spacing (in layouts), 140spanX()(PlotSettings), 118spanY()(PlotSettings), 118SPARC, 457specializing.SeesubclassingSpiderclass definition, 315Spider(), 316done(), 317ftpDone(), 317ftpListInfo(), 317getDirectory(), 316processNextDirectory(), 316spiderexample, 315–320spin boxes, 7,39,101–103splash screens, 71–72splines, 176,178split()(QString), 85,268,282"},{"pageNumber":549,"pageContent":"Index531Splitter example, 145–146splitters, 74,145–148Spreadsheetclass definition, 75inheritance tree, 74ColumnCount, 76,77MagicNumber, 76,81RowCount, 76,77Spreadsheet(), 76autoRecalculate(), 75cell(), 78clear(), 77copy(), 83currentFormula(), 80currentLocation(), 79cut(), 83del(), 85findNext(), 86findPrevious(), 86formula(), 78modified(), 75,80paste(), 84readFile(), 82recalculate(), 87selectCurrentColumn(), 86selectCurrentRow(), 86selectedRange(), 84setAutoRecalculate(), 88setFormula(), 79,283somethingChanged(), 80sort(), 88text(), 78writeFile(), 80,172,282SpreadsheetCompare, 64,76,89–91Spreadsheet example, 43–72,73–99spreadsheetModified()(MainWindow), 54sprintf()(QString), 265SQL, 225,293–310SQLite, 293,447Square, 89–90square(), 453–456SquareCap(Qt), 177squeeze()(QHash<K,T>), 261SSL, 322stack memory, 68,464,465stacked layouts, 143–145stacked widgets, 36,143stacks, 253Standard C++library, 251,454,455,456,488–490standard dialogs, 39–40Standard Template Library, 251,258,489–490standard widgets, 37–39start()AxBouncer, 426QDrag, 209QProcess, 289,291QThread, 384QTimer, 334startDocument()(QXmlContentHandler),340startDrag()MyTableWidget, 211ProjectListWidget, 208startDragDistance()(QApplication), 208startElement()(SaxHandler), 342startOrStopThreadA()(ThreadDialog), 384startOrStopThreadB()(ThreadDialog), 384startTimer()(QObject), 167startsWith()(QString), 267stateChanged()(QFtp), 315static_cast<T>(), 476statickeyword, 463,482,483static libraries, 456static linkage, 482static members, 462–463statusBar()(QMainWindow), 53status bars, 46,52–54,351,396StatusTipRole(Qt), 230status tips, 48,52–53,351stdnamespace, 119,454,485,490cerr, 274,288,290,453cin, 274,284cout, 274,284,453endl, 454localeconv(), 370map<K,T>, 262memcpy(), 470ostream, 478pair<T1,T2>, 262,271setlocale(), 370string, 265,274strtod(), 453vector<T>, 471STL, 251,258,489–490STL-style iterators, 256,262stop()AxBouncer, 426Thread, 382,385stopSearch()(TripPlanner), 329stream manipulators, 280,478,489streaming, 81,274–285,478,489stretch factors, 53,143,147stretches.Seespacer itemsstring(std), 265,274stringList()(QStringListModel), 226"},{"pageNumber":550,"pageContent":"532Indexstrings, 265–269,471–473strippedName()(MainWindow), 58StrongARM, 439StrongFocus(Qt), 120Stroustrup, Bjarne, 451strtod()(std), 453structkeyword, 458style()QApplication, 124QWidget, 124-styleoption (Qt applications), 11,160styles, 11,51,124subclassingbuilt-in widgets, 101–103C++classes, 460–462COM interfaces, 426QAbstractItemModel, 240QAbstractTableModel, 232,235QApplication, 433QAxAggregated, 426QAxBindable, 423QAxObject, 423QAxWidget, 423QDesignerCustomWidgetInterface, 114QDialog, 14,27,34QGLWidget, 199QImageIOHandler, 402QImageIOPlugin, 400QItemDelegate, 245QListWidget, 207QMainWindow, 44,428QMimeData, 212QObject, 21–22,430QSpinBox, 101–103QStyle, 124QTableWidget, 75QTableWidgetItem, 91QTcpServer, 329QTcpSocket, 330QTextEdit, 157QThread, 381,393QTreeWidgetItem, 430QWidget, 104,117,166,183QXmlDefaultHandler, 341Ui::classes, 27,34,288,324subclassng (plugin interfaces), 412sub-layouts, 17,140–141submenus, 50–51submitAll()(QSqlTableModel), 298superkeyword (Java), 462supportsSelection()(QClipboard), 215switchLanguage()(MainWindow), 375Sybase Adaptive Server, 293symbolic links, 317synchronizing threads, 385–390synchronous I/O, 290Syriac, 362system()(QLocale), 369system registry, 67TTabkey, 120,164tab order, 19,25,164tab widgets, 36,38TableMimeData,213class definition, 212formats(), 213retrieveData(), 213table models, 230table views, 38,218,302,305table widgets, 74,218,221–222tabs and newlines format, 84,212tagName()(QDomElement), 346takeFirst()(QList<T>), 282Tamil, 362taskbar, 56Tcl/Tk integration, 415TCP, 311,323–333TDS, 293TeamLeadersDialogTeamLeadersDialog(), 225del(), 226insert(), 226leaders(), 226Team Leaders example, 225–226Telugu, 362template classes, 456,471See alsocontainer classestemplates (Qt Designer), 23,103,144terminate()(QThread), 382Tetrahedronclass definition, 199Tetrahedron(), 199draw(), 200faceAtPosition(), 202initializeGL(), 199mouseDoubleClickEvent(), 201mouseMoveEvent(), 201mousePressEvent(), 201paintGL(), 200resizeGL(), 200Tetrahedron example, 199–203text()QClipboard, 85,215"},{"pageNumber":551,"pageContent":"Index533text()(continued)QLineEdit, 63QMimeData, 210,214QTableWidgetItem, 78,91,93,220QTicker, 166Spreadsheet, 78TextAlignmentRole(Qt), 93–94,230,233,244TextAntialiasing(QPainter), 413TextArtDialogTextArtDialog(), 410loadPlugins(), 410populateListWidget(), 411Text Art example, 408–411TextArtInterfaceapplyEffect(), 412class definition, 409effects(), 412text browsers, 38–39textChanged()(QLineEdit), 16,28TextColorRole(Qt), 230,244text editors, 39text encodings, 214,279,280,349,362–365text engine, 192,361,362textFromValue()(HexSpinBox), 102text I/O, 279–285,323,333Thaana, 362Thai, 362theme engines, 11thiskeyword, 476,479Threadclass definition, 381Thread(), 382run(), 382,385–386stop(), 382,385–386ThreadDialogclass definition, 383ThreadDialog(), 383closeEvent(), 384startOrStopThreadA(), 384startOrStopThreadB(), 384thread-local storage, 390thread-safety, 396thread synchronization, 385–390Threaded Fortune Server example, 333Threads example, 381–384three-button mice, 215three-dimensional graphics, 198–203Tibetan, 362TicTacToeclass definition, 435TicTacToe(), 436TicTacToe(continued)clearBoard(), 436restoreState(), 437saveState(), 436sessionFileName(), 436Tic-Tac-Toe example, 432–437Tickerclass definition, 166Ticker(), 166hideEvent(), 168paintEvent(), 167setText(), 167showEvent(), 167sizeHint(), 167timerEvent(), 168Ticker example, 165–168tidyexample, 283–284tile()(QWorkspace), 156time, 185time editors, 39,370timeout()OvenTimer, 183QTimer, 168,184,334timerEvent()PlayerWindow, 422QObject, 168,173,422Ticker, 168timer events, 165–168timers0-millisecond, 173single-shot, 168,184timerEvent()vs.QTimer, 168TIS-620, 365title bars, 7,56,150TLS (thread-local storage), 390to... ()(QVariant), 270toAscii()(QString), 269toBack()(Java-style iterators), 255toCsv()(MyTableWidget), 211toDouble()(QString), 95,266toElement()(QDomNode), 346toHtml()(MyTableWidget), 211toInt()(QString), 63,103,266,283toLatin1()QChar, 363QString, 269toLongLong()(QString), 266toLower()(QString), 264,267toStdString()(QString), 274toString()QDate, 370QDateTime, 370QTime, 370"},{"pageNumber":552,"pageContent":"534IndextoString()(continued)QVariant, 94toText()(QDomNode), 347toUnicode()(QTextCodec), 365toUpper()(QString), 103,267toggle buttons, 29,37,49toggled()QAbstractButton, 33–34QAction, 49tool buttons, 37ToolTipRole(Qt), 230toolbars, 47,52,150–152toolboxes, 38toolTip()(IconEditorPlugin), 115tooltips, 115,351top()(QStack<T>), 253top-level widgets.SeewindowstopLevelWidgets()(QApplication), 71tr()(QObject), 16,22,361,364,365–368,374,377–378Track, 245TrackDelegateclass definition, 245usage, 306TrackDelegate(), 246commitAndCloseEditor(), 247createEditor(), 247paint(), 246setEditorData(), 247setModelData(), 248TrackEditor, 245Track Editor example, 244–248tracking mouse moves, 111Transactionclass definition, 395apply(), 395message(), 396transaction()(QSqlDatabase), 296transactionStarted()(TransactionThread), 395TransactionThreadclass definition, 393addTransaction(), 394image(), 394run(), 394setImage(), 394transactionStarted(), 395transfer mode (FTP), 314transfer type (FTP), 314transformations, 109,182–183translate()QCoreApplication, 367QMatrix, 182translate()(continued)QPainter, 183translating applications, 16,361,365–371,376–379TRANSLATIONSentry (.profiles), 377transparency, 106,189,190TransparentMode(Qt), 180transpose(), 468traversing directories, 285–286tree models, 230tree views, 38,218,227,243tree widgets, 36,218,222–224,340,344,348triggered()QAction, 48QActionGroup, 375trimmed()(QString), 267–268TripPlannerclass definition, 324TripPlanner(), 324closeConnection(), 328connectToServer(), 325connectionClosedByServer(), 329error(), 329sendRequest(), 326stopSearch(), 329updateTableWidget(), 327Trip Planner example, 323–329TripServerclass definition, 329TripServer(), 330incomingConnection(), 330Trip Server example, 323,329–332Truck, 462–463TrueType, 442truncate()(QString), 259tryLock()(QMutex), 385.tsfiles, 377–379TSCII, 365TSD (thread-specific data), 390TTF, 442two-dimensional graphics, 175–203Type 1, 442type()QEvent, 163,164QVariant, 270typedefkeyword, 475"},{"pageNumber":553,"pageContent":"Index535UUCS-2 (UTF-16), 363–364UDP, 311,333–337UI builder.See Qt DesignerUi::classes, 26–27,34,288,324.uifiles, 26–29,36,288,324,377uic, 26–29,36,114,288,324,376#undefdirective, 487undefined references.SeeunresolvedsymbolsungetChar()(QIODevice), 279Unicode, 265,279,280,296,362–365,473unicode()(QChar), 363uniform resource locators (URLs), 312universal resource identifiers (URIs),206universal resource locators (URLs), 206,207Unix, 415–419,449–450unlock()QMutex, 385,387QReadWriteLock, 386unordered associative containers.Seehashes-unregserveroption (ActiveX servers),430unresolved symbols, 19,456,460,463unsetCursor()(QWidget), 126unsignedkeyword, 456–457untitled documents, 158update()(QWidget), 87,107,108,112,121–122,129,167,168,185updateGeometry()(QWidget), 107,167updateGL()(QGLWidget), 201,202updateMenus()(MainWindow), 155updateOutputTextEdit()(ConvertDialog),290updateRecentFileActions()(MainWindow),59updateRubberBandRegion()(Plotter), 129updateStatusBar()(MainWindow), 54updateTableWidget()(TripPlanner), 327updateWindowTitle()(HelpBrowser), 355UppercaseBase(QTextStream), 281UppercaseDigits(QTextStream), 281uppercasedigitsmanipulator, 280URIs, 206URLs, 206,207,312urls()(QMimeData), 207,214user actions, 5,163,217user interface compiler (uic), 26–29,36,114,324,376UserRole(Qt), 220usingdeclaration, 485using namespacedirective, 454,485UTF-8, 214,280,349,364,365UTF-16 (UCS-2), 363–364,365VValgrind, 457validate()QAbstractSpinBox, 102QValidator, 102validating XML parsers, 339,344validators, 28,102value()Cell, 94Java-style iterators, 131,262QMap<K,T>, 260–261QSettings, 67QSqlQuery, 295QSqlTableModel, 297STL-style iterators, 262value<T>()(QVariant), 270value binding (SQL), 295–296valueChanged()QAbstractSlider, 7–8QSpinBox, 7valueFromText()(HexSpinBox), 103value types, 253–254,480–481values()(associative containers), 261,263variable-length arrays, 271VARIANT(Windows), 421VARIANT_BOOL(Windows), 421variants, 60,105,269–271,295,422vector<T>(std), 471vector paths.SeeQPainterPathvectors, 252,471VerPattern(Qt), 177version of data stream, 81,274,275,277–278version of operating system, 417version of Qt, 4,5,81,447,475verticalHeader()(QTableView), 77vertical layouts, 9,25,140verticalScrollBar()(QAbstractScrollArea), 77,148Vietnamese, 362viewportof a painter, 180,181–182,185–186of a scroll area, 77,149"},{"pageNumber":554,"pageContent":"536Indexviewport()(QAbstractScrollArea), 77,148,149views, 217–218virtual destructors, 395virtual frame buffer, 441virtual functions, 408,409,461virtual machines, 439visible widgets, 4,62,121Visual Basic, 428Visual C++(MSVC), 5,19,36,271,417Visual Studio, 5VNC (Virtual Network Computing),441voidpointers, 78,241,477volatilekeyword, 382WW3C, 344WA_DeleteOnClose(Qt), 70,155,158,356WA_GroupLeader(Qt), 355WA_PaintOnScreen(Qt), 417WA_StaticContents(Qt), 106,112wait()QThread, 384QWaitCondition, 389,390wait conditions, 389–390wait cursor, 81waitForDisconnected()(QAbstractSocket),397waitForFinished()(QProcess), 291,397waitForStarted()(QProcess), 291waitconditionsexample, 389–390wakeAll()(QWaitCondition), 389warning()(QMessageBox), 55wasCanceled()(QProgressDialog), 172WeatherBalloon, 333–334Weather Balloon example, 333–335WeatherStationclass definition, 335WeatherStation(), 335processPendingDatagrams(), 336Weather Station example, 333,335–337whatsThis()(IconEditorPlugin), 115What’s This?, 115,352–353WhatsThisRole(Qt), 230wheelEvent()(Plotter), 128whitespace, 267–268widget stacks.Seestacked widgetswidgetsattributes, 70widgets (continued)background, 109,120,129built-in, 37–39,73,104coordinate system, 109,112,127custom, 101–134disabled, 16,110,170fixed size, 143focus policy, 120geometry, 138hidden, 4,62,142,325minimum and maximum size, 140,143names, 432palette, 109–110,120parent–child mechanism, 7platform-specific ID, 415properties, 22,24,105,422,425–426reparenting, 9,53,149size hint, 17,35,53,107,121,140,142–143size policy, 107,120,142styles, 11,51,124terminology, 3See alsowindowswidth()(QPaintDevice), 109,112wildcard characters, 56,229,285Win32 API, 415,417winEvent()(QWidget), 419winEventFilter()(QApplication), 419winId()(QWidget), 415–416,418window (of a painter), 180,181–182,185–186Window(X11), 418windowActivated()(QWorkspace), 154window managers, 431windowMenuAction()(Editor), 157Windowmenus (MDI), 153,156windowModifiedproperty (QWidget), 54,55,58,158windows, 4active, 62,110,154closing, 5,16decorations, 442icon, 46MDI children, 153platform-specific ID, 415title bar, 7,56,150See alsowidgetsWindows (Microsoft)12xxencodings, 365classic style, 11,51,124hibernation, 432Media Player, 419"},{"pageNumber":555,"pageContent":"Index537Windows (Microsoft) (continued)native APIs, 415–419registry, 67version, 417XP style, 11,124WindowsVersion(QSysInfo), 417WINSAMI2, 365world matrix, 180,182–183World Wide Web Consortium, 344write()(QIODevice), 278,327,332writeDatagram()(QUdpSocket), 334,337writeFile()(Spreadsheet), 80,172,282WriteOnly(QIODevice), 80,274writeRawBytes()(QDataStream), 277writeSettings()MailClient, 148MainWindow, 67,152writing systems, 362XX Render extension, 188,189X Window System (X11)installing Qt, 449–450native APIs, 415–419selection clipboard, 215session management, 431–437x11Event()(QWidget), 419x11EventFilter()(QApplication), 419x11Info()QPixmap, 418QWidget, 418x11PictureHandle()QPixmap, 418QWidget, 418x11Screen()(QCursor), 418XBM, 46Xcode, 5XEvent(X11), 418Xlib, 415XMLencodings, 364.qrcfiles, 47,286reading documents, 339–348SAX vs. DOM, 339.tsfiles, 377.uifiles, 29validation, 339,344writing documents, 348–349Xor(composition mode), 190XP style, 11,124XPM, 46,47xsm, 437Xt migration, 415Zzlib.Seedata compressionzoomIn()(Plotter), 122zoomOut()(Plotter), 122"},{"pageNumber":556,"pageContent":"About the AuthorsJasmin BlanchetteJasmin graduated in computer science in 2001 from the University of Sher-brooke, Quebec. He did a work term at Trolltech in the summer of 2000 as asoftware engineer and has been working there continuously since early 2001.In 2003, Jasmin co-wroteC++GUI Programming with Qt 3. He now combinesthe roles of Trolltech’s documentation manager and senior software engineer.He was the driving force behind theQt Linguisttranslation tool and is stilla key player in Qt 4’s container classes. He is also co-editor ofQt Quarterly,Trolltech’s technical newsletter.Mark SummerfieldMark graduated in computer science in 1993 from the University of WalesSwansea. He followed this with a year’s postgraduate research before goinginto industry. He spent many years working as a software engineer for a vari-ety of firms before joining Trolltech. He spent almost three years as Trolltech’sdocumentation manager, during which he foundedQt Quarterlyand co-wroteC++GUI Programming with Qt 3. Mark owns Qtraining.eu and works as anindependent trainer and consultant specializing in C++, Qt, and Python.ProductionThe authors wrote the text using NEdit and Vim. They typeset and indexedthe text themselves, marking it up with a modified Lout syntax that they con-verted to pure Lout using a custom preprocessor written in Python. They pro-duced all the diagrams in Lout and used ImageMagick and KView to convertscreenshots to PostScript. The monospaced font used for code is derived froman early version of Crystal and was modified using FontForge. The cover wasprovided by the publisher. The marked-up text was converted to PostScript byLout, then to PDF by Ghostscript. The authors did all the editing and process-ing on Debian GNU/Linux and Fedora Core systems under KDE. The exampleprograms were tested on Windows, Linux, and Mac OS X."}]
